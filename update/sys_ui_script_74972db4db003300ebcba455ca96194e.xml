<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_ui_script">
    <sys_ui_script action="INSERT_OR_UPDATE">
        <active>true</active>
        <description/>
        <global>false</global>
        <name>x_317887_amazon.amazon-connect-1.0</name>
        <script>/*&#13;
 * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.&#13;
 *&#13;
 * Licensed under the Amazon Software License (the "License"). You may not use&#13;
 * this file except in compliance with the License. A copy of the License is&#13;
 * located at&#13;
 *&#13;
 *    http://aws.amazon.com/asl/&#13;
 *&#13;
 * or in the "license" file accompanying this file. This file is distributed&#13;
 * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express&#13;
 * or implied. See the License for the specific language governing permissions&#13;
 * and limitations under the License.&#13;
 */&#13;
(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){&#13;
  module.exports={&#13;
    "version": "2.0",&#13;
    "metadata": {&#13;
      "apiVersion": "2014-06-30",&#13;
      "endpointPrefix": "cognito-identity",&#13;
      "jsonVersion": "1.1",&#13;
      "protocol": "json",&#13;
      "serviceFullName": "Amazon Cognito Identity",&#13;
      "signatureVersion": "v4",&#13;
      "targetPrefix": "AWSCognitoIdentityService"&#13;
    },&#13;
    "operations": {&#13;
      "CreateIdentityPool": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityPoolName",&#13;
            "AllowUnauthenticatedIdentities"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityPoolName": {},&#13;
            "AllowUnauthenticatedIdentities": {&#13;
              "type": "boolean"&#13;
            },&#13;
            "SupportedLoginProviders": {&#13;
              "shape": "S4"&#13;
            },&#13;
            "DeveloperProviderName": {},&#13;
            "OpenIdConnectProviderARNs": {&#13;
              "shape": "S8"&#13;
            },&#13;
            "CognitoIdentityProviders": {&#13;
              "shape": "Sa"&#13;
            },&#13;
            "SamlProviderARNs": {&#13;
              "shape": "Se"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "shape": "Sf"&#13;
        }&#13;
      },&#13;
      "DeleteIdentities": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityIdsToDelete"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityIdsToDelete": {&#13;
              "type": "list",&#13;
              "member": {}&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "UnprocessedIdentityIds": {&#13;
              "type": "list",&#13;
              "member": {&#13;
                "type": "structure",&#13;
                "members": {&#13;
                  "IdentityId": {},&#13;
                  "ErrorCode": {}&#13;
                }&#13;
              }&#13;
            }&#13;
          }&#13;
        }&#13;
      },&#13;
      "DeleteIdentityPool": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityPoolId"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityPoolId": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "DescribeIdentity": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityId"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityId": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "shape": "Sq"&#13;
        }&#13;
      },&#13;
      "DescribeIdentityPool": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityPoolId"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityPoolId": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "shape": "Sf"&#13;
        }&#13;
      },&#13;
      "GetCredentialsForIdentity": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityId"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityId": {},&#13;
            "Logins": {&#13;
              "shape": "Sv"&#13;
            },&#13;
            "CustomRoleArn": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "IdentityId": {},&#13;
            "Credentials": {&#13;
              "type": "structure",&#13;
              "members": {&#13;
                "AccessKeyId": {},&#13;
                "SecretKey": {},&#13;
                "SessionToken": {},&#13;
                "Expiration": {&#13;
                  "type": "timestamp"&#13;
                }&#13;
              }&#13;
            }&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetId": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityPoolId"&#13;
          ],&#13;
          "members": {&#13;
            "AccountId": {},&#13;
            "IdentityPoolId": {},&#13;
            "Logins": {&#13;
              "shape": "Sv"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "IdentityId": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetIdentityPoolRoles": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityPoolId"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityPoolId": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "IdentityPoolId": {},&#13;
            "Roles": {&#13;
              "shape": "S17"&#13;
            }&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetOpenIdToken": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityId"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityId": {},&#13;
            "Logins": {&#13;
              "shape": "Sv"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "IdentityId": {},&#13;
            "Token": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetOpenIdTokenForDeveloperIdentity": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityPoolId",&#13;
            "Logins"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityPoolId": {},&#13;
            "IdentityId": {},&#13;
            "Logins": {&#13;
              "shape": "Sv"&#13;
            },&#13;
            "TokenDuration": {&#13;
              "type": "long"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "IdentityId": {},&#13;
            "Token": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "ListIdentities": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityPoolId",&#13;
            "MaxResults"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityPoolId": {},&#13;
            "MaxResults": {&#13;
              "type": "integer"&#13;
            },&#13;
            "NextToken": {},&#13;
            "HideDisabled": {&#13;
              "type": "boolean"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "IdentityPoolId": {},&#13;
            "Identities": {&#13;
              "type": "list",&#13;
              "member": {&#13;
                "shape": "Sq"&#13;
              }&#13;
            },&#13;
            "NextToken": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "ListIdentityPools": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "MaxResults"&#13;
          ],&#13;
          "members": {&#13;
            "MaxResults": {&#13;
              "type": "integer"&#13;
            },&#13;
            "NextToken": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "IdentityPools": {&#13;
              "type": "list",&#13;
              "member": {&#13;
                "type": "structure",&#13;
                "members": {&#13;
                  "IdentityPoolId": {},&#13;
                  "IdentityPoolName": {}&#13;
                }&#13;
              }&#13;
            },&#13;
            "NextToken": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "LookupDeveloperIdentity": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityPoolId"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityPoolId": {},&#13;
            "IdentityId": {},&#13;
            "DeveloperUserIdentifier": {},&#13;
            "MaxResults": {&#13;
              "type": "integer"&#13;
            },&#13;
            "NextToken": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "IdentityId": {},&#13;
            "DeveloperUserIdentifierList": {&#13;
              "type": "list",&#13;
              "member": {}&#13;
            },&#13;
            "NextToken": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "MergeDeveloperIdentities": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "SourceUserIdentifier",&#13;
            "DestinationUserIdentifier",&#13;
            "DeveloperProviderName",&#13;
            "IdentityPoolId"&#13;
          ],&#13;
          "members": {&#13;
            "SourceUserIdentifier": {},&#13;
            "DestinationUserIdentifier": {},&#13;
            "DeveloperProviderName": {},&#13;
            "IdentityPoolId": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "IdentityId": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "SetIdentityPoolRoles": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityPoolId",&#13;
            "Roles"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityPoolId": {},&#13;
            "Roles": {&#13;
              "shape": "S17"&#13;
            }&#13;
          }&#13;
        }&#13;
      },&#13;
      "UnlinkDeveloperIdentity": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityId",&#13;
            "IdentityPoolId",&#13;
            "DeveloperProviderName",&#13;
            "DeveloperUserIdentifier"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityId": {},&#13;
            "IdentityPoolId": {},&#13;
            "DeveloperProviderName": {},&#13;
            "DeveloperUserIdentifier": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "UnlinkIdentity": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "IdentityId",&#13;
            "Logins",&#13;
            "LoginsToRemove"&#13;
          ],&#13;
          "members": {&#13;
            "IdentityId": {},&#13;
            "Logins": {&#13;
              "shape": "Sv"&#13;
            },&#13;
            "LoginsToRemove": {&#13;
              "shape": "Sr"&#13;
            }&#13;
          }&#13;
        }&#13;
      },&#13;
      "UpdateIdentityPool": {&#13;
        "input": {&#13;
          "shape": "Sf"&#13;
        },&#13;
        "output": {&#13;
          "shape": "Sf"&#13;
        }&#13;
      }&#13;
    },&#13;
    "shapes": {&#13;
      "S4": {&#13;
        "type": "map",&#13;
        "key": {},&#13;
        "value": {}&#13;
      },&#13;
      "S8": {&#13;
        "type": "list",&#13;
        "member": {}&#13;
      },&#13;
      "Sa": {&#13;
        "type": "list",&#13;
        "member": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "ProviderName": {},&#13;
            "ClientId": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "Se": {&#13;
        "type": "list",&#13;
        "member": {}&#13;
      },&#13;
      "Sf": {&#13;
        "type": "structure",&#13;
        "required": [&#13;
          "IdentityPoolId",&#13;
          "IdentityPoolName",&#13;
          "AllowUnauthenticatedIdentities"&#13;
        ],&#13;
        "members": {&#13;
          "IdentityPoolId": {},&#13;
          "IdentityPoolName": {},&#13;
          "AllowUnauthenticatedIdentities": {&#13;
            "type": "boolean"&#13;
          },&#13;
          "SupportedLoginProviders": {&#13;
            "shape": "S4"&#13;
          },&#13;
          "DeveloperProviderName": {},&#13;
          "OpenIdConnectProviderARNs": {&#13;
            "shape": "S8"&#13;
          },&#13;
          "CognitoIdentityProviders": {&#13;
            "shape": "Sa"&#13;
          },&#13;
          "SamlProviderARNs": {&#13;
            "shape": "Se"&#13;
          }&#13;
        }&#13;
      },&#13;
      "Sq": {&#13;
        "type": "structure",&#13;
        "members": {&#13;
          "IdentityId": {},&#13;
          "Logins": {&#13;
            "shape": "Sr"&#13;
          },&#13;
          "CreationDate": {&#13;
            "type": "timestamp"&#13;
          },&#13;
          "LastModifiedDate": {&#13;
            "type": "timestamp"&#13;
          }&#13;
        }&#13;
      },&#13;
      "Sr": {&#13;
        "type": "list",&#13;
        "member": {}&#13;
      },&#13;
      "Sv": {&#13;
        "type": "map",&#13;
        "key": {},&#13;
        "value": {}&#13;
      },&#13;
      "S17": {&#13;
        "type": "map",&#13;
        "key": {},&#13;
        "value": {}&#13;
      }&#13;
    }&#13;
  }&#13;
  },{}],2:[function(require,module,exports){&#13;
  module.exports={&#13;
    "version": "2.0",&#13;
    "metadata": {&#13;
      "apiVersion": "2017-02-15",&#13;
      "endpointPrefix": "connect",&#13;
      "jsonVersion": "1.0",&#13;
      "protocol": "json",&#13;
      "serviceAbbreviation": "Connect",&#13;
      "serviceFullName": "AmazonConnectCTIService",&#13;
      "signatureVersion": "v4",&#13;
      "targetPrefix": "AmazonConnectCTIService",&#13;
      "uid": "connect-2017-02-15"&#13;
    },&#13;
    "operations": {&#13;
      "AcceptContact": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "contactId"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "contactId": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "ConferenceConnections": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "contactId"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "contactId": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "CreateAdditionalConnection": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "contactId",&#13;
            "endpoint"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "contactId": {},&#13;
            "endpoint": {&#13;
              "shape": "Sa"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "CreateOutboundContact": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "endpoint"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "endpoint": {&#13;
              "shape": "Sa"&#13;
            },&#13;
            "queueARN": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "DestroyConnection": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "contactId",&#13;
            "connectionId"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "contactId": {},&#13;
            "connectionId": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "GetAgentConfiguration": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "configuration"&#13;
          ],&#13;
          "members": {&#13;
            "configuration": {&#13;
              "shape": "Sr"&#13;
            }&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetAgentPermissions": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "nextToken": {},&#13;
            "maxResults": {&#13;
              "type": "integer"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "permissions"&#13;
          ],&#13;
          "members": {&#13;
            "permissions": {&#13;
              "type": "list",&#13;
              "member": {}&#13;
            },&#13;
            "nextToken": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetAgentSnapshot": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "nextToken": {},&#13;
            "timeout": {&#13;
              "type": "long"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "snapshot",&#13;
            "nextToken"&#13;
          ],&#13;
          "members": {&#13;
            "snapshot": {&#13;
              "type": "structure",&#13;
              "required": [&#13;
                "state",&#13;
                "contacts",&#13;
                "snapshotTimestamp"&#13;
              ],&#13;
              "members": {&#13;
                "state": {&#13;
                  "shape": "S17"&#13;
                },&#13;
                "contacts": {&#13;
                  "type": "list",&#13;
                  "member": {&#13;
                    "type": "structure",&#13;
                    "required": [&#13;
                      "contactId",&#13;
                      "type",&#13;
                      "state",&#13;
                      "queueTimestamp",&#13;
                      "connections",&#13;
                      "attributes"&#13;
                    ],&#13;
                    "members": {&#13;
                      "contactId": {},&#13;
                      "initialContactId": {},&#13;
                      "type": {},&#13;
                      "state": {&#13;
                        "type": "structure",&#13;
                        "required": [&#13;
                          "type",&#13;
                          "timestamp"&#13;
                        ],&#13;
                        "members": {&#13;
                          "type": {},&#13;
                          "timestamp": {&#13;
                            "type": "timestamp"&#13;
                          }&#13;
                        }&#13;
                      },&#13;
                      "queue": {&#13;
                        "shape": "Sg"&#13;
                      },&#13;
                      "queueTimestamp": {&#13;
                        "type": "timestamp"&#13;
                      },&#13;
                      "connections": {&#13;
                        "type": "list",&#13;
                        "member": {&#13;
                          "type": "structure",&#13;
                          "required": [&#13;
                            "connectionId",&#13;
                            "state",&#13;
                            "type",&#13;
                            "initial"&#13;
                          ],&#13;
                          "members": {&#13;
                            "connectionId": {},&#13;
                            "endpoint": {&#13;
                              "shape": "Sa"&#13;
                            },&#13;
                            "state": {&#13;
                              "type": "structure",&#13;
                              "required": [&#13;
                                "type",&#13;
                                "timestamp"&#13;
                              ],&#13;
                              "members": {&#13;
                                "type": {},&#13;
                                "timestamp": {&#13;
                                  "type": "timestamp"&#13;
                                }&#13;
                              }&#13;
                            },&#13;
                            "type": {},&#13;
                            "initial": {&#13;
                              "type": "boolean"&#13;
                            },&#13;
                            "softphoneMediaInfo": {&#13;
                              "type": "structure",&#13;
                              "members": {&#13;
                                "callType": {},&#13;
                                "autoAccept": {&#13;
                                  "type": "boolean"&#13;
                                },&#13;
                                "mediaLegContextToken": {},&#13;
                                "callContextToken": {},&#13;
                                "callConfigJson": {}&#13;
                              }&#13;
                            }&#13;
                          }&#13;
                        }&#13;
                      },&#13;
                      "attributes": {&#13;
                        "shape": "S1o"&#13;
                      }&#13;
                    }&#13;
                  }&#13;
                },&#13;
                "snapshotTimestamp": {&#13;
                  "type": "timestamp"&#13;
                }&#13;
              }&#13;
            },&#13;
            "nextToken": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetAgentStates": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "nextToken": {},&#13;
            "maxResults": {&#13;
              "type": "integer"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "states"&#13;
          ],&#13;
          "members": {&#13;
            "states": {&#13;
              "type": "list",&#13;
              "member": {&#13;
                "shape": "S17"&#13;
              }&#13;
            },&#13;
            "nextToken": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetDialableCountryCodes": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "nextToken": {},&#13;
            "maxResults": {&#13;
              "type": "integer"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "countryCodes"&#13;
          ],&#13;
          "members": {&#13;
            "countryCodes": {&#13;
              "type": "list",&#13;
              "member": {}&#13;
            },&#13;
            "nextToken": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetEndpoints": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "queueARNs"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "queueARNs": {&#13;
              "type": "list",&#13;
              "member": {}&#13;
            },&#13;
            "nextToken": {},&#13;
            "maxResults": {&#13;
              "type": "integer"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "endpoints": {&#13;
              "type": "list",&#13;
              "member": {&#13;
                "shape": "Sa"&#13;
              }&#13;
            },&#13;
            "nextToken": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetNewAuthToken": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "refreshToken"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "refreshToken": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "newAuthToken": {},&#13;
            "expirationDateTime": {&#13;
              "type": "timestamp"&#13;
            }&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetRoutingProfileQueues": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "routingProfileARN"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "routingProfileARN": {},&#13;
            "nextToken": {},&#13;
            "maxResults": {&#13;
              "type": "integer"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "queues"&#13;
          ],&#13;
          "members": {&#13;
            "queues": {&#13;
              "type": "list",&#13;
              "member": {&#13;
                "shape": "Sg"&#13;
              }&#13;
            },&#13;
            "nextToken": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "HoldConnection": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "contactId",&#13;
            "connectionId"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "contactId": {},&#13;
            "connectionId": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "NotifyContactIssue": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "contactId"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "contactId": {},&#13;
            "issueCode": {},&#13;
            "description": {},&#13;
            "clientLogs": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "PutAgentState": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "state"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "state": {&#13;
              "shape": "S17"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "ResumeConnection": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "contactId",&#13;
            "connectionId"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "contactId": {},&#13;
            "connectionId": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "SendClientLogs": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "logEvents"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "logEvents": {&#13;
              "type": "list",&#13;
              "member": {&#13;
                "type": "structure",&#13;
                "members": {&#13;
                  "timestamp": {&#13;
                    "type": "timestamp"&#13;
                  },&#13;
                  "component": {},&#13;
                  "message": {}&#13;
                }&#13;
              }&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "SendDigits": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "contactId",&#13;
            "connectionId",&#13;
            "digits"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "contactId": {},&#13;
            "connectionId": {},&#13;
            "digits": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "SendSoftphoneCallMetrics": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "contactId",&#13;
            "softphoneStreamStatistics"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "contactId": {},&#13;
            "softphoneStreamStatistics": {&#13;
              "shape": "S2n"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "SendSoftphoneCallReport": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "contactId",&#13;
            "report"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "contactId": {},&#13;
            "report": {&#13;
              "type": "structure",&#13;
              "members": {&#13;
                "callStartTime": {&#13;
                  "type": "timestamp"&#13;
                },&#13;
                "callEndTime": {&#13;
                  "type": "timestamp"&#13;
                },&#13;
                "softphoneStreamStatistics": {&#13;
                  "shape": "S2n"&#13;
                },&#13;
                "gumTimeMillis": {&#13;
                  "type": "long"&#13;
                },&#13;
                "initializationTimeMillis": {&#13;
                  "type": "long"&#13;
                },&#13;
                "iceCollectionTimeMillis": {&#13;
                  "type": "long"&#13;
                },&#13;
                "signallingConnectTimeMillis": {&#13;
                  "type": "long"&#13;
                },&#13;
                "handshakeTimeMillis": {&#13;
                  "type": "long"&#13;
                },&#13;
                "preTalkTimeMillis": {&#13;
                  "type": "long"&#13;
                },&#13;
                "talkTimeMillis": {&#13;
                  "type": "long"&#13;
                },&#13;
                "cleanupTimeMillis": {&#13;
                  "type": "long"&#13;
                },&#13;
                "iceCollectionFailure": {&#13;
                  "type": "boolean"&#13;
                },&#13;
                "signallingConnectionFailure": {&#13;
                  "type": "boolean"&#13;
                },&#13;
                "handshakeFailure": {&#13;
                  "type": "boolean"&#13;
                },&#13;
                "gumOtherFailure": {&#13;
                  "type": "boolean"&#13;
                },&#13;
                "gumTimeoutFailure": {&#13;
                  "type": "boolean"&#13;
                },&#13;
                "createOfferFailure": {&#13;
                  "type": "boolean"&#13;
                },&#13;
                "setLocalDescriptionFailure": {&#13;
                  "type": "boolean"&#13;
                },&#13;
                "userBusyFailure": {&#13;
                  "type": "boolean"&#13;
                },&#13;
                "invalidRemoteSDPFailure": {&#13;
                  "type": "boolean"&#13;
                },&#13;
                "noRemoteIceCandidateFailure": {&#13;
                  "type": "boolean"&#13;
                },&#13;
                "setRemoteDescriptionFailure": {&#13;
                  "type": "boolean"&#13;
                }&#13;
              }&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "ToggleActiveConnections": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "contactId",&#13;
            "connectionId"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "contactId": {},&#13;
            "connectionId": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "UpdateAgentConfiguration": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "configuration"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "configuration": {&#13;
              "shape": "Sr"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      },&#13;
      "UpdateContactAttributes": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "authentication",&#13;
            "contactId",&#13;
            "attributes"&#13;
          ],&#13;
          "members": {&#13;
            "authentication": {&#13;
              "shape": "S2"&#13;
            },&#13;
            "contactId": {},&#13;
            "attributes": {&#13;
              "shape": "S1o"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        }&#13;
      }&#13;
    },&#13;
    "shapes": {&#13;
      "S2": {&#13;
        "type": "structure",&#13;
        "members": {&#13;
          "agentARN": {},&#13;
          "authToken": {}&#13;
        }&#13;
      },&#13;
      "Sa": {&#13;
        "type": "structure",&#13;
        "required": [&#13;
          "type"&#13;
        ],&#13;
        "members": {&#13;
          "endpointARN": {},&#13;
          "type": {},&#13;
          "name": {},&#13;
          "phoneNumber": {},&#13;
          "agentLogin": {},&#13;
          "queue": {&#13;
            "shape": "Sg"&#13;
          }&#13;
        }&#13;
      },&#13;
      "Sg": {&#13;
        "type": "structure",&#13;
        "members": {&#13;
          "queueARN": {},&#13;
          "name": {}&#13;
        }&#13;
      },&#13;
      "Sr": {&#13;
        "type": "structure",&#13;
        "required": [&#13;
          "name",&#13;
          "softphoneEnabled",&#13;
          "softphoneAutoAccept",&#13;
          "extension",&#13;
          "routingProfile"&#13;
        ],&#13;
        "members": {&#13;
          "name": {},&#13;
          "softphoneEnabled": {&#13;
            "type": "boolean"&#13;
          },&#13;
          "softphoneAutoAccept": {&#13;
            "type": "boolean"&#13;
          },&#13;
          "extension": {},&#13;
          "routingProfile": {&#13;
            "type": "structure",&#13;
            "members": {&#13;
              "name": {},&#13;
              "routingProfileARN": {},&#13;
              "defaultOutboundQueue": {&#13;
                "shape": "Sg"&#13;
              }&#13;
            }&#13;
          },&#13;
          "agentPreferences": {&#13;
            "type": "map",&#13;
            "key": {},&#13;
            "value": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "S17": {&#13;
        "type": "structure",&#13;
        "required": [&#13;
          "type",&#13;
          "name"&#13;
        ],&#13;
        "members": {&#13;
          "agentStateARN": {},&#13;
          "type": {},&#13;
          "name": {},&#13;
          "startTimestamp": {&#13;
            "type": "timestamp"&#13;
          }&#13;
        }&#13;
      },&#13;
      "S1o": {&#13;
        "type": "map",&#13;
        "key": {},&#13;
        "value": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "name"&#13;
          ],&#13;
          "members": {&#13;
            "name": {},&#13;
            "value": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "S2n": {&#13;
        "type": "list",&#13;
        "member": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "timestamp": {&#13;
              "type": "timestamp"&#13;
            },&#13;
            "softphoneStreamType": {},&#13;
            "packetCount": {&#13;
              "type": "long"&#13;
            },&#13;
            "packetsLost": {&#13;
              "type": "long"&#13;
            },&#13;
            "audioLevel": {&#13;
              "type": "double"&#13;
            },&#13;
            "jitterBufferMillis": {&#13;
              "type": "long"&#13;
            },&#13;
            "roundTripTimeMillis": {&#13;
              "type": "long"&#13;
            }&#13;
          }&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
  },{}],3:[function(require,module,exports){&#13;
  module.exports={&#13;
    "acm": {&#13;
      "name": "ACM",&#13;
      "cors": true&#13;
    },&#13;
    "apigateway": {&#13;
      "name": "APIGateway",&#13;
      "cors": true&#13;
    },&#13;
    "applicationautoscaling": {&#13;
      "prefix": "application-autoscaling",&#13;
      "name": "ApplicationAutoScaling",&#13;
      "cors": true&#13;
    },&#13;
    "autoscaling": {&#13;
      "name": "AutoScaling",&#13;
      "cors": true&#13;
    },&#13;
    "budgets": {&#13;
      "name": "Budgets"&#13;
    },&#13;
    "cloudformation": {&#13;
      "name": "CloudFormation",&#13;
      "cors": true&#13;
    },&#13;
    "cloudfront": {&#13;
      "name": "CloudFront",&#13;
      "versions": [&#13;
        "2013-05-12*",&#13;
        "2013-11-11*",&#13;
        "2014-05-31*",&#13;
        "2014-10-21*",&#13;
        "2014-11-06*",&#13;
        "2015-04-17*",&#13;
        "2015-07-27*",&#13;
        "2015-09-17*",&#13;
        "2016-01-13*",&#13;
        "2016-01-28*",&#13;
        "2016-08-01*",&#13;
        "2016-08-20*",&#13;
        "2016-09-07*"&#13;
      ],&#13;
      "cors": true&#13;
    },&#13;
    "cloudhsm": {&#13;
      "name": "CloudHSM",&#13;
      "cors": true&#13;
    },&#13;
    "cloudsearch": {&#13;
      "name": "CloudSearch"&#13;
    },&#13;
    "cloudsearchdomain": {&#13;
      "name": "CloudSearchDomain"&#13;
    },&#13;
    "cloudtrail": {&#13;
      "name": "CloudTrail",&#13;
      "cors": true&#13;
    },&#13;
    "cloudwatch": {&#13;
      "prefix": "monitoring",&#13;
      "name": "CloudWatch",&#13;
      "cors": true&#13;
    },&#13;
    "cloudwatchevents": {&#13;
      "prefix": "events",&#13;
      "name": "CloudWatchEvents",&#13;
      "versions": [&#13;
        "2014-02-03*"&#13;
      ],&#13;
      "cors": true&#13;
    },&#13;
    "cloudwatchlogs": {&#13;
      "prefix": "logs",&#13;
      "name": "CloudWatchLogs",&#13;
      "cors": true&#13;
    },&#13;
    "codecommit": {&#13;
      "name": "CodeCommit",&#13;
      "cors": true&#13;
    },&#13;
    "codedeploy": {&#13;
      "name": "CodeDeploy",&#13;
      "cors": true&#13;
    },&#13;
    "codepipeline": {&#13;
      "name": "CodePipeline",&#13;
      "cors": true&#13;
    },&#13;
    "cognitoidentity": {&#13;
      "prefix": "cognito-identity",&#13;
      "name": "CognitoIdentity",&#13;
      "cors": true&#13;
    },&#13;
    "cognitoidentityserviceprovider": {&#13;
      "prefix": "cognito-idp",&#13;
      "name": "CognitoIdentityServiceProvider",&#13;
      "cors": true&#13;
    },&#13;
    "cognitosync": {&#13;
      "prefix": "cognito-sync",&#13;
      "name": "CognitoSync",&#13;
      "cors": true&#13;
    },&#13;
    "configservice": {&#13;
      "prefix": "config",&#13;
      "name": "ConfigService",&#13;
      "cors": true&#13;
    },&#13;
    "connect": {&#13;
      "name":  "Connect",&#13;
      "cors":  true&#13;
    },&#13;
    "datapipeline": {&#13;
      "name": "DataPipeline"&#13;
    },&#13;
    "devicefarm": {&#13;
      "name": "DeviceFarm",&#13;
      "cors": true&#13;
    },&#13;
    "directconnect": {&#13;
      "name": "DirectConnect",&#13;
      "cors": true&#13;
    },&#13;
    "directoryservice": {&#13;
      "prefix": "ds",&#13;
      "name": "DirectoryService"&#13;
    },&#13;
    "discovery": {&#13;
      "name": "Discovery"&#13;
    },&#13;
    "dms": {&#13;
      "name": "DMS"&#13;
    },&#13;
    "dynamodb": {&#13;
      "name": "DynamoDB",&#13;
      "cors": true&#13;
    },&#13;
    "dynamodbstreams": {&#13;
      "prefix": "streams.dynamodb",&#13;
      "name": "DynamoDBStreams",&#13;
      "cors": true&#13;
    },&#13;
    "ec2": {&#13;
      "name": "EC2",&#13;
      "versions": [&#13;
        "2013-06-15*",&#13;
        "2013-10-15*",&#13;
        "2014-02-01*",&#13;
        "2014-05-01*",&#13;
        "2014-06-15*",&#13;
        "2014-09-01*",&#13;
        "2014-10-01*",&#13;
        "2015-03-01*",&#13;
        "2015-04-15*",&#13;
        "2015-10-01*",&#13;
        "2016-04-01*"&#13;
      ],&#13;
      "cors": true&#13;
    },&#13;
    "ecr": {&#13;
      "name": "ECR",&#13;
      "cors": true&#13;
    },&#13;
    "ecs": {&#13;
      "name": "ECS",&#13;
      "cors": true&#13;
    },&#13;
    "efs": {&#13;
      "prefix": "elasticfilesystem",&#13;
      "name": "EFS"&#13;
    },&#13;
    "elasticache": {&#13;
      "name": "ElastiCache",&#13;
      "versions": [&#13;
        "2012-11-15*",&#13;
        "2014-03-24*",&#13;
        "2014-07-15*",&#13;
        "2014-09-30*"&#13;
      ],&#13;
      "cors": true&#13;
    },&#13;
    "elasticbeanstalk": {&#13;
      "name": "ElasticBeanstalk",&#13;
      "cors": true&#13;
    },&#13;
    "elb": {&#13;
      "prefix": "elasticloadbalancing",&#13;
      "name": "ELB",&#13;
      "cors": true&#13;
    },&#13;
    "elbv2": {&#13;
      "prefix": "elasticloadbalancingv2",&#13;
      "name": "ELBv2",&#13;
      "cors": true&#13;
    },&#13;
    "emr": {&#13;
      "prefix": "elasticmapreduce",&#13;
      "name": "EMR",&#13;
      "cors": true&#13;
    },&#13;
    "es": {&#13;
      "name": "ES"&#13;
    },&#13;
    "elastictranscoder": {&#13;
      "name": "ElasticTranscoder",&#13;
      "cors": true&#13;
    },&#13;
    "firehose": {&#13;
      "name": "Firehose",&#13;
      "cors": true&#13;
    },&#13;
    "gamelift": {&#13;
      "name": "GameLift",&#13;
      "cors": true&#13;
    },&#13;
    "glacier": {&#13;
      "name": "Glacier"&#13;
    },&#13;
    "iam": {&#13;
      "name": "IAM"&#13;
    },&#13;
    "importexport": {&#13;
      "name": "ImportExport"&#13;
    },&#13;
    "inspector": {&#13;
      "name": "Inspector",&#13;
      "versions": [&#13;
        "2015-08-18*"&#13;
      ],&#13;
      "cors": true&#13;
    },&#13;
    "iot": {&#13;
      "name": "Iot",&#13;
      "cors": true&#13;
    },&#13;
    "iotdata": {&#13;
      "prefix": "iot-data",&#13;
      "name": "IotData",&#13;
      "cors": true&#13;
    },&#13;
    "kinesis": {&#13;
      "name": "Kinesis",&#13;
      "cors": true&#13;
    },&#13;
    "kinesisanalytics": {&#13;
      "name": "KinesisAnalytics"&#13;
    },&#13;
    "kms": {&#13;
      "name": "KMS",&#13;
      "cors": true&#13;
    },&#13;
    "lambda": {&#13;
      "name": "Lambda",&#13;
      "cors": true&#13;
    },&#13;
    "machinelearning": {&#13;
      "name": "MachineLearning",&#13;
      "cors": true&#13;
    },&#13;
    "marketplacecommerceanalytics": {&#13;
      "name": "MarketplaceCommerceAnalytics",&#13;
      "cors": true&#13;
    },&#13;
    "marketplacemetering": {&#13;
      "prefix": "meteringmarketplace",&#13;
      "name": "MarketplaceMetering"&#13;
    },&#13;
    "mobileanalytics": {&#13;
      "name": "MobileAnalytics",&#13;
      "cors": true&#13;
    },&#13;
    "opsworks": {&#13;
      "name": "OpsWorks",&#13;
      "cors": true&#13;
    },&#13;
    "rds": {&#13;
      "name": "RDS",&#13;
      "versions": [&#13;
        "2014-09-01*"&#13;
      ],&#13;
      "cors": true&#13;
    },&#13;
    "redshift": {&#13;
      "name": "Redshift",&#13;
      "cors": true&#13;
    },&#13;
    "route53": {&#13;
      "name": "Route53",&#13;
      "cors": true&#13;
    },&#13;
    "route53domains": {&#13;
      "name": "Route53Domains",&#13;
      "cors": true&#13;
    },&#13;
    "s3": {&#13;
      "name": "S3",&#13;
      "dualstackAvailable": true,&#13;
      "cors": true&#13;
    },&#13;
    "servicecatalog": {&#13;
      "name": "ServiceCatalog",&#13;
      "cors": true&#13;
    },&#13;
    "ses": {&#13;
      "prefix": "email",&#13;
      "name": "SES",&#13;
      "cors": true&#13;
    },&#13;
    "simpledb": {&#13;
      "prefix": "sdb",&#13;
      "name": "SimpleDB"&#13;
    },&#13;
    "sms": {&#13;
      "name": "SMS"&#13;
    },&#13;
    "snowball": {&#13;
      "name": "Snowball"&#13;
    },&#13;
    "sns": {&#13;
      "name": "SNS",&#13;
      "cors": true&#13;
    },&#13;
    "sqs": {&#13;
      "name": "SQS",&#13;
      "cors": true&#13;
    },&#13;
    "ssm": {&#13;
      "name": "SSM",&#13;
      "cors": true&#13;
    },&#13;
    "storagegateway": {&#13;
      "name": "StorageGateway",&#13;
      "cors": true&#13;
    },&#13;
    "sts": {&#13;
      "name": "STS",&#13;
      "cors": true&#13;
    },&#13;
    "support": {&#13;
      "name": "Support"&#13;
    },&#13;
    "swf": {&#13;
      "name": "SWF"&#13;
    },&#13;
    "waf": {&#13;
      "name": "WAF",&#13;
      "cors": true&#13;
    },&#13;
    "workspaces": {&#13;
      "name": "WorkSpaces"&#13;
    }&#13;
  }&#13;
  &#13;
  },{}],4:[function(require,module,exports){&#13;
  module.exports={&#13;
    "version": "2.0",&#13;
    "metadata": {&#13;
      "apiVersion": "2011-06-15",&#13;
      "endpointPrefix": "sts",&#13;
      "globalEndpoint": "sts.amazonaws.com",&#13;
      "protocol": "query",&#13;
      "serviceAbbreviation": "AWS STS",&#13;
      "serviceFullName": "AWS Security Token Service",&#13;
      "signatureVersion": "v4",&#13;
      "xmlNamespace": "https://sts.amazonaws.com/doc/2011-06-15/"&#13;
    },&#13;
    "operations": {&#13;
      "AssumeRole": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "RoleArn",&#13;
            "RoleSessionName"&#13;
          ],&#13;
          "members": {&#13;
            "RoleArn": {},&#13;
            "RoleSessionName": {},&#13;
            "Policy": {},&#13;
            "DurationSeconds": {&#13;
              "type": "integer"&#13;
            },&#13;
            "ExternalId": {},&#13;
            "SerialNumber": {},&#13;
            "TokenCode": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "resultWrapper": "AssumeRoleResult",&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "Credentials": {&#13;
              "shape": "Sa"&#13;
            },&#13;
            "AssumedRoleUser": {&#13;
              "shape": "Sf"&#13;
            },&#13;
            "PackedPolicySize": {&#13;
              "type": "integer"&#13;
            }&#13;
          }&#13;
        }&#13;
      },&#13;
      "AssumeRoleWithSAML": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "RoleArn",&#13;
            "PrincipalArn",&#13;
            "SAMLAssertion"&#13;
          ],&#13;
          "members": {&#13;
            "RoleArn": {},&#13;
            "PrincipalArn": {},&#13;
            "SAMLAssertion": {},&#13;
            "Policy": {},&#13;
            "DurationSeconds": {&#13;
              "type": "integer"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "resultWrapper": "AssumeRoleWithSAMLResult",&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "Credentials": {&#13;
              "shape": "Sa"&#13;
            },&#13;
            "AssumedRoleUser": {&#13;
              "shape": "Sf"&#13;
            },&#13;
            "PackedPolicySize": {&#13;
              "type": "integer"&#13;
            },&#13;
            "Subject": {},&#13;
            "SubjectType": {},&#13;
            "Issuer": {},&#13;
            "Audience": {},&#13;
            "NameQualifier": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "AssumeRoleWithWebIdentity": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "RoleArn",&#13;
            "RoleSessionName",&#13;
            "WebIdentityToken"&#13;
          ],&#13;
          "members": {&#13;
            "RoleArn": {},&#13;
            "RoleSessionName": {},&#13;
            "WebIdentityToken": {},&#13;
            "ProviderId": {},&#13;
            "Policy": {},&#13;
            "DurationSeconds": {&#13;
              "type": "integer"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "resultWrapper": "AssumeRoleWithWebIdentityResult",&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "Credentials": {&#13;
              "shape": "Sa"&#13;
            },&#13;
            "SubjectFromWebIdentityToken": {},&#13;
            "AssumedRoleUser": {&#13;
              "shape": "Sf"&#13;
            },&#13;
            "PackedPolicySize": {&#13;
              "type": "integer"&#13;
            },&#13;
            "Provider": {},&#13;
            "Audience": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "DecodeAuthorizationMessage": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "EncodedMessage"&#13;
          ],&#13;
          "members": {&#13;
            "EncodedMessage": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "resultWrapper": "DecodeAuthorizationMessageResult",&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "DecodedMessage": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetCallerIdentity": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "members": {}&#13;
        },&#13;
        "output": {&#13;
          "resultWrapper": "GetCallerIdentityResult",&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "UserId": {},&#13;
            "Account": {},&#13;
            "Arn": {}&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetFederationToken": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "required": [&#13;
            "Name"&#13;
          ],&#13;
          "members": {&#13;
            "Name": {},&#13;
            "Policy": {},&#13;
            "DurationSeconds": {&#13;
              "type": "integer"&#13;
            }&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "resultWrapper": "GetFederationTokenResult",&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "Credentials": {&#13;
              "shape": "Sa"&#13;
            },&#13;
            "FederatedUser": {&#13;
              "type": "structure",&#13;
              "required": [&#13;
                "FederatedUserId",&#13;
                "Arn"&#13;
              ],&#13;
              "members": {&#13;
                "FederatedUserId": {},&#13;
                "Arn": {}&#13;
              }&#13;
            },&#13;
            "PackedPolicySize": {&#13;
              "type": "integer"&#13;
            }&#13;
          }&#13;
        }&#13;
      },&#13;
      "GetSessionToken": {&#13;
        "input": {&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "DurationSeconds": {&#13;
              "type": "integer"&#13;
            },&#13;
            "SerialNumber": {},&#13;
            "TokenCode": {}&#13;
          }&#13;
        },&#13;
        "output": {&#13;
          "resultWrapper": "GetSessionTokenResult",&#13;
          "type": "structure",&#13;
          "members": {&#13;
            "Credentials": {&#13;
              "shape": "Sa"&#13;
            }&#13;
          }&#13;
        }&#13;
      }&#13;
    },&#13;
    "shapes": {&#13;
      "Sa": {&#13;
        "type": "structure",&#13;
        "required": [&#13;
          "AccessKeyId",&#13;
          "SecretAccessKey",&#13;
          "SessionToken",&#13;
          "Expiration"&#13;
        ],&#13;
        "members": {&#13;
          "AccessKeyId": {},&#13;
          "SecretAccessKey": {},&#13;
          "SessionToken": {},&#13;
          "Expiration": {&#13;
            "type": "timestamp"&#13;
          }&#13;
        }&#13;
      },&#13;
      "Sf": {&#13;
        "type": "structure",&#13;
        "required": [&#13;
          "AssumedRoleId",&#13;
          "Arn"&#13;
        ],&#13;
        "members": {&#13;
          "AssumedRoleId": {},&#13;
          "Arn": {}&#13;
        }&#13;
      }&#13;
    }&#13;
  }&#13;
  },{}],5:[function(require,module,exports){&#13;
  require('../lib/node_loader');&#13;
  var AWS = require('../lib/core');&#13;
  var Service = require('../lib/service');&#13;
  var apiLoader = require('../lib/api_loader');&#13;
  &#13;
  apiLoader.services['cognitoidentity'] = {};&#13;
  AWS.CognitoIdentity = Service.defineService('cognitoidentity', ['2014-06-30']);&#13;
  require('../lib/services/cognitoidentity');&#13;
  Object.defineProperty(apiLoader.services['cognitoidentity'], '2014-06-30', {&#13;
    get: function get() {&#13;
      var model = require('../apis/cognito-identity-2014-06-30.min.json');&#13;
      return model;&#13;
    },&#13;
    enumerable: true,&#13;
    configurable: true&#13;
  });&#13;
  &#13;
  module.exports = AWS.CognitoIdentity;&#13;
  &#13;
  },{"../apis/cognito-identity-2014-06-30.min.json":1,"../lib/api_loader":7,"../lib/core":10,"../lib/node_loader":8,"../lib/service":41,"../lib/services/cognitoidentity":42}],6:[function(require,module,exports){&#13;
  require('../lib/node_loader');&#13;
  var AWS = require('../lib/core');&#13;
  var Service = require('../lib/service');&#13;
  var apiLoader = require('../lib/api_loader');&#13;
  &#13;
  apiLoader.services['sts'] = {};&#13;
  AWS.STS = Service.defineService('sts', ['2011-06-15']);&#13;
  require('../lib/services/sts');&#13;
  Object.defineProperty(apiLoader.services['sts'], '2011-06-15', {&#13;
    get: function get() {&#13;
      var model = require('../apis/sts-2011-06-15.min.json');&#13;
      return model;&#13;
    },&#13;
    enumerable: true,&#13;
    configurable: true&#13;
  });&#13;
  &#13;
  module.exports = AWS.STS;&#13;
  &#13;
  },{"../apis/sts-2011-06-15.min.json":4,"../lib/api_loader":7,"../lib/core":10,"../lib/node_loader":8,"../lib/service":41,"../lib/services/sts":43}],7:[function(require,module,exports){&#13;
  var AWS = require('./core');&#13;
  &#13;
  AWS.apiLoader = function(svc, version) {&#13;
    if (!AWS.apiLoader.services.hasOwnProperty(svc)) {&#13;
      throw new Error('InvalidService: Failed to load api for ' + svc);&#13;
    }&#13;
    return AWS.apiLoader.services[svc][version];&#13;
  };&#13;
  &#13;
  AWS.apiLoader.services = {};&#13;
  &#13;
  module.exports = AWS.apiLoader;&#13;
  },{"./core":10}],8:[function(require,module,exports){&#13;
  (function (process){&#13;
  var util = require('./util');&#13;
  &#13;
  util.crypto.lib = require('crypto-browserify');&#13;
  util.Buffer = require('buffer/').Buffer;&#13;
  util.url = require('url/');&#13;
  util.querystring = require('querystring/');&#13;
  &#13;
  var AWS = require('./core');&#13;
  &#13;
  require('./api_loader');&#13;
  &#13;
  AWS.XML.Parser = require('./xml/browser_parser');&#13;
  &#13;
  require('./http/xhr');&#13;
  &#13;
  if (typeof process === 'undefined') {&#13;
    process = {&#13;
      browser: true&#13;
    };&#13;
  }&#13;
  }).call(this,require('_process'))&#13;
  },{"./api_loader":7,"./core":10,"./http/xhr":19,"./util":52,"./xml/browser_parser":53,"_process":117,"buffer/":58,"crypto-browserify":60,"querystring/":124,"url/":125}],9:[function(require,module,exports){&#13;
  var AWS = require('./core');&#13;
  require('./credentials');&#13;
  require('./credentials/credential_provider_chain');&#13;
  var PromisesDependency;&#13;
  &#13;
  &#13;
  AWS.Config = AWS.util.inherit({&#13;
  &#13;
  &#13;
  &#13;
    constructor: function Config(options) {&#13;
      if (options === undefined) options = {};&#13;
      options = this.extractCredentials(options);&#13;
  &#13;
      AWS.util.each.call(this, this.keys, function (key, value) {&#13;
        this.set(key, options[key], value);&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
  &#13;
  &#13;
    getCredentials: function getCredentials(callback) {&#13;
      var self = this;&#13;
  &#13;
      function finish(err) {&#13;
        callback(err, err ? null : self.credentials);&#13;
      }&#13;
  &#13;
      function credError(msg, err) {&#13;
        return new AWS.util.error(err || new Error(), {&#13;
          code: 'CredentialsError', message: msg&#13;
        });&#13;
      }&#13;
  &#13;
      function getAsyncCredentials() {&#13;
        self.credentials.get(function(err) {&#13;
          if (err) {&#13;
            var msg = 'Could not load credentials from ' +&#13;
              self.credentials.constructor.name;&#13;
            err = credError(msg, err);&#13;
          }&#13;
          finish(err);&#13;
        });&#13;
      }&#13;
  &#13;
      function getStaticCredentials() {&#13;
        var err = null;&#13;
        if (!self.credentials.accessKeyId || !self.credentials.secretAccessKey) {&#13;
          err = credError('Missing credentials');&#13;
        }&#13;
        finish(err);&#13;
      }&#13;
  &#13;
      if (self.credentials) {&#13;
        if (typeof self.credentials.get === 'function') {&#13;
          getAsyncCredentials();&#13;
        } else { // static credentials&#13;
          getStaticCredentials();&#13;
        }&#13;
      } else if (self.credentialProvider) {&#13;
        self.credentialProvider.resolve(function(err, creds) {&#13;
          if (err) {&#13;
            err = credError('Could not load credentials from any providers', err);&#13;
          }&#13;
          self.credentials = creds;&#13;
          finish(err);&#13;
        });&#13;
      } else {&#13;
        finish(credError('No credentials to load'));&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
  &#13;
  &#13;
    update: function update(options, allowUnknownKeys) {&#13;
      allowUnknownKeys = allowUnknownKeys || false;&#13;
      options = this.extractCredentials(options);&#13;
      AWS.util.each.call(this, options, function (key, value) {&#13;
        if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) ||&#13;
            AWS.Service.hasService(key)) {&#13;
          this.set(key, value);&#13;
        }&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
    loadFromPath: function loadFromPath(path) {&#13;
      this.clear();&#13;
  &#13;
      var options = JSON.parse(AWS.util.readFileSync(path));&#13;
      var fileSystemCreds = new AWS.FileSystemCredentials(path);&#13;
      var chain = new AWS.CredentialProviderChain();&#13;
      chain.providers.unshift(fileSystemCreds);&#13;
      chain.resolve(function (err, creds) {&#13;
        if (err) throw err;&#13;
        else options.credentials = creds;&#13;
      });&#13;
  &#13;
      this.constructor(options);&#13;
  &#13;
      return this;&#13;
    },&#13;
  &#13;
  &#13;
    clear: function clear() {&#13;
  &#13;
      AWS.util.each.call(this, this.keys, function (key) {&#13;
        delete this[key];&#13;
      });&#13;
  &#13;
      this.set('credentials', undefined);&#13;
      this.set('credentialProvider', undefined);&#13;
    },&#13;
  &#13;
  &#13;
    set: function set(property, value, defaultValue) {&#13;
      if (value === undefined) {&#13;
        if (defaultValue === undefined) {&#13;
          defaultValue = this.keys[property];&#13;
        }&#13;
        if (typeof defaultValue === 'function') {&#13;
          this[property] = defaultValue.call(this);&#13;
        } else {&#13;
          this[property] = defaultValue;&#13;
        }&#13;
      } else if (property === 'httpOptions' &amp;&amp; this[property]) {&#13;
        this[property] = AWS.util.merge(this[property], value);&#13;
      } else {&#13;
        this[property] = value;&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    keys: {&#13;
      credentials: null,&#13;
      credentialProvider: null,&#13;
      region: null,&#13;
      logger: null,&#13;
      apiVersions: {},&#13;
      apiVersion: null,&#13;
      endpoint: undefined,&#13;
      httpOptions: {&#13;
        timeout: 120000&#13;
      },&#13;
      maxRetries: undefined,&#13;
      maxRedirects: 10,&#13;
      paramValidation: true,&#13;
      sslEnabled: true,&#13;
      s3ForcePathStyle: false,&#13;
      s3BucketEndpoint: false,&#13;
      s3DisableBodySigning: true,&#13;
      computeChecksums: true,&#13;
      convertResponseTypes: true,&#13;
      correctClockSkew: false,&#13;
      customUserAgent: null,&#13;
      dynamoDbCrc32: true,&#13;
      systemClockOffset: 0,&#13;
      signatureVersion: null,&#13;
      signatureCache: true,&#13;
      retryDelayOptions: {&#13;
        base: 100&#13;
      },&#13;
      useAccelerateEndpoint: false&#13;
    },&#13;
  &#13;
  &#13;
    extractCredentials: function extractCredentials(options) {&#13;
      if (options.accessKeyId &amp;&amp; options.secretAccessKey) {&#13;
        options = AWS.util.copy(options);&#13;
        options.credentials = new AWS.Credentials(options);&#13;
      }&#13;
      return options;&#13;
    },&#13;
  &#13;
  &#13;
    setPromisesDependency: function setPromisesDependency(dep) {&#13;
      PromisesDependency = dep;&#13;
      var constructors = [AWS.Request, AWS.Credentials, AWS.CredentialProviderChain];&#13;
      if (AWS.S3 &amp;&amp; AWS.S3.ManagedUpload) constructors.push(AWS.S3.ManagedUpload);&#13;
      AWS.util.addPromises(constructors, dep);&#13;
    },&#13;
  &#13;
  &#13;
    getPromisesDependency: function getPromisesDependency() {&#13;
      return PromisesDependency;&#13;
    }&#13;
  });&#13;
  &#13;
  &#13;
  AWS.config = new AWS.Config();&#13;
  &#13;
  },{"./core":10,"./credentials":11,"./credentials/credential_provider_chain":13}],10:[function(require,module,exports){&#13;
  &#13;
  var AWS = { util: require('./util') };&#13;
  &#13;
  &#13;
  var _hidden = {}; _hidden.toString(); // hack to parse macro&#13;
  &#13;
  module.exports = AWS;&#13;
  &#13;
  AWS.util.update(AWS, {&#13;
  &#13;
  &#13;
    VERSION: '2.7.0',&#13;
  &#13;
  &#13;
    Signers: {},&#13;
  &#13;
  &#13;
    Protocol: {&#13;
      Json: require('./protocol/json'),&#13;
      Query: require('./protocol/query'),&#13;
      Rest: require('./protocol/rest'),&#13;
      RestJson: require('./protocol/rest_json'),&#13;
      RestXml: require('./protocol/rest_xml')&#13;
    },&#13;
  &#13;
  &#13;
    XML: {&#13;
      Builder: require('./xml/builder'),&#13;
      Parser: null // conditionally set based on environment&#13;
    },&#13;
  &#13;
  &#13;
    JSON: {&#13;
      Builder: require('./json/builder'),&#13;
      Parser: require('./json/parser')&#13;
    },&#13;
  &#13;
  &#13;
    Model: {&#13;
      Api: require('./model/api'),&#13;
      Operation: require('./model/operation'),&#13;
      Shape: require('./model/shape'),&#13;
      Paginator: require('./model/paginator'),&#13;
      ResourceWaiter: require('./model/resource_waiter')&#13;
    },&#13;
  &#13;
    util: require('./util'),&#13;
  &#13;
  &#13;
    apiLoader: function() { throw new Error('No API loader set'); }&#13;
  });&#13;
  &#13;
  require('./service');&#13;
  &#13;
  require('./credentials');&#13;
  require('./credentials/credential_provider_chain');&#13;
  require('./credentials/temporary_credentials');&#13;
  require('./credentials/web_identity_credentials');&#13;
  require('./credentials/cognito_identity_credentials');&#13;
  require('./credentials/saml_credentials');&#13;
  &#13;
  require('./config');&#13;
  require('./http');&#13;
  require('./sequential_executor');&#13;
  require('./event_listeners');&#13;
  require('./request');&#13;
  require('./response');&#13;
  require('./resource_waiter');&#13;
  require('./signers/request_signer');&#13;
  require('./param_validator');&#13;
  &#13;
  &#13;
  AWS.events = new AWS.SequentialExecutor();&#13;
  &#13;
  },{"./config":9,"./credentials":11,"./credentials/cognito_identity_credentials":12,"./credentials/credential_provider_chain":13,"./credentials/saml_credentials":14,"./credentials/temporary_credentials":15,"./credentials/web_identity_credentials":16,"./event_listeners":17,"./http":18,"./json/builder":20,"./json/parser":21,"./model/api":22,"./model/operation":24,"./model/paginator":25,"./model/resource_waiter":26,"./model/shape":27,"./param_validator":28,"./protocol/json":29,"./protocol/query":30,"./protocol/rest":31,"./protocol/rest_json":32,"./protocol/rest_xml":33,"./request":37,"./resource_waiter":38,"./response":39,"./sequential_executor":40,"./service":41,"./signers/request_signer":45,"./util":52,"./xml/builder":54}],11:[function(require,module,exports){&#13;
  var AWS = require('./core');&#13;
  &#13;
  &#13;
  AWS.Credentials = AWS.util.inherit({&#13;
  &#13;
    constructor: function Credentials() {&#13;
      AWS.util.hideProperties(this, ['secretAccessKey']);&#13;
  &#13;
      this.expired = false;&#13;
      this.expireTime = null;&#13;
      if (arguments.length === 1 &amp;&amp; typeof arguments[0] === 'object') {&#13;
        var creds = arguments[0].credentials || arguments[0];&#13;
        this.accessKeyId = creds.accessKeyId;&#13;
        this.secretAccessKey = creds.secretAccessKey;&#13;
        this.sessionToken = creds.sessionToken;&#13;
      } else {&#13;
        this.accessKeyId = arguments[0];&#13;
        this.secretAccessKey = arguments[1];&#13;
        this.sessionToken = arguments[2];&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    expiryWindow: 15,&#13;
  &#13;
  &#13;
    needsRefresh: function needsRefresh() {&#13;
      var currentTime = AWS.util.date.getDate().getTime();&#13;
      var adjustedTime = new Date(currentTime + this.expiryWindow * 1000);&#13;
  &#13;
      if (this.expireTime &amp;&amp; adjustedTime &gt; this.expireTime) {&#13;
        return true;&#13;
      } else {&#13;
        return this.expired || !this.accessKeyId || !this.secretAccessKey;&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    get: function get(callback) {&#13;
      var self = this;&#13;
      if (this.needsRefresh()) {&#13;
        this.refresh(function(err) {&#13;
          if (!err) self.expired = false; // reset expired flag&#13;
          if (callback) callback(err);&#13;
        });&#13;
      } else if (callback) {&#13;
        callback();&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
  &#13;
  &#13;
  &#13;
  &#13;
    refresh: function refresh(callback) {&#13;
      this.expired = false;&#13;
      callback();&#13;
    }&#13;
  });&#13;
  &#13;
  &#13;
  AWS.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {&#13;
    this.prototype.getPromise = AWS.util.promisifyMethod('get', PromiseDependency);&#13;
    this.prototype.refreshPromise = AWS.util.promisifyMethod('refresh', PromiseDependency);&#13;
  };&#13;
  &#13;
  &#13;
  AWS.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {&#13;
    delete this.prototype.getPromise;&#13;
    delete this.prototype.refreshPromise;&#13;
  };&#13;
  &#13;
  AWS.util.addPromises(AWS.Credentials);&#13;
  &#13;
  },{"./core":10}],12:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var CognitoIdentity = require('../../clients/cognitoidentity');&#13;
  var STS = require('../../clients/sts');&#13;
  &#13;
  &#13;
  AWS.CognitoIdentityCredentials = AWS.util.inherit(AWS.Credentials, {&#13;
  &#13;
    localStorageKey: {&#13;
      id: 'aws.cognito.identity-id.',&#13;
      providers: 'aws.cognito.identity-providers.'&#13;
    },&#13;
  &#13;
  &#13;
    constructor: function CognitoIdentityCredentials(params) {&#13;
      AWS.Credentials.call(this);&#13;
      this.expired = true;&#13;
      this.params = params;&#13;
      this.data = null;&#13;
      this.identityId = null;&#13;
      this.loadCachedId();&#13;
    },&#13;
  &#13;
  &#13;
    refresh: function refresh(callback) {&#13;
      var self = this;&#13;
      self.createClients();&#13;
      self.data = null;&#13;
      self.identityId = null;&#13;
      self.getId(function(err) {&#13;
        if (!err) {&#13;
          if (!self.params.RoleArn) {&#13;
            self.getCredentialsForIdentity(callback);&#13;
          } else {&#13;
            self.getCredentialsFromSTS(callback);&#13;
          }&#13;
        } else {&#13;
          self.clearIdOnNotAuthorized(err);&#13;
          callback(err);&#13;
        }&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
    clearCachedId: function clearCache() {&#13;
      this.identityId = null;&#13;
      delete this.params.IdentityId;&#13;
  &#13;
      var poolId = this.params.IdentityPoolId;&#13;
      var loginId = this.params.LoginId || '';&#13;
      delete this.storage[this.localStorageKey.id + poolId + loginId];&#13;
      delete this.storage[this.localStorageKey.providers + poolId + loginId];&#13;
    },&#13;
  &#13;
  &#13;
    clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {&#13;
      var self = this;&#13;
      if (err.code == 'NotAuthorizedException') {&#13;
        self.clearCachedId();&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    getId: function getId(callback) {&#13;
      var self = this;&#13;
      if (typeof self.params.IdentityId === 'string') {&#13;
        return callback(null, self.params.IdentityId);&#13;
      }&#13;
  &#13;
      self.cognito.getId(function(err, data) {&#13;
        if (!err &amp;&amp; data.IdentityId) {&#13;
          self.params.IdentityId = data.IdentityId;&#13;
          callback(null, data.IdentityId);&#13;
        } else {&#13;
          callback(err);&#13;
        }&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
  &#13;
    loadCredentials: function loadCredentials(data, credentials) {&#13;
      if (!data || !credentials) return;&#13;
      credentials.expired = false;&#13;
      credentials.accessKeyId = data.Credentials.AccessKeyId;&#13;
      credentials.secretAccessKey = data.Credentials.SecretKey;&#13;
      credentials.sessionToken = data.Credentials.SessionToken;&#13;
      credentials.expireTime = data.Credentials.Expiration;&#13;
    },&#13;
  &#13;
  &#13;
    getCredentialsForIdentity: function getCredentialsForIdentity(callback) {&#13;
      var self = this;&#13;
      self.cognito.getCredentialsForIdentity(function(err, data) {&#13;
        if (!err) {&#13;
          self.cacheId(data);&#13;
          self.data = data;&#13;
          self.loadCredentials(self.data, self);&#13;
        } else {&#13;
          self.clearIdOnNotAuthorized(err);&#13;
        }&#13;
        callback(err);&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
    getCredentialsFromSTS: function getCredentialsFromSTS(callback) {&#13;
      var self = this;&#13;
      self.cognito.getOpenIdToken(function(err, data) {&#13;
        if (!err) {&#13;
          self.cacheId(data);&#13;
          self.params.WebIdentityToken = data.Token;&#13;
          self.webIdentityCredentials.refresh(function(webErr) {&#13;
            if (!webErr) {&#13;
              self.data = self.webIdentityCredentials.data;&#13;
              self.sts.credentialsFrom(self.data, self);&#13;
            }&#13;
            callback(webErr);&#13;
          });&#13;
        } else {&#13;
          self.clearIdOnNotAuthorized(err);&#13;
          callback(err);&#13;
        }&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
    loadCachedId: function loadCachedId() {&#13;
      var self = this;&#13;
  &#13;
      if (AWS.util.isBrowser() &amp;&amp; !self.params.IdentityId) {&#13;
        var id = self.getStorage('id');&#13;
        if (id &amp;&amp; self.params.Logins) {&#13;
          var actualProviders = Object.keys(self.params.Logins);&#13;
          var cachedProviders =&#13;
            (self.getStorage('providers') || '').split(',');&#13;
  &#13;
          var intersect = cachedProviders.filter(function(n) {&#13;
            return actualProviders.indexOf(n) !== -1;&#13;
          });&#13;
          if (intersect.length !== 0) {&#13;
            self.params.IdentityId = id;&#13;
          }&#13;
        } else if (id) {&#13;
          self.params.IdentityId = id;&#13;
        }&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    createClients: function() {&#13;
      this.webIdentityCredentials = this.webIdentityCredentials ||&#13;
        new AWS.WebIdentityCredentials(this.params);&#13;
      this.cognito = this.cognito ||&#13;
        new CognitoIdentity({params: this.params});&#13;
      this.sts = this.sts || new STS();&#13;
    },&#13;
  &#13;
  &#13;
    cacheId: function cacheId(data) {&#13;
      this.identityId = data.IdentityId;&#13;
      this.params.IdentityId = this.identityId;&#13;
  &#13;
      if (AWS.util.isBrowser()) {&#13;
        this.setStorage('id', data.IdentityId);&#13;
  &#13;
        if (this.params.Logins) {&#13;
          this.setStorage('providers', Object.keys(this.params.Logins).join(','));&#13;
        }&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    getStorage: function getStorage(key) {&#13;
      return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')];&#13;
    },&#13;
  &#13;
  &#13;
    setStorage: function setStorage(key, val) {&#13;
      try {&#13;
        this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || '')] = val;&#13;
      } catch (_) {}&#13;
    },&#13;
  &#13;
  &#13;
    storage: (function() {&#13;
      try {&#13;
        return AWS.util.isBrowser() &amp;&amp; window.localStorage !== null &amp;&amp; typeof window.localStorage === 'object' ?&#13;
               window.localStorage : {};&#13;
      } catch (_) {&#13;
        return {};&#13;
      }&#13;
    })()&#13;
  });&#13;
  &#13;
  },{"../../clients/cognitoidentity":5,"../../clients/sts":6,"../core":10}],13:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  &#13;
  &#13;
  AWS.CredentialProviderChain = AWS.util.inherit(AWS.Credentials, {&#13;
  &#13;
  &#13;
    constructor: function CredentialProviderChain(providers) {&#13;
      if (providers) {&#13;
        this.providers = providers;&#13;
      } else {&#13;
        this.providers = AWS.CredentialProviderChain.defaultProviders.slice(0);&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
  &#13;
  &#13;
    resolve: function resolve(callback) {&#13;
      if (this.providers.length === 0) {&#13;
        callback(new Error('No providers'));&#13;
        return this;&#13;
      }&#13;
  &#13;
      var index = 0;&#13;
      var providers = this.providers.slice(0);&#13;
  &#13;
      function resolveNext(err, creds) {&#13;
        if ((!err &amp;&amp; creds) || index === providers.length) {&#13;
          callback(err, creds);&#13;
          return;&#13;
        }&#13;
  &#13;
        var provider = providers[index++];&#13;
        if (typeof provider === 'function') {&#13;
          creds = provider.call();&#13;
        } else {&#13;
          creds = provider;&#13;
        }&#13;
  &#13;
        if (creds.get) {&#13;
          creds.get(function(getErr) {&#13;
            resolveNext(getErr, getErr ? null : creds);&#13;
          });&#13;
        } else {&#13;
          resolveNext(null, creds);&#13;
        }&#13;
      }&#13;
  &#13;
      resolveNext();&#13;
      return this;&#13;
    }&#13;
  });&#13;
  &#13;
  &#13;
  AWS.CredentialProviderChain.defaultProviders = [];&#13;
  &#13;
  &#13;
  AWS.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {&#13;
    this.prototype.resolvePromise = AWS.util.promisifyMethod('resolve', PromiseDependency);&#13;
  };&#13;
  &#13;
  &#13;
  AWS.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {&#13;
    delete this.prototype.resolvePromise;&#13;
  };&#13;
  &#13;
  AWS.util.addPromises(AWS.CredentialProviderChain);&#13;
  &#13;
  },{"../core":10}],14:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var STS = require('../../clients/sts');&#13;
  &#13;
  &#13;
  AWS.SAMLCredentials = AWS.util.inherit(AWS.Credentials, {&#13;
  &#13;
    constructor: function SAMLCredentials(params) {&#13;
      AWS.Credentials.call(this);&#13;
      this.expired = true;&#13;
      this.params = params;&#13;
    },&#13;
  &#13;
  &#13;
    refresh: function refresh(callback) {&#13;
      var self = this;&#13;
      self.createClients();&#13;
      if (!callback) callback = function(err) { if (err) throw err; };&#13;
  &#13;
      self.service.assumeRoleWithSAML(function (err, data) {&#13;
        if (!err) {&#13;
          self.service.credentialsFrom(data, self);&#13;
        }&#13;
        callback(err);&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
    createClients: function() {&#13;
      this.service = this.service || new STS({params: this.params});&#13;
    }&#13;
  &#13;
  });&#13;
  &#13;
  },{"../../clients/sts":6,"../core":10}],15:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var STS = require('../../clients/sts');&#13;
  &#13;
  &#13;
  AWS.TemporaryCredentials = AWS.util.inherit(AWS.Credentials, {&#13;
  &#13;
    constructor: function TemporaryCredentials(params) {&#13;
      AWS.Credentials.call(this);&#13;
      this.loadMasterCredentials();&#13;
      this.expired = true;&#13;
  &#13;
      this.params = params || {};&#13;
      if (this.params.RoleArn) {&#13;
        this.params.RoleSessionName =&#13;
          this.params.RoleSessionName || 'temporary-credentials';&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    refresh: function refresh(callback) {&#13;
      var self = this;&#13;
      self.createClients();&#13;
      if (!callback) callback = function(err) { if (err) throw err; };&#13;
  &#13;
      self.service.config.credentials = self.masterCredentials;&#13;
      var operation = self.params.RoleArn ?&#13;
        self.service.assumeRole : self.service.getSessionToken;&#13;
      operation.call(self.service, function (err, data) {&#13;
        if (!err) {&#13;
          self.service.credentialsFrom(data, self);&#13;
        }&#13;
        callback(err);&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
    loadMasterCredentials: function loadMasterCredentials() {&#13;
      this.masterCredentials = AWS.config.credentials;&#13;
      while (this.masterCredentials.masterCredentials) {&#13;
        this.masterCredentials = this.masterCredentials.masterCredentials;&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    createClients: function() {&#13;
      this.service = this.service || new STS({params: this.params});&#13;
    }&#13;
  &#13;
  });&#13;
  &#13;
  },{"../../clients/sts":6,"../core":10}],16:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var STS = require('../../clients/sts');&#13;
  &#13;
  &#13;
  AWS.WebIdentityCredentials = AWS.util.inherit(AWS.Credentials, {&#13;
  &#13;
    constructor: function WebIdentityCredentials(params) {&#13;
      AWS.Credentials.call(this);&#13;
      this.expired = true;&#13;
      this.params = params;&#13;
      this.params.RoleSessionName = this.params.RoleSessionName || 'web-identity';&#13;
      this.data = null;&#13;
    },&#13;
  &#13;
  &#13;
    refresh: function refresh(callback) {&#13;
      var self = this;&#13;
      self.createClients();&#13;
      if (!callback) callback = function(err) { if (err) throw err; };&#13;
  &#13;
      self.service.assumeRoleWithWebIdentity(function (err, data) {&#13;
        self.data = null;&#13;
        if (!err) {&#13;
          self.data = data;&#13;
          self.service.credentialsFrom(data, self);&#13;
        }&#13;
        callback(err);&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
    createClients: function() {&#13;
      this.service = this.service || new STS({params: this.params});&#13;
    }&#13;
  &#13;
  });&#13;
  &#13;
  },{"../../clients/sts":6,"../core":10}],17:[function(require,module,exports){&#13;
  var AWS = require('./core');&#13;
  var SequentialExecutor = require('./sequential_executor');&#13;
  &#13;
  &#13;
  AWS.EventListeners = {&#13;
  &#13;
    Core: {} /* doc hack */&#13;
  };&#13;
  &#13;
  AWS.EventListeners = {&#13;
    Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {&#13;
      addAsync('VALIDATE_CREDENTIALS', 'validate',&#13;
          function VALIDATE_CREDENTIALS(req, done) {&#13;
        if (!req.service.api.signatureVersion) return done(); // none&#13;
        req.service.config.getCredentials(function(err) {&#13;
          if (err) {&#13;
            req.response.error = AWS.util.error(err,&#13;
              {code: 'CredentialsError', message: 'Missing credentials in config'});&#13;
          }&#13;
          done();&#13;
        });&#13;
      });&#13;
  &#13;
      add('VALIDATE_REGION', 'validate', function VALIDATE_REGION(req) {&#13;
        if (!req.service.config.region &amp;&amp; !req.service.isGlobalEndpoint) {&#13;
          req.response.error = AWS.util.error(new Error(),&#13;
            {code: 'ConfigError', message: 'Missing region in config'});&#13;
        }&#13;
      });&#13;
  &#13;
      add('VALIDATE_PARAMETERS', 'validate', function VALIDATE_PARAMETERS(req) {&#13;
        var rules = req.service.api.operations[req.operation].input;&#13;
        var validation = req.service.config.paramValidation;&#13;
        new AWS.ParamValidator(validation).validate(rules, req.params);&#13;
      });&#13;
  &#13;
      addAsync('COMPUTE_SHA256', 'afterBuild', function COMPUTE_SHA256(req, done) {&#13;
        req.haltHandlersOnError();&#13;
        if (!req.service.api.signatureVersion) return done(); // none&#13;
        if (req.service.getSignerClass(req) === AWS.Signers.V4) {&#13;
          var body = req.httpRequest.body || '';&#13;
          AWS.util.computeSha256(body, function(err, sha) {&#13;
            if (err) {&#13;
              done(err);&#13;
            }&#13;
            else {&#13;
              req.httpRequest.headers['X-Amz-Content-Sha256'] = sha;&#13;
              done();&#13;
            }&#13;
          });&#13;
        } else {&#13;
          done();&#13;
        }&#13;
      });&#13;
  &#13;
      add('SET_CONTENT_LENGTH', 'afterBuild', function SET_CONTENT_LENGTH(req) {&#13;
        if (req.httpRequest.headers['Content-Length'] === undefined) {&#13;
          var length = AWS.util.string.byteLength(req.httpRequest.body);&#13;
          req.httpRequest.headers['Content-Length'] = length;&#13;
        }&#13;
      });&#13;
  &#13;
      add('SET_HTTP_HOST', 'afterBuild', function SET_HTTP_HOST(req) {&#13;
        req.httpRequest.headers['Host'] = req.httpRequest.endpoint.host;&#13;
      });&#13;
  &#13;
      add('RESTART', 'restart', function RESTART() {&#13;
        var err = this.response.error;&#13;
        if (!err || !err.retryable) return;&#13;
  &#13;
        this.httpRequest = new AWS.HttpRequest(&#13;
          this.service.endpoint,&#13;
          this.service.region&#13;
        );&#13;
  &#13;
        if (this.response.retryCount &lt; this.service.config.maxRetries) {&#13;
          this.response.retryCount++;&#13;
        } else {&#13;
          this.response.error = null;&#13;
        }&#13;
      });&#13;
  &#13;
      addAsync('SIGN', 'sign', function SIGN(req, done) {&#13;
        var service = req.service;&#13;
        if (!service.api.signatureVersion) return done(); // none&#13;
  &#13;
        service.config.getCredentials(function (err, credentials) {&#13;
          if (err) {&#13;
            req.response.error = err;&#13;
            return done();&#13;
          }&#13;
  &#13;
          try {&#13;
            var date = AWS.util.date.getDate();&#13;
            var SignerClass = service.getSignerClass(req);&#13;
            var signer = new SignerClass(req.httpRequest,&#13;
              service.api.signingName || service.api.endpointPrefix,&#13;
             service.config.signatureCache);&#13;
            signer.setServiceClientId(service._clientId);&#13;
  &#13;
            delete req.httpRequest.headers['Authorization'];&#13;
            delete req.httpRequest.headers['Date'];&#13;
            delete req.httpRequest.headers['X-Amz-Date'];&#13;
  &#13;
            signer.addAuthorization(credentials, date);&#13;
            req.signedAt = date;&#13;
          } catch (e) {&#13;
            req.response.error = e;&#13;
          }&#13;
          done();&#13;
        });&#13;
      });&#13;
  &#13;
      add('VALIDATE_RESPONSE', 'validateResponse', function VALIDATE_RESPONSE(resp) {&#13;
        if (this.service.successfulResponse(resp, this)) {&#13;
          resp.data = {};&#13;
          resp.error = null;&#13;
        } else {&#13;
          resp.data = null;&#13;
          resp.error = AWS.util.error(new Error(),&#13;
            {code: 'UnknownError', message: 'An unknown error occurred.'});&#13;
        }&#13;
      });&#13;
  &#13;
      addAsync('SEND', 'send', function SEND(resp, done) {&#13;
        resp.httpResponse._abortCallback = done;&#13;
        resp.error = null;&#13;
        resp.data = null;&#13;
  &#13;
        function callback(httpResp) {&#13;
          resp.httpResponse.stream = httpResp;&#13;
  &#13;
          httpResp.on('headers', function onHeaders(statusCode, headers) {&#13;
            resp.request.emit('httpHeaders', [statusCode, headers, resp]);&#13;
  &#13;
            if (!resp.httpResponse.streaming) {&#13;
              if (AWS.HttpClient.streamsApiVersion === 2) { // streams2 API check&#13;
                httpResp.on('readable', function onReadable() {&#13;
                  var data = httpResp.read();&#13;
                  if (data !== null) {&#13;
                    resp.request.emit('httpData', [data, resp]);&#13;
                  }&#13;
                });&#13;
              } else { // legacy streams API&#13;
                httpResp.on('data', function onData(data) {&#13;
                  resp.request.emit('httpData', [data, resp]);&#13;
                });&#13;
              }&#13;
            }&#13;
          });&#13;
  &#13;
          httpResp.on('end', function onEnd() {&#13;
            resp.request.emit('httpDone');&#13;
            done();&#13;
          });&#13;
        }&#13;
  &#13;
        function progress(httpResp) {&#13;
          httpResp.on('sendProgress', function onSendProgress(value) {&#13;
            resp.request.emit('httpUploadProgress', [value, resp]);&#13;
          });&#13;
  &#13;
          httpResp.on('receiveProgress', function onReceiveProgress(value) {&#13;
            resp.request.emit('httpDownloadProgress', [value, resp]);&#13;
          });&#13;
        }&#13;
  &#13;
        function error(err) {&#13;
          resp.error = AWS.util.error(err, {&#13;
            code: 'NetworkingError',&#13;
            region: resp.request.httpRequest.region,&#13;
            hostname: resp.request.httpRequest.endpoint.hostname,&#13;
            retryable: true&#13;
          });&#13;
          resp.request.emit('httpError', [resp.error, resp], function() {&#13;
            done();&#13;
          });&#13;
        }&#13;
  &#13;
        function executeSend() {&#13;
          var http = AWS.HttpClient.getInstance();&#13;
          var httpOptions = resp.request.service.config.httpOptions || {};&#13;
          try {&#13;
            var stream = http.handleRequest(resp.request.httpRequest, httpOptions,&#13;
                                            callback, error);&#13;
            progress(stream);&#13;
          } catch (err) {&#13;
            error(err);&#13;
          }&#13;
        }&#13;
  &#13;
        var timeDiff = (AWS.util.date.getDate() - this.signedAt) / 1000;&#13;
        if (timeDiff &gt;= 60 * 10) { // if we signed 10min ago, re-sign&#13;
          this.emit('sign', [this], function(err) {&#13;
            if (err) done(err);&#13;
            else executeSend();&#13;
          });&#13;
        } else {&#13;
          executeSend();&#13;
        }&#13;
      });&#13;
  &#13;
      add('HTTP_HEADERS', 'httpHeaders',&#13;
          function HTTP_HEADERS(statusCode, headers, resp) {&#13;
        resp.httpResponse.statusCode = statusCode;&#13;
        resp.httpResponse.headers = headers;&#13;
        resp.httpResponse.body = new AWS.util.Buffer('');&#13;
        resp.httpResponse.buffers = [];&#13;
        resp.httpResponse.numBytes = 0;&#13;
        var dateHeader = headers.date || headers.Date;&#13;
        if (dateHeader) {&#13;
          var serverTime = Date.parse(dateHeader);&#13;
          if (resp.request.service.config.correctClockSkew&#13;
              &amp;&amp; AWS.util.isClockSkewed(serverTime)) {&#13;
            AWS.util.applyClockOffset(serverTime);&#13;
          }&#13;
        }&#13;
      });&#13;
  &#13;
      add('HTTP_DATA', 'httpData', function HTTP_DATA(chunk, resp) {&#13;
        if (chunk) {&#13;
          if (AWS.util.isNode()) {&#13;
            resp.httpResponse.numBytes += chunk.length;&#13;
  &#13;
            var total = resp.httpResponse.headers['content-length'];&#13;
            var progress = { loaded: resp.httpResponse.numBytes, total: total };&#13;
            resp.request.emit('httpDownloadProgress', [progress, resp]);&#13;
          }&#13;
  &#13;
          resp.httpResponse.buffers.push(new AWS.util.Buffer(chunk));&#13;
        }&#13;
      });&#13;
  &#13;
      add('HTTP_DONE', 'httpDone', function HTTP_DONE(resp) {&#13;
        if (resp.httpResponse.buffers &amp;&amp; resp.httpResponse.buffers.length &gt; 0) {&#13;
          var body = AWS.util.buffer.concat(resp.httpResponse.buffers);&#13;
          resp.httpResponse.body = body;&#13;
        }&#13;
        delete resp.httpResponse.numBytes;&#13;
        delete resp.httpResponse.buffers;&#13;
      });&#13;
  &#13;
      add('FINALIZE_ERROR', 'retry', function FINALIZE_ERROR(resp) {&#13;
        if (resp.httpResponse.statusCode) {&#13;
          resp.error.statusCode = resp.httpResponse.statusCode;&#13;
          if (resp.error.retryable === undefined) {&#13;
            resp.error.retryable = this.service.retryableError(resp.error, this);&#13;
          }&#13;
        }&#13;
      });&#13;
  &#13;
      add('INVALIDATE_CREDENTIALS', 'retry', function INVALIDATE_CREDENTIALS(resp) {&#13;
        if (!resp.error) return;&#13;
        switch (resp.error.code) {&#13;
          case 'RequestExpired': // EC2 only&#13;
          case 'ExpiredTokenException':&#13;
          case 'ExpiredToken':&#13;
            resp.error.retryable = true;&#13;
            resp.request.service.config.credentials.expired = true;&#13;
        }&#13;
      });&#13;
  &#13;
      add('EXPIRED_SIGNATURE', 'retry', function EXPIRED_SIGNATURE(resp) {&#13;
        var err = resp.error;&#13;
        if (!err) return;&#13;
        if (typeof err.code === 'string' &amp;&amp; typeof err.message === 'string') {&#13;
          if (err.code.match(/Signature/) &amp;&amp; err.message.match(/expired/)) {&#13;
            resp.error.retryable = true;&#13;
          }&#13;
        }&#13;
      });&#13;
  &#13;
      add('CLOCK_SKEWED', 'retry', function CLOCK_SKEWED(resp) {&#13;
        if (!resp.error) return;&#13;
        if (this.service.clockSkewError(resp.error)&#13;
            &amp;&amp; this.service.config.correctClockSkew&#13;
            &amp;&amp; AWS.config.isClockSkewed) {&#13;
          resp.error.retryable = true;&#13;
        }&#13;
      });&#13;
  &#13;
      add('REDIRECT', 'retry', function REDIRECT(resp) {&#13;
        if (resp.error &amp;&amp; resp.error.statusCode &gt;= 300 &amp;&amp;&#13;
            resp.error.statusCode &lt; 400 &amp;&amp; resp.httpResponse.headers['location']) {&#13;
          this.httpRequest.endpoint =&#13;
            new AWS.Endpoint(resp.httpResponse.headers['location']);&#13;
          this.httpRequest.headers['Host'] = this.httpRequest.endpoint.host;&#13;
          resp.error.redirect = true;&#13;
          resp.error.retryable = true;&#13;
        }&#13;
      });&#13;
  &#13;
      add('RETRY_CHECK', 'retry', function RETRY_CHECK(resp) {&#13;
        if (resp.error) {&#13;
          if (resp.error.redirect &amp;&amp; resp.redirectCount &lt; resp.maxRedirects) {&#13;
            resp.error.retryDelay = 0;&#13;
          } else if (resp.retryCount &lt; resp.maxRetries) {&#13;
            resp.error.retryDelay = this.service.retryDelays(resp.retryCount) || 0;&#13;
          }&#13;
        }&#13;
      });&#13;
  &#13;
      addAsync('RESET_RETRY_STATE', 'afterRetry', function RESET_RETRY_STATE(resp, done) {&#13;
        var delay, willRetry = false;&#13;
  &#13;
        if (resp.error) {&#13;
          delay = resp.error.retryDelay || 0;&#13;
          if (resp.error.retryable &amp;&amp; resp.retryCount &lt; resp.maxRetries) {&#13;
            resp.retryCount++;&#13;
            willRetry = true;&#13;
          } else if (resp.error.redirect &amp;&amp; resp.redirectCount &lt; resp.maxRedirects) {&#13;
            resp.redirectCount++;&#13;
            willRetry = true;&#13;
          }&#13;
        }&#13;
  &#13;
        if (willRetry) {&#13;
          resp.error = null;&#13;
          setTimeout(done, delay);&#13;
        } else {&#13;
          done();&#13;
        }&#13;
      });&#13;
    }),&#13;
  &#13;
    CorePost: new SequentialExecutor().addNamedListeners(function(add) {&#13;
      add('EXTRACT_REQUEST_ID', 'extractData', AWS.util.extractRequestId);&#13;
      add('EXTRACT_REQUEST_ID', 'extractError', AWS.util.extractRequestId);&#13;
  &#13;
      add('ENOTFOUND_ERROR', 'httpError', function ENOTFOUND_ERROR(err) {&#13;
        if (err.code === 'NetworkingError' &amp;&amp; err.errno === 'ENOTFOUND') {&#13;
          var message = 'Inaccessible host: `' + err.hostname +&#13;
            '\'. This service may not be available in the `' + err.region +&#13;
            '\' region.';&#13;
          this.response.error = AWS.util.error(new Error(message), {&#13;
            code: 'UnknownEndpoint',&#13;
            region: err.region,&#13;
            hostname: err.hostname,&#13;
            retryable: true,&#13;
            originalError: err&#13;
          });&#13;
        }&#13;
      });&#13;
    }),&#13;
  &#13;
    Logger: new SequentialExecutor().addNamedListeners(function(add) {&#13;
      add('LOG_REQUEST', 'complete', function LOG_REQUEST(resp) {&#13;
        var req = resp.request;&#13;
        var logger = req.service.config.logger;&#13;
        if (!logger) return;&#13;
  &#13;
        function buildMessage() {&#13;
          var time = AWS.util.date.getDate().getTime();&#13;
          var delta = (time - req.startTime.getTime()) / 1000;&#13;
          var ansi = logger.isTTY ? true : false;&#13;
          var status = resp.httpResponse.statusCode;&#13;
          var params = require('util').inspect(req.params, true, null);&#13;
  &#13;
          var message = '';&#13;
          if (ansi) message += '\x1B[33m';&#13;
          message += '[AWS ' + req.service.serviceIdentifier + ' ' + status;&#13;
          message += ' ' + delta.toString() + 's ' + resp.retryCount + ' retries]';&#13;
          if (ansi) message += '\x1B[0;1m';&#13;
          message += ' ' + AWS.util.string.lowerFirst(req.operation);&#13;
          message += '(' + params + ')';&#13;
          if (ansi) message += '\x1B[0m';&#13;
          return message;&#13;
        }&#13;
  &#13;
        var line = buildMessage();&#13;
        if (typeof logger.log === 'function') {&#13;
          logger.log(line);&#13;
        } else if (typeof logger.write === 'function') {&#13;
          logger.write(line + '\n');&#13;
        }&#13;
      });&#13;
    }),&#13;
  &#13;
    Json: new SequentialExecutor().addNamedListeners(function(add) {&#13;
      var svc = require('./protocol/json');&#13;
      add('BUILD', 'build', svc.buildRequest);&#13;
      add('EXTRACT_DATA', 'extractData', svc.extractData);&#13;
      add('EXTRACT_ERROR', 'extractError', svc.extractError);&#13;
    }),&#13;
  &#13;
    Rest: new SequentialExecutor().addNamedListeners(function(add) {&#13;
      var svc = require('./protocol/rest');&#13;
      add('BUILD', 'build', svc.buildRequest);&#13;
      add('EXTRACT_DATA', 'extractData', svc.extractData);&#13;
      add('EXTRACT_ERROR', 'extractError', svc.extractError);&#13;
    }),&#13;
  &#13;
    RestJson: new SequentialExecutor().addNamedListeners(function(add) {&#13;
      var svc = require('./protocol/rest_json');&#13;
      add('BUILD', 'build', svc.buildRequest);&#13;
      add('EXTRACT_DATA', 'extractData', svc.extractData);&#13;
      add('EXTRACT_ERROR', 'extractError', svc.extractError);&#13;
    }),&#13;
  &#13;
    RestXml: new SequentialExecutor().addNamedListeners(function(add) {&#13;
      var svc = require('./protocol/rest_xml');&#13;
      add('BUILD', 'build', svc.buildRequest);&#13;
      add('EXTRACT_DATA', 'extractData', svc.extractData);&#13;
      add('EXTRACT_ERROR', 'extractError', svc.extractError);&#13;
    }),&#13;
  &#13;
    Query: new SequentialExecutor().addNamedListeners(function(add) {&#13;
      var svc = require('./protocol/query');&#13;
      add('BUILD', 'build', svc.buildRequest);&#13;
      add('EXTRACT_DATA', 'extractData', svc.extractData);&#13;
      add('EXTRACT_ERROR', 'extractError', svc.extractError);&#13;
    })&#13;
  };&#13;
  &#13;
  },{"./core":10,"./protocol/json":29,"./protocol/query":30,"./protocol/rest":31,"./protocol/rest_json":32,"./protocol/rest_xml":33,"./sequential_executor":40,"util":128}],18:[function(require,module,exports){&#13;
  var AWS = require('./core');&#13;
  var inherit = AWS.util.inherit;&#13;
  &#13;
  &#13;
  AWS.Endpoint = inherit({&#13;
  &#13;
  &#13;
    constructor: function Endpoint(endpoint, config) {&#13;
      AWS.util.hideProperties(this, ['slashes', 'auth', 'hash', 'search', 'query']);&#13;
  &#13;
      if (typeof endpoint === 'undefined' || endpoint === null) {&#13;
        throw new Error('Invalid endpoint: ' + endpoint);&#13;
      } else if (typeof endpoint !== 'string') {&#13;
        return AWS.util.copy(endpoint);&#13;
      }&#13;
  &#13;
      if (!endpoint.match(/^http/)) {&#13;
        var useSSL = config &amp;&amp; config.sslEnabled !== undefined ?&#13;
          config.sslEnabled : AWS.config.sslEnabled;&#13;
        endpoint = (useSSL ? 'https' : 'http') + '://' + endpoint;&#13;
      }&#13;
  &#13;
      AWS.util.update(this, AWS.util.urlParse(endpoint));&#13;
  &#13;
      if (this.port) {&#13;
        this.port = parseInt(this.port, 10);&#13;
      } else {&#13;
        this.port = this.protocol === 'https:' ? 443 : 80;&#13;
      }&#13;
    }&#13;
  &#13;
  });&#13;
  &#13;
  &#13;
  AWS.HttpRequest = inherit({&#13;
  &#13;
  &#13;
    constructor: function HttpRequest(endpoint, region, customUserAgent) {&#13;
      endpoint = new AWS.Endpoint(endpoint);&#13;
      this.method = 'POST';&#13;
      this.path = endpoint.path || '/';&#13;
      this.headers = {};&#13;
      this.body = '';&#13;
      this.endpoint = endpoint;&#13;
      this.region = region;&#13;
      this.setUserAgent(customUserAgent);&#13;
    },&#13;
  &#13;
  &#13;
    setUserAgent: function setUserAgent(customUserAgent) {&#13;
      var prefix = AWS.util.isBrowser() ? 'X-Amz-' : '';&#13;
      var customSuffix = '';&#13;
      if (typeof customUserAgent === 'string' &amp;&amp; customUserAgent) {&#13;
        customSuffix += ' ' + customUserAgent;&#13;
      }&#13;
      this.headers[prefix + 'User-Agent'] = AWS.util.userAgent() + customSuffix;&#13;
    },&#13;
  &#13;
  &#13;
    pathname: function pathname() {&#13;
      return this.path.split('?', 1)[0];&#13;
    },&#13;
  &#13;
  &#13;
    search: function search() {&#13;
      var query = this.path.split('?', 2)[1];&#13;
      if (query) {&#13;
        query = AWS.util.queryStringParse(query);&#13;
        return AWS.util.queryParamsToString(query);&#13;
      }&#13;
      return '';&#13;
    }&#13;
  &#13;
  });&#13;
  &#13;
  &#13;
  AWS.HttpResponse = inherit({&#13;
  &#13;
  &#13;
    constructor: function HttpResponse() {&#13;
      this.statusCode = undefined;&#13;
      this.headers = {};&#13;
      this.body = undefined;&#13;
      this.streaming = false;&#13;
      this.stream = null;&#13;
    },&#13;
  &#13;
  &#13;
    createUnbufferedStream: function createUnbufferedStream() {&#13;
      this.streaming = true;&#13;
      return this.stream;&#13;
    }&#13;
  });&#13;
  &#13;
  &#13;
  AWS.HttpClient = inherit({});&#13;
  &#13;
  &#13;
  AWS.HttpClient.getInstance = function getInstance() {&#13;
    if (this.singleton === undefined) {&#13;
      this.singleton = new this();&#13;
    }&#13;
    return this.singleton;&#13;
  };&#13;
  &#13;
  },{"./core":10}],19:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var EventEmitter = require('events').EventEmitter;&#13;
  require('../http');&#13;
  &#13;
  &#13;
  AWS.XHRClient = AWS.util.inherit({&#13;
    handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {&#13;
      var self = this;&#13;
      var endpoint = httpRequest.endpoint;&#13;
      var emitter = new EventEmitter();&#13;
      var href = endpoint.protocol + '//' + endpoint.hostname;&#13;
      if (endpoint.port !== 80 &amp;&amp; endpoint.port !== 443) {&#13;
        href += ':' + endpoint.port;&#13;
      }&#13;
      href += httpRequest.path;&#13;
  &#13;
      var xhr = new XMLHttpRequest(), headersEmitted = false;&#13;
      httpRequest.stream = xhr;&#13;
  &#13;
      xhr.addEventListener('readystatechange', function() {&#13;
        try {&#13;
          if (xhr.status === 0) return; // 0 code is invalid&#13;
        } catch (e) { return; }&#13;
  &#13;
        if (this.readyState &gt;= this.HEADERS_RECEIVED &amp;&amp; !headersEmitted) {&#13;
          try { xhr.responseType = 'arraybuffer'; } catch (e) {}&#13;
          emitter.statusCode = xhr.status;&#13;
          emitter.headers = self.parseHeaders(xhr.getAllResponseHeaders());&#13;
          emitter.emit('headers', emitter.statusCode, emitter.headers);&#13;
          headersEmitted = true;&#13;
        }&#13;
        if (this.readyState === this.DONE) {&#13;
          self.finishRequest(xhr, emitter);&#13;
        }&#13;
      }, false);&#13;
      xhr.upload.addEventListener('progress', function (evt) {&#13;
        emitter.emit('sendProgress', evt);&#13;
      });&#13;
      xhr.addEventListener('progress', function (evt) {&#13;
        emitter.emit('receiveProgress', evt);&#13;
      }, false);&#13;
      xhr.addEventListener('timeout', function () {&#13;
        errCallback(AWS.util.error(new Error('Timeout'), {code: 'TimeoutError'}));&#13;
      }, false);&#13;
      xhr.addEventListener('error', function () {&#13;
        errCallback(AWS.util.error(new Error('Network Failure'), {&#13;
          code: 'NetworkingError'&#13;
        }));&#13;
      }, false);&#13;
      /** BEGIN HOT-FIX: DO NOT REMOVE https://issues.amazon.com/issues/JS-358 */&#13;
      xhr.addEventListener('abort', function () {&#13;
        errCallback(AWS.util.error(new Error('Connection aborted'), {&#13;
          code: 'RequestAborted'&#13;
        }));&#13;
      }, false);&#13;
      /** END */&#13;
  &#13;
      callback(emitter);&#13;
      xhr.open(httpRequest.method, href, httpOptions.xhrAsync !== false);&#13;
      AWS.util.each(httpRequest.headers, function (key, value) {&#13;
        if (key !== 'Content-Length' &amp;&amp; key !== 'User-Agent' &amp;&amp; key !== 'Host') {&#13;
          xhr.setRequestHeader(key, value);&#13;
        }&#13;
      });&#13;
  &#13;
      if (httpOptions.timeout &amp;&amp; httpOptions.xhrAsync !== false) {&#13;
        xhr.timeout = httpOptions.timeout;&#13;
      }&#13;
  &#13;
      if (httpOptions.xhrWithCredentials) {&#13;
        xhr.withCredentials = true;&#13;
      }&#13;
  &#13;
      try {&#13;
        xhr.send(httpRequest.body);&#13;
      } catch (err) {&#13;
        if (httpRequest.body &amp;&amp; typeof httpRequest.body.buffer === 'object') {&#13;
          xhr.send(httpRequest.body.buffer); // send ArrayBuffer directly&#13;
        } else {&#13;
          throw err;&#13;
        }&#13;
      }&#13;
  &#13;
      return emitter;&#13;
    },&#13;
  &#13;
    parseHeaders: function parseHeaders(rawHeaders) {&#13;
      var headers = {};&#13;
      AWS.util.arrayEach(rawHeaders.split(/\r?\n/), function (line) {&#13;
        var key = line.split(':', 1)[0];&#13;
        var value = line.substring(key.length + 2);&#13;
        if (key.length &gt; 0) headers[key.toLowerCase()] = value;&#13;
      });&#13;
      return headers;&#13;
    },&#13;
  &#13;
    finishRequest: function finishRequest(xhr, emitter) {&#13;
      var buffer;&#13;
      if (xhr.responseType === 'arraybuffer' &amp;&amp; xhr.response) {&#13;
        var ab = xhr.response;&#13;
        buffer = new AWS.util.Buffer(ab.byteLength);&#13;
        var view = new Uint8Array(ab);&#13;
        for (var i = 0; i &lt; buffer.length; ++i) {&#13;
          buffer[i] = view[i];&#13;
        }&#13;
      }&#13;
  &#13;
      try {&#13;
        if (!buffer &amp;&amp; typeof xhr.responseText === 'string') {&#13;
          buffer = new AWS.util.Buffer(xhr.responseText);&#13;
        }&#13;
      } catch (e) {}&#13;
  &#13;
      if (buffer) emitter.emit('data', buffer);&#13;
      emitter.emit('end');&#13;
    }&#13;
  });&#13;
  &#13;
  &#13;
  AWS.HttpClient.prototype = AWS.XHRClient.prototype;&#13;
  &#13;
  &#13;
  AWS.HttpClient.streamsApiVersion = 1;&#13;
  &#13;
  },{"../core":10,"../http":18,"events":65}],20:[function(require,module,exports){&#13;
  var util = require('../util');&#13;
  &#13;
  function JsonBuilder() { }&#13;
  &#13;
  JsonBuilder.prototype.build = function(value, shape) {&#13;
    return JSON.stringify(translate(value, shape));&#13;
  };&#13;
  &#13;
  function translate(value, shape) {&#13;
    if (!shape || value === undefined || value === null) return undefined;&#13;
  &#13;
    switch (shape.type) {&#13;
      case 'structure': return translateStructure(value, shape);&#13;
      case 'map': return translateMap(value, shape);&#13;
      case 'list': return translateList(value, shape);&#13;
      default: return translateScalar(value, shape);&#13;
    }&#13;
  }&#13;
  &#13;
  function translateStructure(structure, shape) {&#13;
    var struct = {};&#13;
    util.each(structure, function(name, value) {&#13;
      var memberShape = shape.members[name];&#13;
      if (memberShape) {&#13;
        if (memberShape.location !== 'body') return;&#13;
        var locationName = memberShape.isLocationName ? memberShape.name : name;&#13;
        var result = translate(value, memberShape);&#13;
        if (result !== undefined) struct[locationName] = result;&#13;
      }&#13;
    });&#13;
    return struct;&#13;
  }&#13;
  &#13;
  function translateList(list, shape) {&#13;
    var out = [];&#13;
    util.arrayEach(list, function(value) {&#13;
      var result = translate(value, shape.member);&#13;
      if (result !== undefined) out.push(result);&#13;
    });&#13;
    return out;&#13;
  }&#13;
  &#13;
  function translateMap(map, shape) {&#13;
    var out = {};&#13;
    util.each(map, function(key, value) {&#13;
      var result = translate(value, shape.value);&#13;
      if (result !== undefined) out[key] = result;&#13;
    });&#13;
    return out;&#13;
  }&#13;
  &#13;
  function translateScalar(value, shape) {&#13;
    return shape.toWireFormat(value);&#13;
  }&#13;
  &#13;
  module.exports = JsonBuilder;&#13;
  &#13;
  },{"../util":52}],21:[function(require,module,exports){&#13;
  var util = require('../util');&#13;
  &#13;
  function JsonParser() { }&#13;
  &#13;
  JsonParser.prototype.parse = function(value, shape) {&#13;
    return translate(JSON.parse(value), shape);&#13;
  };&#13;
  &#13;
  function translate(value, shape) {&#13;
    if (!shape || value === undefined) return undefined;&#13;
  &#13;
    switch (shape.type) {&#13;
      case 'structure': return translateStructure(value, shape);&#13;
      case 'map': return translateMap(value, shape);&#13;
      case 'list': return translateList(value, shape);&#13;
      default: return translateScalar(value, shape);&#13;
    }&#13;
  }&#13;
  &#13;
  function translateStructure(structure, shape) {&#13;
    if (structure == null) return undefined;&#13;
  &#13;
    var struct = {};&#13;
    var shapeMembers = shape.members;&#13;
    util.each(shapeMembers, function(name, memberShape) {&#13;
      var locationName = memberShape.isLocationName ? memberShape.name : name;&#13;
      if (Object.prototype.hasOwnProperty.call(structure, locationName)) {&#13;
        var value = structure[locationName];&#13;
        var result = translate(value, memberShape);&#13;
        if (result !== undefined) struct[name] = result;&#13;
      }&#13;
    });&#13;
    return struct;&#13;
  }&#13;
  &#13;
  function translateList(list, shape) {&#13;
    if (list == null) return undefined;&#13;
  &#13;
    var out = [];&#13;
    util.arrayEach(list, function(value) {&#13;
      var result = translate(value, shape.member);&#13;
      if (result === undefined) out.push(null);&#13;
      else out.push(result);&#13;
    });&#13;
    return out;&#13;
  }&#13;
  &#13;
  function translateMap(map, shape) {&#13;
    if (map == null) return undefined;&#13;
  &#13;
    var out = {};&#13;
    util.each(map, function(key, value) {&#13;
      var result = translate(value, shape.value);&#13;
      if (result === undefined) out[key] = null;&#13;
      else out[key] = result;&#13;
    });&#13;
    return out;&#13;
  }&#13;
  &#13;
  function translateScalar(value, shape) {&#13;
    return shape.toType(value);&#13;
  }&#13;
  &#13;
  module.exports = JsonParser;&#13;
  &#13;
  },{"../util":52}],22:[function(require,module,exports){&#13;
  var Collection = require('./collection');&#13;
  var Operation = require('./operation');&#13;
  var Shape = require('./shape');&#13;
  var Paginator = require('./paginator');&#13;
  var ResourceWaiter = require('./resource_waiter');&#13;
  &#13;
  var util = require('../util');&#13;
  var property = util.property;&#13;
  var memoizedProperty = util.memoizedProperty;&#13;
  &#13;
  function Api(api, options) {&#13;
    api = api || {};&#13;
    options = options || {};&#13;
    options.api = this;&#13;
  &#13;
    api.metadata = api.metadata || {};&#13;
  &#13;
    property(this, 'isApi', true, false);&#13;
    property(this, 'apiVersion', api.metadata.apiVersion);&#13;
    property(this, 'endpointPrefix', api.metadata.endpointPrefix);&#13;
    property(this, 'signingName', api.metadata.signingName);&#13;
    property(this, 'globalEndpoint', api.metadata.globalEndpoint);&#13;
    property(this, 'signatureVersion', api.metadata.signatureVersion);&#13;
    property(this, 'jsonVersion', api.metadata.jsonVersion);&#13;
    property(this, 'targetPrefix', api.metadata.targetPrefix);&#13;
    property(this, 'protocol', api.metadata.protocol);&#13;
    property(this, 'timestampFormat', api.metadata.timestampFormat);&#13;
    property(this, 'xmlNamespaceUri', api.metadata.xmlNamespace);&#13;
    property(this, 'abbreviation', api.metadata.serviceAbbreviation);&#13;
    property(this, 'fullName', api.metadata.serviceFullName);&#13;
  &#13;
    memoizedProperty(this, 'className', function() {&#13;
      var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;&#13;
      if (!name) return null;&#13;
  &#13;
      name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, '');&#13;
      if (name === 'ElasticLoadBalancing') name = 'ELB';&#13;
      return name;&#13;
    });&#13;
  &#13;
    property(this, 'operations', new Collection(api.operations, options, function(name, operation) {&#13;
      return new Operation(name, operation, options);&#13;
    }, util.string.lowerFirst));&#13;
  &#13;
    property(this, 'shapes', new Collection(api.shapes, options, function(name, shape) {&#13;
      return Shape.create(shape, options);&#13;
    }));&#13;
  &#13;
    property(this, 'paginators', new Collection(api.paginators, options, function(name, paginator) {&#13;
      return new Paginator(name, paginator, options);&#13;
    }));&#13;
  &#13;
    property(this, 'waiters', new Collection(api.waiters, options, function(name, waiter) {&#13;
      return new ResourceWaiter(name, waiter, options);&#13;
    }, util.string.lowerFirst));&#13;
  &#13;
    if (options.documentation) {&#13;
      property(this, 'documentation', api.documentation);&#13;
      property(this, 'documentationUrl', api.documentationUrl);&#13;
    }&#13;
  }&#13;
  &#13;
  module.exports = Api;&#13;
  &#13;
  },{"../util":52,"./collection":23,"./operation":24,"./paginator":25,"./resource_waiter":26,"./shape":27}],23:[function(require,module,exports){&#13;
  var memoizedProperty = require('../util').memoizedProperty;&#13;
  &#13;
  function memoize(name, value, fn, nameTr) {&#13;
    memoizedProperty(this, nameTr(name), function() {&#13;
      return fn(name, value);&#13;
    });&#13;
  }&#13;
  &#13;
  function Collection(iterable, options, fn, nameTr) {&#13;
    nameTr = nameTr || String;&#13;
    var self = this;&#13;
  &#13;
    for (var id in iterable) {&#13;
      if (Object.prototype.hasOwnProperty.call(iterable, id)) {&#13;
        memoize.call(self, id, iterable[id], fn, nameTr);&#13;
      }&#13;
    }&#13;
  }&#13;
  &#13;
  module.exports = Collection;&#13;
  &#13;
  },{"../util":52}],24:[function(require,module,exports){&#13;
  var Shape = require('./shape');&#13;
  &#13;
  var util = require('../util');&#13;
  var property = util.property;&#13;
  var memoizedProperty = util.memoizedProperty;&#13;
  &#13;
  function Operation(name, operation, options) {&#13;
    options = options || {};&#13;
  &#13;
    property(this, 'name', operation.name || name);&#13;
    property(this, 'api', options.api, false);&#13;
  &#13;
    operation.http = operation.http || {};&#13;
    property(this, 'httpMethod', operation.http.method || 'POST');&#13;
    property(this, 'httpPath', operation.http.requestUri || '/');&#13;
    property(this, 'authtype', operation.authtype || '');&#13;
  &#13;
    memoizedProperty(this, 'input', function() {&#13;
      if (!operation.input) {&#13;
        return new Shape.create({type: 'structure'}, options);&#13;
      }&#13;
      return Shape.create(operation.input, options);&#13;
    });&#13;
  &#13;
    memoizedProperty(this, 'output', function() {&#13;
      if (!operation.output) {&#13;
        return new Shape.create({type: 'structure'}, options);&#13;
      }&#13;
      return Shape.create(operation.output, options);&#13;
    });&#13;
  &#13;
    memoizedProperty(this, 'errors', function() {&#13;
      var list = [];&#13;
      if (!operation.errors) return null;&#13;
  &#13;
      for (var i = 0; i &lt; operation.errors.length; i++) {&#13;
        list.push(Shape.create(operation.errors[i], options));&#13;
      }&#13;
  &#13;
      return list;&#13;
    });&#13;
  &#13;
    memoizedProperty(this, 'paginator', function() {&#13;
      return options.api.paginators[name];&#13;
    });&#13;
  &#13;
    if (options.documentation) {&#13;
      property(this, 'documentation', operation.documentation);&#13;
      property(this, 'documentationUrl', operation.documentationUrl);&#13;
    }&#13;
  }&#13;
  &#13;
  module.exports = Operation;&#13;
  &#13;
  },{"../util":52,"./shape":27}],25:[function(require,module,exports){&#13;
  var property = require('../util').property;&#13;
  &#13;
  function Paginator(name, paginator) {&#13;
    property(this, 'inputToken', paginator.input_token);&#13;
    property(this, 'limitKey', paginator.limit_key);&#13;
    property(this, 'moreResults', paginator.more_results);&#13;
    property(this, 'outputToken', paginator.output_token);&#13;
    property(this, 'resultKey', paginator.result_key);&#13;
  }&#13;
  &#13;
  module.exports = Paginator;&#13;
  &#13;
  },{"../util":52}],26:[function(require,module,exports){&#13;
  var util = require('../util');&#13;
  var property = util.property;&#13;
  &#13;
  function ResourceWaiter(name, waiter, options) {&#13;
    options = options || {};&#13;
    property(this, 'name', name);&#13;
    property(this, 'api', options.api, false);&#13;
  &#13;
    if (waiter.operation) {&#13;
      property(this, 'operation', util.string.lowerFirst(waiter.operation));&#13;
    }&#13;
  &#13;
    var self = this;&#13;
    var keys = [&#13;
      'type',&#13;
      'description',&#13;
      'delay',&#13;
      'maxAttempts',&#13;
      'acceptors'&#13;
    ];&#13;
  &#13;
    keys.forEach(function(key) {&#13;
      var value = waiter[key];&#13;
      if (value) {&#13;
        property(self, key, value);&#13;
      }&#13;
    });&#13;
  }&#13;
  &#13;
  module.exports = ResourceWaiter;&#13;
  &#13;
  },{"../util":52}],27:[function(require,module,exports){&#13;
  var Collection = require('./collection');&#13;
  &#13;
  var util = require('../util');&#13;
  &#13;
  function property(obj, name, value) {&#13;
    if (value !== null &amp;&amp; value !== undefined) {&#13;
      util.property.apply(this, arguments);&#13;
    }&#13;
  }&#13;
  &#13;
  function memoizedProperty(obj, name) {&#13;
    if (!obj.constructor.prototype[name]) {&#13;
      util.memoizedProperty.apply(this, arguments);&#13;
    }&#13;
  }&#13;
  &#13;
  function Shape(shape, options, memberName) {&#13;
    options = options || {};&#13;
  &#13;
    property(this, 'shape', shape.shape);&#13;
    property(this, 'api', options.api, false);&#13;
    property(this, 'type', shape.type);&#13;
    property(this, 'enum', shape.enum);&#13;
    property(this, 'min', shape.min);&#13;
    property(this, 'max', shape.max);&#13;
    property(this, 'pattern', shape.pattern);&#13;
    property(this, 'location', shape.location || this.location || 'body');&#13;
    property(this, 'name', this.name || shape.xmlName || shape.queryName ||&#13;
      shape.locationName || memberName);&#13;
    property(this, 'isStreaming', shape.streaming || this.isStreaming || false);&#13;
    property(this, 'isComposite', shape.isComposite || false);&#13;
    property(this, 'isShape', true, false);&#13;
    property(this, 'isQueryName', shape.queryName ? true : false, false);&#13;
    property(this, 'isLocationName', shape.locationName ? true : false, false);&#13;
  &#13;
    if (options.documentation) {&#13;
      property(this, 'documentation', shape.documentation);&#13;
      property(this, 'documentationUrl', shape.documentationUrl);&#13;
    }&#13;
  &#13;
    if (shape.xmlAttribute) {&#13;
      property(this, 'isXmlAttribute', shape.xmlAttribute || false);&#13;
    }&#13;
  &#13;
    property(this, 'defaultValue', null);&#13;
    this.toWireFormat = function(value) {&#13;
      if (value === null || value === undefined) return '';&#13;
      return value;&#13;
    };&#13;
    this.toType = function(value) { return value; };&#13;
  }&#13;
  &#13;
  &#13;
  Shape.normalizedTypes = {&#13;
    character: 'string',&#13;
    double: 'float',&#13;
    long: 'integer',&#13;
    short: 'integer',&#13;
    biginteger: 'integer',&#13;
    bigdecimal: 'float',&#13;
    blob: 'binary'&#13;
  };&#13;
  &#13;
  &#13;
  Shape.types = {&#13;
    'structure': StructureShape,&#13;
    'list': ListShape,&#13;
    'map': MapShape,&#13;
    'boolean': BooleanShape,&#13;
    'timestamp': TimestampShape,&#13;
    'float': FloatShape,&#13;
    'integer': IntegerShape,&#13;
    'string': StringShape,&#13;
    'base64': Base64Shape,&#13;
    'binary': BinaryShape&#13;
  };&#13;
  &#13;
  Shape.resolve = function resolve(shape, options) {&#13;
    if (shape.shape) {&#13;
      var refShape = options.api.shapes[shape.shape];&#13;
      if (!refShape) {&#13;
        throw new Error('Cannot find shape reference: ' + shape.shape);&#13;
      }&#13;
  &#13;
      return refShape;&#13;
    } else {&#13;
      return null;&#13;
    }&#13;
  };&#13;
  &#13;
  Shape.create = function create(shape, options, memberName) {&#13;
    if (shape.isShape) return shape;&#13;
  &#13;
    var refShape = Shape.resolve(shape, options);&#13;
    if (refShape) {&#13;
      var filteredKeys = Object.keys(shape);&#13;
      if (!options.documentation) {&#13;
        filteredKeys = filteredKeys.filter(function(name) {&#13;
          return !name.match(/documentation/);&#13;
        });&#13;
      }&#13;
      if (filteredKeys === ['shape']) { // no inline customizations&#13;
        return refShape;&#13;
      }&#13;
  &#13;
      var InlineShape = function() {&#13;
        refShape.constructor.call(this, shape, options, memberName);&#13;
      };&#13;
      InlineShape.prototype = refShape;&#13;
      return new InlineShape();&#13;
    } else {&#13;
      if (!shape.type) {&#13;
        if (shape.members) shape.type = 'structure';&#13;
        else if (shape.member) shape.type = 'list';&#13;
        else if (shape.key) shape.type = 'map';&#13;
        else shape.type = 'string';&#13;
      }&#13;
  &#13;
      var origType = shape.type;&#13;
      if (Shape.normalizedTypes[shape.type]) {&#13;
        shape.type = Shape.normalizedTypes[shape.type];&#13;
      }&#13;
  &#13;
      if (Shape.types[shape.type]) {&#13;
        return new Shape.types[shape.type](shape, options, memberName);&#13;
      } else {&#13;
        throw new Error('Unrecognized shape type: ' + origType);&#13;
      }&#13;
    }&#13;
  };&#13;
  &#13;
  function CompositeShape(shape) {&#13;
    Shape.apply(this, arguments);&#13;
    property(this, 'isComposite', true);&#13;
  &#13;
    if (shape.flattened) {&#13;
      property(this, 'flattened', shape.flattened || false);&#13;
    }&#13;
  }&#13;
  &#13;
  function StructureShape(shape, options) {&#13;
    var requiredMap = null, firstInit = !this.isShape;&#13;
  &#13;
    CompositeShape.apply(this, arguments);&#13;
  &#13;
    if (firstInit) {&#13;
      property(this, 'defaultValue', function() { return {}; });&#13;
      property(this, 'members', {});&#13;
      property(this, 'memberNames', []);&#13;
      property(this, 'required', []);&#13;
      property(this, 'isRequired', function() { return false; });&#13;
    }&#13;
  &#13;
    if (shape.members) {&#13;
      property(this, 'members', new Collection(shape.members, options, function(name, member) {&#13;
        return Shape.create(member, options, name);&#13;
      }));&#13;
      memoizedProperty(this, 'memberNames', function() {&#13;
        return shape.xmlOrder || Object.keys(shape.members);&#13;
      });&#13;
    }&#13;
  &#13;
    if (shape.required) {&#13;
      property(this, 'required', shape.required);&#13;
      property(this, 'isRequired', function(name) {&#13;
        if (!requiredMap) {&#13;
          requiredMap = {};&#13;
          for (var i = 0; i &lt; shape.required.length; i++) {&#13;
            requiredMap[shape.required[i]] = true;&#13;
          }&#13;
        }&#13;
  &#13;
        return requiredMap[name];&#13;
      }, false, true);&#13;
    }&#13;
  &#13;
    property(this, 'resultWrapper', shape.resultWrapper || null);&#13;
  &#13;
    if (shape.payload) {&#13;
      property(this, 'payload', shape.payload);&#13;
    }&#13;
  &#13;
    if (typeof shape.xmlNamespace === 'string') {&#13;
      property(this, 'xmlNamespaceUri', shape.xmlNamespace);&#13;
    } else if (typeof shape.xmlNamespace === 'object') {&#13;
      property(this, 'xmlNamespacePrefix', shape.xmlNamespace.prefix);&#13;
      property(this, 'xmlNamespaceUri', shape.xmlNamespace.uri);&#13;
    }&#13;
  }&#13;
  &#13;
  function ListShape(shape, options) {&#13;
    var self = this, firstInit = !this.isShape;&#13;
    CompositeShape.apply(this, arguments);&#13;
  &#13;
    if (firstInit) {&#13;
      property(this, 'defaultValue', function() { return []; });&#13;
    }&#13;
  &#13;
    if (shape.member) {&#13;
      memoizedProperty(this, 'member', function() {&#13;
        return Shape.create(shape.member, options);&#13;
      });&#13;
    }&#13;
  &#13;
    if (this.flattened) {&#13;
      var oldName = this.name;&#13;
      memoizedProperty(this, 'name', function() {&#13;
        return self.member.name || oldName;&#13;
      });&#13;
    }&#13;
  }&#13;
  &#13;
  function MapShape(shape, options) {&#13;
    var firstInit = !this.isShape;&#13;
    CompositeShape.apply(this, arguments);&#13;
  &#13;
    if (firstInit) {&#13;
      property(this, 'defaultValue', function() { return {}; });&#13;
      property(this, 'key', Shape.create({type: 'string'}, options));&#13;
      property(this, 'value', Shape.create({type: 'string'}, options));&#13;
    }&#13;
  &#13;
    if (shape.key) {&#13;
      memoizedProperty(this, 'key', function() {&#13;
        return Shape.create(shape.key, options);&#13;
      });&#13;
    }&#13;
    if (shape.value) {&#13;
      memoizedProperty(this, 'value', function() {&#13;
        return Shape.create(shape.value, options);&#13;
      });&#13;
    }&#13;
  }&#13;
  &#13;
  function TimestampShape(shape) {&#13;
    var self = this;&#13;
    Shape.apply(this, arguments);&#13;
  &#13;
    if (this.location === 'header') {&#13;
      property(this, 'timestampFormat', 'rfc822');&#13;
    } else if (shape.timestampFormat) {&#13;
      property(this, 'timestampFormat', shape.timestampFormat);&#13;
    } else if (this.api) {&#13;
      if (this.api.timestampFormat) {&#13;
        property(this, 'timestampFormat', this.api.timestampFormat);&#13;
      } else {&#13;
        switch (this.api.protocol) {&#13;
          case 'json':&#13;
          case 'rest-json':&#13;
            property(this, 'timestampFormat', 'unixTimestamp');&#13;
            break;&#13;
          case 'rest-xml':&#13;
          case 'query':&#13;
          case 'ec2':&#13;
            property(this, 'timestampFormat', 'iso8601');&#13;
            break;&#13;
        }&#13;
      }&#13;
    }&#13;
  &#13;
    this.toType = function(value) {&#13;
      if (value === null || value === undefined) return null;&#13;
      if (typeof value.toUTCString === 'function') return value;&#13;
      return typeof value === 'string' || typeof value === 'number' ?&#13;
             util.date.parseTimestamp(value) : null;&#13;
    };&#13;
  &#13;
    this.toWireFormat = function(value) {&#13;
      return util.date.format(value, self.timestampFormat);&#13;
    };&#13;
  }&#13;
  &#13;
  function StringShape() {&#13;
    Shape.apply(this, arguments);&#13;
  &#13;
    if (this.api) {&#13;
      switch (this.api.protocol) {&#13;
        case 'rest-xml':&#13;
        case 'query':&#13;
        case 'ec2':&#13;
          this.toType = function(value) { return value || ''; };&#13;
      }&#13;
    }&#13;
  }&#13;
  &#13;
  function FloatShape() {&#13;
    Shape.apply(this, arguments);&#13;
  &#13;
    this.toType = function(value) {&#13;
      if (value === null || value === undefined) return null;&#13;
      return parseFloat(value);&#13;
    };&#13;
    this.toWireFormat = this.toType;&#13;
  }&#13;
  &#13;
  function IntegerShape() {&#13;
    Shape.apply(this, arguments);&#13;
  &#13;
    this.toType = function(value) {&#13;
      if (value === null || value === undefined) return null;&#13;
      return parseInt(value, 10);&#13;
    };&#13;
    this.toWireFormat = this.toType;&#13;
  }&#13;
  &#13;
  function BinaryShape() {&#13;
    Shape.apply(this, arguments);&#13;
    this.toType = util.base64.decode;&#13;
    this.toWireFormat = util.base64.encode;&#13;
  }&#13;
  &#13;
  function Base64Shape() {&#13;
    BinaryShape.apply(this, arguments);&#13;
  }&#13;
  &#13;
  function BooleanShape() {&#13;
    Shape.apply(this, arguments);&#13;
  &#13;
    this.toType = function(value) {&#13;
      if (typeof value === 'boolean') return value;&#13;
      if (value === null || value === undefined) return null;&#13;
      return value === 'true';&#13;
    };&#13;
  }&#13;
  &#13;
  &#13;
  Shape.shapes = {&#13;
    StructureShape: StructureShape,&#13;
    ListShape: ListShape,&#13;
    MapShape: MapShape,&#13;
    StringShape: StringShape,&#13;
    BooleanShape: BooleanShape,&#13;
    Base64Shape: Base64Shape&#13;
  };&#13;
  &#13;
  module.exports = Shape;&#13;
  &#13;
  },{"../util":52,"./collection":23}],28:[function(require,module,exports){&#13;
  var AWS = require('./core');&#13;
  &#13;
  &#13;
  AWS.ParamValidator = AWS.util.inherit({&#13;
  &#13;
    constructor: function ParamValidator(validation) {&#13;
      if (validation === true || validation === undefined) {&#13;
        validation = {'min': true};&#13;
      }&#13;
      this.validation = validation;&#13;
    },&#13;
  &#13;
    validate: function validate(shape, params, context) {&#13;
      this.errors = [];&#13;
      this.validateMember(shape, params || {}, context || 'params');&#13;
  &#13;
      if (this.errors.length &gt; 1) {&#13;
        var msg = this.errors.join('\n* ');&#13;
        msg = 'There were ' + this.errors.length +&#13;
          ' validation errors:\n* ' + msg;&#13;
        throw AWS.util.error(new Error(msg),&#13;
          {code: 'MultipleValidationErrors', errors: this.errors});&#13;
      } else if (this.errors.length === 1) {&#13;
        throw this.errors[0];&#13;
      } else {&#13;
        return true;&#13;
      }&#13;
    },&#13;
  &#13;
    fail: function fail(code, message) {&#13;
      this.errors.push(AWS.util.error(new Error(message), {code: code}));&#13;
    },&#13;
  &#13;
    validateStructure: function validateStructure(shape, params, context) {&#13;
      this.validateType(params, context, ['object'], 'structure');&#13;
  &#13;
      var paramName;&#13;
      for (var i = 0; shape.required &amp;&amp; i &lt; shape.required.length; i++) {&#13;
        paramName = shape.required[i];&#13;
        var value = params[paramName];&#13;
        if (value === undefined || value === null) {&#13;
          this.fail('MissingRequiredParameter',&#13;
            'Missing required key \'' + paramName + '\' in ' + context);&#13;
        }&#13;
      }&#13;
  &#13;
      for (paramName in params) {&#13;
        if (!Object.prototype.hasOwnProperty.call(params, paramName)) continue;&#13;
  &#13;
        var paramValue = params[paramName],&#13;
            memberShape = shape.members[paramName];&#13;
  &#13;
        if (memberShape !== undefined) {&#13;
          var memberContext = [context, paramName].join('.');&#13;
          this.validateMember(memberShape, paramValue, memberContext);&#13;
        } else {&#13;
          this.fail('UnexpectedParameter',&#13;
            'Unexpected key \'' + paramName + '\' found in ' + context);&#13;
        }&#13;
      }&#13;
  &#13;
      return true;&#13;
    },&#13;
  &#13;
    validateMember: function validateMember(shape, param, context) {&#13;
      switch (shape.type) {&#13;
        case 'structure':&#13;
          return this.validateStructure(shape, param, context);&#13;
        case 'list':&#13;
          return this.validateList(shape, param, context);&#13;
        case 'map':&#13;
          return this.validateMap(shape, param, context);&#13;
        default:&#13;
          return this.validateScalar(shape, param, context);&#13;
      }&#13;
    },&#13;
  &#13;
    validateList: function validateList(shape, params, context) {&#13;
      if (this.validateType(params, context, [Array])) {&#13;
        this.validateRange(shape, params.length, context, 'list member count');&#13;
        for (var i = 0; i &lt; params.length; i++) {&#13;
          this.validateMember(shape.member, params[i], context + '[' + i + ']');&#13;
        }&#13;
      }&#13;
    },&#13;
  &#13;
    validateMap: function validateMap(shape, params, context) {&#13;
      if (this.validateType(params, context, ['object'], 'map')) {&#13;
        var mapCount = 0;&#13;
        for (var param in params) {&#13;
          if (!Object.prototype.hasOwnProperty.call(params, param)) continue;&#13;
          this.validateMember(shape.key, param,&#13;
                              context + '[key=\'' + param + '\']')&#13;
          this.validateMember(shape.value, params[param],&#13;
                              context + '[\'' + param + '\']');&#13;
          mapCount++;&#13;
        }&#13;
        this.validateRange(shape, mapCount, context, 'map member count');&#13;
      }&#13;
    },&#13;
  &#13;
    validateScalar: function validateScalar(shape, value, context) {&#13;
      switch (shape.type) {&#13;
        case null:&#13;
        case undefined:&#13;
        case 'string':&#13;
          return this.validateString(shape, value, context);&#13;
        case 'base64':&#13;
        case 'binary':&#13;
          return this.validatePayload(value, context);&#13;
        case 'integer':&#13;
        case 'float':&#13;
          return this.validateNumber(shape, value, context);&#13;
        case 'boolean':&#13;
          return this.validateType(value, context, ['boolean']);&#13;
        case 'timestamp':&#13;
          return this.validateType(value, context, [Date,&#13;
            /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/, 'number'],&#13;
            'Date object, ISO-8601 string, or a UNIX timestamp');&#13;
        default:&#13;
          return this.fail('UnkownType', 'Unhandled type ' +&#13;
                           shape.type + ' for ' + context);&#13;
      }&#13;
    },&#13;
  &#13;
    validateString: function validateString(shape, value, context) {&#13;
      if (this.validateType(value, context, ['string'])) {&#13;
        this.validateEnum(shape, value, context);&#13;
        this.validateRange(shape, value.length, context, 'string length');&#13;
        this.validatePattern(shape, value, context);&#13;
      }&#13;
    },&#13;
  &#13;
    validatePattern: function validatePattern(shape, value, context) {&#13;
      if (this.validation['pattern'] &amp;&amp; shape['pattern'] !== undefined) {&#13;
        if (!(new RegExp(shape['pattern'])).test(value)) {&#13;
          this.fail('PatternMatchError', 'Provided value "' + value + '" '&#13;
            + 'does not match regex pattern /' + shape['pattern'] + '/ for '&#13;
            + context);&#13;
        }&#13;
      }&#13;
    },&#13;
  &#13;
    validateRange: function validateRange(shape, value, context, descriptor) {&#13;
      if (this.validation['min']) {&#13;
        if (shape['min'] !== undefined &amp;&amp; value &lt; shape['min']) {&#13;
          this.fail('MinRangeError', 'Expected ' + descriptor + ' &gt;= '&#13;
            + shape['min'] + ', but found ' + value + ' for ' + context);&#13;
        }&#13;
      }&#13;
      if (this.validation['max']) {&#13;
        if (shape['max'] !== undefined &amp;&amp; value &gt; shape['max']) {&#13;
          this.fail('MaxRangeError', 'Expected ' + descriptor + ' &lt;= '&#13;
            + shape['max'] + ', but found ' + value + ' for ' + context);&#13;
        }&#13;
      }&#13;
    },&#13;
  &#13;
    validateEnum: function validateRange(shape, value, context) {&#13;
      if (this.validation['enum'] &amp;&amp; shape['enum'] !== undefined) {&#13;
        if (shape['enum'].indexOf(value) === -1) {&#13;
          this.fail('EnumError', 'Found string value of ' + value + ', but '&#13;
            + 'expected ' + shape['enum'].join('|') + ' for ' + context);&#13;
        }&#13;
      }&#13;
    },&#13;
  &#13;
    validateType: function validateType(value, context, acceptedTypes, type) {&#13;
      if (value === null || value === undefined) return false;&#13;
  &#13;
      var foundInvalidType = false;&#13;
      for (var i = 0; i &lt; acceptedTypes.length; i++) {&#13;
        if (typeof acceptedTypes[i] === 'string') {&#13;
          if (typeof value === acceptedTypes[i]) return true;&#13;
        } else if (acceptedTypes[i] instanceof RegExp) {&#13;
          if ((value || '').toString().match(acceptedTypes[i])) return true;&#13;
        } else {&#13;
          if (value instanceof acceptedTypes[i]) return true;&#13;
          if (AWS.util.isType(value, acceptedTypes[i])) return true;&#13;
          if (!type &amp;&amp; !foundInvalidType) acceptedTypes = acceptedTypes.slice();&#13;
          acceptedTypes[i] = AWS.util.typeName(acceptedTypes[i]);&#13;
        }&#13;
        foundInvalidType = true;&#13;
      }&#13;
  &#13;
      var acceptedType = type;&#13;
      if (!acceptedType) {&#13;
        acceptedType = acceptedTypes.join(', ').replace(/,([^,]+)$/, ', or$1');&#13;
      }&#13;
  &#13;
      var vowel = acceptedType.match(/^[aeiou]/i) ? 'n' : '';&#13;
      this.fail('InvalidParameterType', 'Expected ' + context + ' to be a' +&#13;
                vowel + ' ' + acceptedType);&#13;
      return false;&#13;
    },&#13;
  &#13;
    validateNumber: function validateNumber(shape, value, context) {&#13;
      if (value === null || value === undefined) return;&#13;
      if (typeof value === 'string') {&#13;
        var castedValue = parseFloat(value);&#13;
        if (castedValue.toString() === value) value = castedValue;&#13;
      }&#13;
      if (this.validateType(value, context, ['number'])) {&#13;
        this.validateRange(shape, value, context, 'numeric value');&#13;
      }&#13;
    },&#13;
  &#13;
    validatePayload: function validatePayload(value, context) {&#13;
      if (value === null || value === undefined) return;&#13;
      if (typeof value === 'string') return;&#13;
      if (value &amp;&amp; typeof value.byteLength === 'number') return; // typed arrays&#13;
      if (AWS.util.isNode()) { // special check for buffer/stream in Node.js&#13;
        var Stream = AWS.util.stream.Stream;&#13;
        if (AWS.util.Buffer.isBuffer(value) || value instanceof Stream) return;&#13;
      }&#13;
  &#13;
      var types = ['Buffer', 'Stream', 'File', 'Blob', 'ArrayBuffer', 'DataView'];&#13;
      if (value) {&#13;
        for (var i = 0; i &lt; types.length; i++) {&#13;
          if (AWS.util.isType(value, types[i])) return;&#13;
          if (AWS.util.typeName(value.constructor) === types[i]) return;&#13;
        }&#13;
      }&#13;
  &#13;
      this.fail('InvalidParameterType', 'Expected ' + context + ' to be a ' +&#13;
        'string, Buffer, Stream, Blob, or typed array object');&#13;
    }&#13;
  });&#13;
  &#13;
  },{"./core":10}],29:[function(require,module,exports){&#13;
  var util = require('../util');&#13;
  var JsonBuilder = require('../json/builder');&#13;
  var JsonParser = require('../json/parser');&#13;
  &#13;
  function buildRequest(req) {&#13;
    var httpRequest = req.httpRequest;&#13;
    var api = req.service.api;&#13;
    var target = api.targetPrefix + '.' + api.operations[req.operation].name;&#13;
    var version = api.jsonVersion || '1.0';&#13;
    var input = api.operations[req.operation].input;&#13;
    var builder = new JsonBuilder();&#13;
  &#13;
    if (version === 1) version = '1.0';&#13;
    httpRequest.body = builder.build(req.params || {}, input);&#13;
    httpRequest.headers['Content-Type'] = 'application/x-amz-json-' + version;&#13;
    httpRequest.headers['X-Amz-Target'] = target;&#13;
  }&#13;
  &#13;
  function extractError(resp) {&#13;
    var error = {};&#13;
    var httpResponse = resp.httpResponse;&#13;
  &#13;
    error.code = httpResponse.headers['x-amzn-errortype'] || 'UnknownError';&#13;
    if (typeof error.code === 'string') {&#13;
      error.code = error.code.split(':')[0];&#13;
    }&#13;
  &#13;
    if (httpResponse.body.length &gt; 0) {&#13;
      var e = JSON.parse(httpResponse.body.toString());&#13;
      if (e.__type || e.code) {&#13;
        error.code = (e.__type || e.code).split('#').pop();&#13;
      }&#13;
      if (error.code === 'RequestEntityTooLarge') {&#13;
        error.message = 'Request body must be less than 1 MB';&#13;
      } else {&#13;
        error.message = (e.message || e.Message || null);&#13;
      }&#13;
    } else {&#13;
      error.statusCode = httpResponse.statusCode;&#13;
      error.message = httpResponse.statusCode.toString();&#13;
    }&#13;
  &#13;
    resp.error = util.error(new Error(), error);&#13;
  }&#13;
  &#13;
  function extractData(resp) {&#13;
    var body = resp.httpResponse.body.toString() || '{}';&#13;
    if (resp.request.service.config.convertResponseTypes === false) {&#13;
      resp.data = JSON.parse(body);&#13;
    } else {&#13;
      var operation = resp.request.service.api.operations[resp.request.operation];&#13;
      var shape = operation.output || {};&#13;
      var parser = new JsonParser();&#13;
      resp.data = parser.parse(body, shape);&#13;
    }&#13;
  }&#13;
  &#13;
  module.exports = {&#13;
    buildRequest: buildRequest,&#13;
    extractError: extractError,&#13;
    extractData: extractData&#13;
  };&#13;
  &#13;
  },{"../json/builder":20,"../json/parser":21,"../util":52}],30:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var util = require('../util');&#13;
  var QueryParamSerializer = require('../query/query_param_serializer');&#13;
  var Shape = require('../model/shape');&#13;
  &#13;
  function buildRequest(req) {&#13;
    var operation = req.service.api.operations[req.operation];&#13;
    var httpRequest = req.httpRequest;&#13;
    httpRequest.headers['Content-Type'] =&#13;
      'application/x-www-form-urlencoded; charset=utf-8';&#13;
    httpRequest.params = {&#13;
      Version: req.service.api.apiVersion,&#13;
      Action: operation.name&#13;
    };&#13;
  &#13;
    var builder = new QueryParamSerializer();&#13;
    builder.serialize(req.params, operation.input, function(name, value) {&#13;
      httpRequest.params[name] = value;&#13;
    });&#13;
    httpRequest.body = util.queryParamsToString(httpRequest.params);&#13;
  }&#13;
  &#13;
  function extractError(resp) {&#13;
    var data, body = resp.httpResponse.body.toString();&#13;
    if (body.match('&lt;UnknownOperationException')) {&#13;
      data = {&#13;
        Code: 'UnknownOperation',&#13;
        Message: 'Unknown operation ' + resp.request.operation&#13;
      };&#13;
    } else {&#13;
      data = new AWS.XML.Parser().parse(body);&#13;
    }&#13;
  &#13;
    if (data.requestId &amp;&amp; !resp.requestId) resp.requestId = data.requestId;&#13;
    if (data.Errors) data = data.Errors;&#13;
    if (data.Error) data = data.Error;&#13;
    if (data.Code) {&#13;
      resp.error = util.error(new Error(), {&#13;
        code: data.Code,&#13;
        message: data.Message&#13;
      });&#13;
    } else {&#13;
      resp.error = util.error(new Error(), {&#13;
        code: resp.httpResponse.statusCode,&#13;
        message: null&#13;
      });&#13;
    }&#13;
  }&#13;
  &#13;
  function extractData(resp) {&#13;
    var req = resp.request;&#13;
    var operation = req.service.api.operations[req.operation];&#13;
    var shape = operation.output || {};&#13;
    var origRules = shape;&#13;
  &#13;
    if (origRules.resultWrapper) {&#13;
      var tmp = Shape.create({type: 'structure'});&#13;
      tmp.members[origRules.resultWrapper] = shape;&#13;
      tmp.memberNames = [origRules.resultWrapper];&#13;
      util.property(shape, 'name', shape.resultWrapper);&#13;
      shape = tmp;&#13;
    }&#13;
  &#13;
    var parser = new AWS.XML.Parser();&#13;
  &#13;
    if (shape &amp;&amp; shape.members &amp;&amp; !shape.members._XAMZRequestId) {&#13;
      var requestIdShape = Shape.create(&#13;
        { type: 'string' },&#13;
        { api: { protocol: 'query' } },&#13;
        'requestId'&#13;
      );&#13;
      shape.members._XAMZRequestId = requestIdShape;&#13;
    }&#13;
  &#13;
    var data = parser.parse(resp.httpResponse.body.toString(), shape);&#13;
    resp.requestId = data._XAMZRequestId || data.requestId;&#13;
  &#13;
    if (data._XAMZRequestId) delete data._XAMZRequestId;&#13;
  &#13;
    if (origRules.resultWrapper) {&#13;
      if (data[origRules.resultWrapper]) {&#13;
        util.update(data, data[origRules.resultWrapper]);&#13;
        delete data[origRules.resultWrapper];&#13;
      }&#13;
    }&#13;
  &#13;
    resp.data = data;&#13;
  }&#13;
  &#13;
  module.exports = {&#13;
    buildRequest: buildRequest,&#13;
    extractError: extractError,&#13;
    extractData: extractData&#13;
  };&#13;
  &#13;
  },{"../core":10,"../model/shape":27,"../query/query_param_serializer":34,"../util":52}],31:[function(require,module,exports){&#13;
  var util = require('../util');&#13;
  &#13;
  function populateMethod(req) {&#13;
    req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;&#13;
  }&#13;
  &#13;
  function populateURI(req) {&#13;
    var operation = req.service.api.operations[req.operation];&#13;
    var input = operation.input;&#13;
    var uri = [req.httpRequest.endpoint.path, operation.httpPath].join('/');&#13;
    uri = uri.replace(/\/+/g, '/');&#13;
  &#13;
    var queryString = {}, queryStringSet = false;&#13;
    util.each(input.members, function (name, member) {&#13;
      var paramValue = req.params[name];&#13;
      if (paramValue === null || paramValue === undefined) return;&#13;
      if (member.location === 'uri') {&#13;
        var regex = new RegExp('\\{' + member.name + '(\\+)?\\}');&#13;
        uri = uri.replace(regex, function(_, plus) {&#13;
          var fn = plus ? util.uriEscapePath : util.uriEscape;&#13;
          return fn(String(paramValue));&#13;
        });&#13;
      } else if (member.location === 'querystring') {&#13;
        queryStringSet = true;&#13;
  &#13;
        if (member.type === 'list') {&#13;
          queryString[member.name] = paramValue.map(function(val) {&#13;
            return util.uriEscape(String(val));&#13;
          });&#13;
        } else if (member.type === 'map') {&#13;
          util.each(paramValue, function(key, value) {&#13;
            if (Array.isArray(value)) {&#13;
              queryString[key] = value.map(function(val) {&#13;
                return util.uriEscape(String(val));&#13;
              });&#13;
            } else {&#13;
              queryString[key] = util.uriEscape(String(value));&#13;
            }&#13;
          });&#13;
        } else {&#13;
          queryString[member.name] = util.uriEscape(String(paramValue));&#13;
        }&#13;
      }&#13;
    });&#13;
  &#13;
    if (queryStringSet) {&#13;
      uri += (uri.indexOf('?') &gt;= 0 ? '&amp;' : '?');&#13;
      var parts = [];&#13;
      util.arrayEach(Object.keys(queryString).sort(), function(key) {&#13;
        if (!Array.isArray(queryString[key])) {&#13;
          queryString[key] = [queryString[key]];&#13;
        }&#13;
        for (var i = 0; i &lt; queryString[key].length; i++) {&#13;
          parts.push(util.uriEscape(String(key)) + '=' + queryString[key][i]);&#13;
        }&#13;
      });&#13;
      uri += parts.join('&amp;');&#13;
    }&#13;
  &#13;
    req.httpRequest.path = uri;&#13;
  }&#13;
  &#13;
  function populateHeaders(req) {&#13;
    var operation = req.service.api.operations[req.operation];&#13;
    util.each(operation.input.members, function (name, member) {&#13;
      var value = req.params[name];&#13;
      if (value === null || value === undefined) return;&#13;
  &#13;
      if (member.location === 'headers' &amp;&amp; member.type === 'map') {&#13;
        util.each(value, function(key, memberValue) {&#13;
          req.httpRequest.headers[member.name + key] = memberValue;&#13;
        });&#13;
      } else if (member.location === 'header') {&#13;
        value = member.toWireFormat(value).toString();&#13;
        req.httpRequest.headers[member.name] = value;&#13;
      }&#13;
    });&#13;
  }&#13;
  &#13;
  function buildRequest(req) {&#13;
    populateMethod(req);&#13;
    populateURI(req);&#13;
    populateHeaders(req);&#13;
  }&#13;
  &#13;
  function extractError() {&#13;
  }&#13;
  &#13;
  function extractData(resp) {&#13;
    var req = resp.request;&#13;
    var data = {};&#13;
    var r = resp.httpResponse;&#13;
    var operation = req.service.api.operations[req.operation];&#13;
    var output = operation.output;&#13;
  &#13;
    var headers = {};&#13;
    util.each(r.headers, function (k, v) {&#13;
      headers[k.toLowerCase()] = v;&#13;
    });&#13;
  &#13;
    util.each(output.members, function(name, member) {&#13;
      var header = (member.name || name).toLowerCase();&#13;
      if (member.location === 'headers' &amp;&amp; member.type === 'map') {&#13;
        data[name] = {};&#13;
        var location = member.isLocationName ? member.name : '';&#13;
        var pattern = new RegExp('^' + location + '(.+)', 'i');&#13;
        util.each(r.headers, function (k, v) {&#13;
          var result = k.match(pattern);&#13;
          if (result !== null) {&#13;
            data[name][result[1]] = v;&#13;
          }&#13;
        });&#13;
      } else if (member.location === 'header') {&#13;
        if (headers[header] !== undefined) {&#13;
          data[name] = headers[header];&#13;
        }&#13;
      } else if (member.location === 'statusCode') {&#13;
        data[name] = parseInt(r.statusCode, 10);&#13;
      }&#13;
    });&#13;
  &#13;
    resp.data = data;&#13;
  }&#13;
  &#13;
  module.exports = {&#13;
    buildRequest: buildRequest,&#13;
    extractError: extractError,&#13;
    extractData: extractData&#13;
  };&#13;
  &#13;
  },{"../util":52}],32:[function(require,module,exports){&#13;
  var util = require('../util');&#13;
  var Rest = require('./rest');&#13;
  var Json = require('./json');&#13;
  var JsonBuilder = require('../json/builder');&#13;
  var JsonParser = require('../json/parser');&#13;
  &#13;
  function populateBody(req) {&#13;
    var builder = new JsonBuilder();&#13;
    var input = req.service.api.operations[req.operation].input;&#13;
  &#13;
    if (input.payload) {&#13;
      var params = {};&#13;
      var payloadShape = input.members[input.payload];&#13;
      params = req.params[input.payload];&#13;
      if (params === undefined) return;&#13;
  &#13;
      if (payloadShape.type === 'structure') {&#13;
        req.httpRequest.body = builder.build(params, payloadShape);&#13;
      } else { // non-JSON payload&#13;
        req.httpRequest.body = params;&#13;
      }&#13;
    } else {&#13;
      req.httpRequest.body = builder.build(req.params, input);&#13;
    }&#13;
  }&#13;
  &#13;
  function buildRequest(req) {&#13;
    Rest.buildRequest(req);&#13;
  &#13;
    if (['GET', 'HEAD', 'DELETE'].indexOf(req.httpRequest.method) &lt; 0) {&#13;
      populateBody(req);&#13;
    }&#13;
  }&#13;
  &#13;
  function extractError(resp) {&#13;
    Json.extractError(resp);&#13;
  }&#13;
  &#13;
  function extractData(resp) {&#13;
    Rest.extractData(resp);&#13;
  &#13;
    var req = resp.request;&#13;
    var rules = req.service.api.operations[req.operation].output || {};&#13;
    if (rules.payload) {&#13;
      var payloadMember = rules.members[rules.payload];&#13;
      var body = resp.httpResponse.body;&#13;
      if (payloadMember.isStreaming) {&#13;
        resp.data[rules.payload] = body;&#13;
      } else if (payloadMember.type === 'structure' || payloadMember.type === 'list') {&#13;
        var parser = new JsonParser();&#13;
        resp.data[rules.payload] = parser.parse(body, payloadMember);&#13;
      } else {&#13;
        resp.data[rules.payload] = body.toString();&#13;
      }&#13;
    } else {&#13;
      var data = resp.data;&#13;
      Json.extractData(resp);&#13;
      resp.data = util.merge(data, resp.data);&#13;
    }&#13;
  }&#13;
  &#13;
  module.exports = {&#13;
    buildRequest: buildRequest,&#13;
    extractError: extractError,&#13;
    extractData: extractData&#13;
  };&#13;
  &#13;
  },{"../json/builder":20,"../json/parser":21,"../util":52,"./json":29,"./rest":31}],33:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var util = require('../util');&#13;
  var Rest = require('./rest');&#13;
  &#13;
  function populateBody(req) {&#13;
    var input = req.service.api.operations[req.operation].input;&#13;
    var builder = new AWS.XML.Builder();&#13;
    var params = req.params;&#13;
  &#13;
    var payload = input.payload;&#13;
    if (payload) {&#13;
      var payloadMember = input.members[payload];&#13;
      params = params[payload];&#13;
      if (params === undefined) return;&#13;
  &#13;
      if (payloadMember.type === 'structure') {&#13;
        var rootElement = payloadMember.name;&#13;
        req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);&#13;
      } else { // non-xml payload&#13;
        req.httpRequest.body = params;&#13;
      }&#13;
    } else {&#13;
      req.httpRequest.body = builder.toXML(params, input, input.name ||&#13;
        input.shape || util.string.upperFirst(req.operation) + 'Request');&#13;
    }&#13;
  }&#13;
  &#13;
  function buildRequest(req) {&#13;
    Rest.buildRequest(req);&#13;
  &#13;
    if (['GET', 'HEAD'].indexOf(req.httpRequest.method) &lt; 0) {&#13;
      populateBody(req);&#13;
    }&#13;
  }&#13;
  &#13;
  function extractError(resp) {&#13;
    Rest.extractError(resp);&#13;
  &#13;
    var data = new AWS.XML.Parser().parse(resp.httpResponse.body.toString());&#13;
    if (data.Errors) data = data.Errors;&#13;
    if (data.Error) data = data.Error;&#13;
    if (data.Code) {&#13;
      resp.error = util.error(new Error(), {&#13;
        code: data.Code,&#13;
        message: data.Message&#13;
      });&#13;
    } else {&#13;
      resp.error = util.error(new Error(), {&#13;
        code: resp.httpResponse.statusCode,&#13;
        message: null&#13;
      });&#13;
    }&#13;
  }&#13;
  &#13;
  function extractData(resp) {&#13;
    Rest.extractData(resp);&#13;
  &#13;
    var parser;&#13;
    var req = resp.request;&#13;
    var body = resp.httpResponse.body;&#13;
    var operation = req.service.api.operations[req.operation];&#13;
    var output = operation.output;&#13;
  &#13;
    var payload = output.payload;&#13;
    if (payload) {&#13;
      var payloadMember = output.members[payload];&#13;
      if (payloadMember.isStreaming) {&#13;
        resp.data[payload] = body;&#13;
      } else if (payloadMember.type === 'structure') {&#13;
        parser = new AWS.XML.Parser();&#13;
        resp.data[payload] = parser.parse(body.toString(), payloadMember);&#13;
      } else {&#13;
        resp.data[payload] = body.toString();&#13;
      }&#13;
    } else if (body.length &gt; 0) {&#13;
      parser = new AWS.XML.Parser();&#13;
      var data = parser.parse(body.toString(), output);&#13;
      util.update(resp.data, data);&#13;
    }&#13;
  }&#13;
  &#13;
  module.exports = {&#13;
    buildRequest: buildRequest,&#13;
    extractError: extractError,&#13;
    extractData: extractData&#13;
  };&#13;
  &#13;
  },{"../core":10,"../util":52,"./rest":31}],34:[function(require,module,exports){&#13;
  var util = require('../util');&#13;
  &#13;
  function QueryParamSerializer() {&#13;
  }&#13;
  &#13;
  QueryParamSerializer.prototype.serialize = function(params, shape, fn) {&#13;
    serializeStructure('', params, shape, fn);&#13;
  };&#13;
  &#13;
  function ucfirst(shape) {&#13;
    if (shape.isQueryName || shape.api.protocol !== 'ec2') {&#13;
      return shape.name;&#13;
    } else {&#13;
      return shape.name[0].toUpperCase() + shape.name.substr(1);&#13;
    }&#13;
  }&#13;
  &#13;
  function serializeStructure(prefix, struct, rules, fn) {&#13;
    util.each(rules.members, function(name, member) {&#13;
      var value = struct[name];&#13;
      if (value === null || value === undefined) return;&#13;
  &#13;
      var memberName = ucfirst(member);&#13;
      memberName = prefix ? prefix + '.' + memberName : memberName;&#13;
      serializeMember(memberName, value, member, fn);&#13;
    });&#13;
  }&#13;
  &#13;
  function serializeMap(name, map, rules, fn) {&#13;
    var i = 1;&#13;
    util.each(map, function (key, value) {&#13;
      var prefix = rules.flattened ? '.' : '.entry.';&#13;
      var position = prefix + (i++) + '.';&#13;
      var keyName = position + (rules.key.name || 'key');&#13;
      var valueName = position + (rules.value.name || 'value');&#13;
      serializeMember(name + keyName, key, rules.key, fn);&#13;
      serializeMember(name + valueName, value, rules.value, fn);&#13;
    });&#13;
  }&#13;
  &#13;
  function serializeList(name, list, rules, fn) {&#13;
    var memberRules = rules.member || {};&#13;
  &#13;
    if (list.length === 0) {&#13;
      fn.call(this, name, null);&#13;
      return;&#13;
    }&#13;
  &#13;
    util.arrayEach(list, function (v, n) {&#13;
      var suffix = '.' + (n + 1);&#13;
      if (rules.api.protocol === 'ec2') {&#13;
        suffix = suffix + ''; // make linter happy&#13;
      } else if (rules.flattened) {&#13;
        if (memberRules.name) {&#13;
          var parts = name.split('.');&#13;
          parts.pop();&#13;
          parts.push(ucfirst(memberRules));&#13;
          name = parts.join('.');&#13;
        }&#13;
      } else {&#13;
        suffix = '.member' + suffix;&#13;
      }&#13;
      serializeMember(name + suffix, v, memberRules, fn);&#13;
    });&#13;
  }&#13;
  &#13;
  function serializeMember(name, value, rules, fn) {&#13;
    if (value === null || value === undefined) return;&#13;
    if (rules.type === 'structure') {&#13;
      serializeStructure(name, value, rules, fn);&#13;
    } else if (rules.type === 'list') {&#13;
      serializeList(name, value, rules, fn);&#13;
    } else if (rules.type === 'map') {&#13;
      serializeMap(name, value, rules, fn);&#13;
    } else {&#13;
      fn(name, rules.toWireFormat(value).toString());&#13;
    }&#13;
  }&#13;
  &#13;
  module.exports = QueryParamSerializer;&#13;
  &#13;
  },{"../util":52}],35:[function(require,module,exports){&#13;
  module.exports={&#13;
    "rules": {&#13;
      "*/*": {&#13;
        "endpoint": "{service}.{region}.amazonaws.com"&#13;
      },&#13;
      "cn-*/*": {&#13;
        "endpoint": "{service}.{region}.amazonaws.com.cn"&#13;
      },&#13;
      "*/budgets": "globalSSL",&#13;
      "*/cloudfront": "globalSSL",&#13;
      "*/iam": "globalSSL",&#13;
      "*/sts": "globalSSL",&#13;
      "*/importexport": {&#13;
        "endpoint": "{service}.amazonaws.com",&#13;
        "signatureVersion": "v2",&#13;
        "globalEndpoint": true&#13;
      },&#13;
      "*/route53": {&#13;
        "endpoint": "https://{service}.amazonaws.com",&#13;
        "signatureVersion": "v3https",&#13;
        "globalEndpoint": true&#13;
      },&#13;
      "*/waf": "globalSSL",&#13;
      "us-gov-*/iam": "globalGovCloud",&#13;
      "us-gov-*/sts": {&#13;
        "endpoint": "{service}.{region}.amazonaws.com"&#13;
      },&#13;
      "us-gov-west-1/s3": "s3dash",&#13;
      "us-west-1/s3": "s3dash",&#13;
      "us-west-2/s3": "s3dash",&#13;
      "eu-west-1/s3": "s3dash",&#13;
      "ap-southeast-1/s3": "s3dash",&#13;
      "ap-southeast-2/s3": "s3dash",&#13;
      "ap-northeast-1/s3": "s3dash",&#13;
      "sa-east-1/s3": "s3dash",&#13;
      "us-east-1/s3": {&#13;
        "endpoint": "{service}.amazonaws.com",&#13;
        "signatureVersion": "s3"&#13;
      },&#13;
      "us-east-1/sdb": {&#13;
        "endpoint": "{service}.amazonaws.com",&#13;
        "signatureVersion": "v2"&#13;
      },&#13;
      "*/sdb": {&#13;
        "endpoint": "{service}.{region}.amazonaws.com",&#13;
        "signatureVersion": "v2"&#13;
      }&#13;
    },&#13;
  &#13;
    "patterns": {&#13;
      "globalSSL": {&#13;
        "endpoint": "https://{service}.amazonaws.com",&#13;
        "globalEndpoint": true&#13;
      },&#13;
      "globalGovCloud": {&#13;
        "endpoint": "{service}.us-gov.amazonaws.com"&#13;
      },&#13;
      "s3dash": {&#13;
        "endpoint": "{service}-{region}.amazonaws.com",&#13;
        "signatureVersion": "s3"&#13;
      }&#13;
    }&#13;
  }&#13;
  &#13;
  },{}],36:[function(require,module,exports){&#13;
  var util = require('./util');&#13;
  var regionConfig = require('./region_config.json');&#13;
  &#13;
  function generateRegionPrefix(region) {&#13;
    if (!region) return null;&#13;
  &#13;
    var parts = region.split('-');&#13;
    if (parts.length &lt; 3) return null;&#13;
    return parts.slice(0, parts.length - 2).join('-') + '-*';&#13;
  }&#13;
  &#13;
  function derivedKeys(service) {&#13;
    var region = service.config.region;&#13;
    var regionPrefix = generateRegionPrefix(region);&#13;
    var endpointPrefix = service.api.endpointPrefix;&#13;
  &#13;
    return [&#13;
      [region, endpointPrefix],&#13;
      [regionPrefix, endpointPrefix],&#13;
      [region, '*'],&#13;
      [regionPrefix, '*'],&#13;
      ['*', endpointPrefix],&#13;
      ['*', '*']&#13;
    ].map(function(item) {&#13;
      return item[0] &amp;&amp; item[1] ? item.join('/') : null;&#13;
    });&#13;
  }&#13;
  &#13;
  function applyConfig(service, config) {&#13;
    util.each(config, function(key, value) {&#13;
      if (key === 'globalEndpoint') return;&#13;
      if (service.config[key] === undefined || service.config[key] === null) {&#13;
        service.config[key] = value;&#13;
      }&#13;
    });&#13;
  }&#13;
  &#13;
  function configureEndpoint(service) {&#13;
    var keys = derivedKeys(service);&#13;
    for (var i = 0; i &lt; keys.length; i++) {&#13;
      var key = keys[i];&#13;
      if (!key) continue;&#13;
  &#13;
      if (Object.prototype.hasOwnProperty.call(regionConfig.rules, key)) {&#13;
        var config = regionConfig.rules[key];&#13;
        if (typeof config === 'string') {&#13;
          config = regionConfig.patterns[config];&#13;
        }&#13;
  &#13;
        if (service.config.useDualstack &amp;&amp; util.isDualstackAvailable(service)) {&#13;
          config = util.copy(config);&#13;
          config.endpoint = '{service}.dualstack.{region}.amazonaws.com';&#13;
        }&#13;
  &#13;
        service.isGlobalEndpoint = !!config.globalEndpoint;&#13;
  &#13;
        if (!config.signatureVersion) config.signatureVersion = 'v4';&#13;
  &#13;
        applyConfig(service, config);&#13;
        return;&#13;
      }&#13;
    }&#13;
  }&#13;
  &#13;
  module.exports = configureEndpoint;&#13;
  &#13;
  },{"./region_config.json":35,"./util":52}],37:[function(require,module,exports){&#13;
  (function (process){&#13;
  var AWS = require('./core');&#13;
  var AcceptorStateMachine = require('./state_machine');&#13;
  var inherit = AWS.util.inherit;&#13;
  var domain = AWS.util.domain;&#13;
  var jmespath = require('jmespath');&#13;
  &#13;
  &#13;
  var hardErrorStates = {success: 1, error: 1, complete: 1};&#13;
  &#13;
  function isTerminalState(machine) {&#13;
    return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);&#13;
  }&#13;
  &#13;
  var fsm = new AcceptorStateMachine();&#13;
  fsm.setupStates = function() {&#13;
    var transition = function(_, done) {&#13;
      var self = this;&#13;
      self._haltHandlersOnError = false;&#13;
  &#13;
      self.emit(self._asm.currentState, function(err) {&#13;
        if (err) {&#13;
          if (isTerminalState(self)) {&#13;
            if (domain &amp;&amp; self.domain instanceof domain.Domain) {&#13;
              err.domainEmitter = self;&#13;
              err.domain = self.domain;&#13;
              err.domainThrown = false;&#13;
              self.domain.emit('error', err);&#13;
            } else {&#13;
              throw err;&#13;
            }&#13;
          } else {&#13;
            self.response.error = err;&#13;
            done(err);&#13;
          }&#13;
        } else {&#13;
          done(self.response.error);&#13;
        }&#13;
      });&#13;
  &#13;
    };&#13;
  &#13;
    this.addState('validate', 'build', 'error', transition);&#13;
    this.addState('build', 'afterBuild', 'restart', transition);&#13;
    this.addState('afterBuild', 'sign', 'restart', transition);&#13;
    this.addState('sign', 'send', 'retry', transition);&#13;
    this.addState('retry', 'afterRetry', 'afterRetry', transition);&#13;
    this.addState('afterRetry', 'sign', 'error', transition);&#13;
    this.addState('send', 'validateResponse', 'retry', transition);&#13;
    this.addState('validateResponse', 'extractData', 'extractError', transition);&#13;
    this.addState('extractError', 'extractData', 'retry', transition);&#13;
    this.addState('extractData', 'success', 'retry', transition);&#13;
    this.addState('restart', 'build', 'error', transition);&#13;
    this.addState('success', 'complete', 'complete', transition);&#13;
    this.addState('error', 'complete', 'complete', transition);&#13;
    this.addState('complete', null, null, transition);&#13;
  };&#13;
  fsm.setupStates();&#13;
  &#13;
  &#13;
  AWS.Request = inherit({&#13;
  &#13;
  &#13;
    constructor: function Request(service, operation, params) {&#13;
      var endpoint = service.endpoint;&#13;
      var region = service.config.region;&#13;
      var customUserAgent = service.config.customUserAgent;&#13;
  &#13;
      if (service.isGlobalEndpoint) region = 'us-east-1';&#13;
  &#13;
      this.domain = domain &amp;&amp; domain.active;&#13;
      this.service = service;&#13;
      this.operation = operation;&#13;
      this.params = params || {};&#13;
      this.httpRequest = new AWS.HttpRequest(endpoint, region, customUserAgent);&#13;
      this.startTime = AWS.util.date.getDate();&#13;
  &#13;
      this.response = new AWS.Response(this);&#13;
      this._asm = new AcceptorStateMachine(fsm.states, 'validate');&#13;
      this._haltHandlersOnError = false;&#13;
  &#13;
      AWS.SequentialExecutor.call(this);&#13;
      this.emit = this.emitEvent;&#13;
    },&#13;
  &#13;
  &#13;
  &#13;
  &#13;
    send: function send(callback) {&#13;
      if (callback) {&#13;
        this.on('complete', function (resp) {&#13;
          callback.call(resp, resp.error, resp.data);&#13;
        });&#13;
      }&#13;
      this.runTo();&#13;
  &#13;
      return this.response;&#13;
    },&#13;
  &#13;
  &#13;
  &#13;
  &#13;
    build: function build(callback) {&#13;
      return this.runTo('send', callback);&#13;
    },&#13;
  &#13;
  &#13;
    runTo: function runTo(state, done) {&#13;
      this._asm.runTo(state, done, this);&#13;
      return this;&#13;
    },&#13;
  &#13;
  &#13;
    abort: function abort() {&#13;
      this.removeAllListeners('validateResponse');&#13;
      this.removeAllListeners('extractError');&#13;
      this.on('validateResponse', function addAbortedError(resp) {&#13;
        resp.error = AWS.util.error(new Error('Request aborted by user'), {&#13;
           code: 'RequestAbortedError', retryable: false&#13;
        });&#13;
      });&#13;
  &#13;
      if (this.httpRequest.stream) { // abort HTTP stream&#13;
        this.httpRequest.stream.abort();&#13;
        if (this.httpRequest._abortCallback) {&#13;
           this.httpRequest._abortCallback();&#13;
        } else {&#13;
          this.removeAllListeners('send'); // haven't sent yet, so let's not&#13;
        }&#13;
      }&#13;
  &#13;
      return this;&#13;
    },&#13;
  &#13;
  &#13;
    eachPage: function eachPage(callback) {&#13;
      callback = AWS.util.fn.makeAsync(callback, 3);&#13;
  &#13;
      function wrappedCallback(response) {&#13;
        callback.call(response, response.error, response.data, function (result) {&#13;
          if (result === false) return;&#13;
  &#13;
          if (response.hasNextPage()) {&#13;
            response.nextPage().on('complete', wrappedCallback).send();&#13;
          } else {&#13;
            callback.call(response, null, null, AWS.util.fn.noop);&#13;
          }&#13;
        });&#13;
      }&#13;
  &#13;
      this.on('complete', wrappedCallback).send();&#13;
    },&#13;
  &#13;
  &#13;
    eachItem: function eachItem(callback) {&#13;
      var self = this;&#13;
      function wrappedCallback(err, data) {&#13;
        if (err) return callback(err, null);&#13;
        if (data === null) return callback(null, null);&#13;
  &#13;
        var config = self.service.paginationConfig(self.operation);&#13;
        var resultKey = config.resultKey;&#13;
        if (Array.isArray(resultKey)) resultKey = resultKey[0];&#13;
        var items = jmespath.search(data, resultKey);&#13;
        var continueIteration = true;&#13;
        AWS.util.arrayEach(items, function(item) {&#13;
          continueIteration = callback(null, item);&#13;
          if (continueIteration === false) {&#13;
            return AWS.util.abort;&#13;
          }&#13;
        });&#13;
        return continueIteration;&#13;
      }&#13;
  &#13;
      this.eachPage(wrappedCallback);&#13;
    },&#13;
  &#13;
  &#13;
    isPageable: function isPageable() {&#13;
      return this.service.paginationConfig(this.operation) ? true : false;&#13;
    },&#13;
  &#13;
  &#13;
    createReadStream: function createReadStream() {&#13;
      var streams = AWS.util.stream;&#13;
      var req = this;&#13;
      var stream = null;&#13;
  &#13;
      if (AWS.HttpClient.streamsApiVersion === 2) {&#13;
        stream = new streams.PassThrough();&#13;
        req.send();&#13;
      } else {&#13;
        stream = new streams.Stream();&#13;
        stream.readable = true;&#13;
  &#13;
        stream.sent = false;&#13;
        stream.on('newListener', function(event) {&#13;
          if (!stream.sent &amp;&amp; event === 'data') {&#13;
            stream.sent = true;&#13;
            process.nextTick(function() { req.send(); });&#13;
          }&#13;
        });&#13;
      }&#13;
  &#13;
      this.on('httpHeaders', function streamHeaders(statusCode, headers, resp) {&#13;
        if (statusCode &lt; 300) {&#13;
          req.removeListener('httpData', AWS.EventListeners.Core.HTTP_DATA);&#13;
          req.removeListener('httpError', AWS.EventListeners.Core.HTTP_ERROR);&#13;
          req.on('httpError', function streamHttpError(error) {&#13;
            resp.error = error;&#13;
            resp.error.retryable = false;&#13;
          });&#13;
  &#13;
          var shouldCheckContentLength = false;&#13;
          var expectedLen;&#13;
          if (req.httpRequest.method !== 'HEAD') {&#13;
            expectedLen = parseInt(headers['content-length'], 10);&#13;
          }&#13;
          if (expectedLen !== undefined &amp;&amp; !isNaN(expectedLen) &amp;&amp; expectedLen &gt;= 0) {&#13;
            shouldCheckContentLength = true;&#13;
            var receivedLen = 0;&#13;
          }&#13;
  &#13;
          var checkContentLengthAndEmit = function checkContentLengthAndEmit() {&#13;
            if (shouldCheckContentLength &amp;&amp; receivedLen !== expectedLen) {&#13;
              stream.emit('error', AWS.util.error(&#13;
                new Error('Stream content length mismatch. Received ' +&#13;
                  receivedLen + ' of ' + expectedLen + ' bytes.'),&#13;
                { code: 'StreamContentLengthMismatch' }&#13;
              ));&#13;
            } else if (AWS.HttpClient.streamsApiVersion === 2) {&#13;
              stream.end();&#13;
            } else {&#13;
              stream.emit('end')&#13;
            }&#13;
          }&#13;
  &#13;
          var httpStream = resp.httpResponse.createUnbufferedStream();&#13;
  &#13;
          if (AWS.HttpClient.streamsApiVersion === 2) {&#13;
            if (shouldCheckContentLength) {&#13;
              var lengthAccumulator = new streams.PassThrough();&#13;
              lengthAccumulator._write = function(chunk) {&#13;
                if (chunk &amp;&amp; chunk.length) {&#13;
                  receivedLen += chunk.length;&#13;
                }&#13;
                return streams.PassThrough.prototype._write.apply(this, arguments);&#13;
              };&#13;
  &#13;
              lengthAccumulator.on('end', checkContentLengthAndEmit);&#13;
              httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });&#13;
            } else {&#13;
              httpStream.pipe(stream);&#13;
            }&#13;
          } else {&#13;
  &#13;
            if (shouldCheckContentLength) {&#13;
              httpStream.on('data', function(arg) {&#13;
                if (arg &amp;&amp; arg.length) {&#13;
                  receivedLen += arg.length;&#13;
                }&#13;
              });&#13;
            }&#13;
  &#13;
            httpStream.on('data', function(arg) {&#13;
              stream.emit('data', arg);&#13;
            });&#13;
            httpStream.on('end', checkContentLengthAndEmit);&#13;
          }&#13;
  &#13;
          httpStream.on('error', function(err) {&#13;
            shouldCheckContentLength = false;&#13;
            stream.emit('error', err);&#13;
          });&#13;
        }&#13;
      });&#13;
  &#13;
      this.on('error', function(err) {&#13;
        stream.emit('error', err);&#13;
      });&#13;
  &#13;
      return stream;&#13;
    },&#13;
  &#13;
  &#13;
    emitEvent: function emit(eventName, args, done) {&#13;
      if (typeof args === 'function') { done = args; args = null; }&#13;
      if (!done) done = function() { };&#13;
      if (!args) args = this.eventParameters(eventName, this.response);&#13;
  &#13;
      var origEmit = AWS.SequentialExecutor.prototype.emit;&#13;
      origEmit.call(this, eventName, args, function (err) {&#13;
        if (err) this.response.error = err;&#13;
        done.call(this, err);&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
    eventParameters: function eventParameters(eventName) {&#13;
      switch (eventName) {&#13;
        case 'restart':&#13;
        case 'validate':&#13;
        case 'sign':&#13;
        case 'build':&#13;
        case 'afterValidate':&#13;
        case 'afterBuild':&#13;
          return [this];&#13;
        case 'error':&#13;
          return [this.response.error, this.response];&#13;
        default:&#13;
          return [this.response];&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    presign: function presign(expires, callback) {&#13;
      if (!callback &amp;&amp; typeof expires === 'function') {&#13;
        callback = expires;&#13;
        expires = null;&#13;
      }&#13;
      return new AWS.Signers.Presign().sign(this.toGet(), expires, callback);&#13;
    },&#13;
  &#13;
  &#13;
    isPresigned: function isPresigned() {&#13;
      return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, 'presigned-expires');&#13;
    },&#13;
  &#13;
  &#13;
    toUnauthenticated: function toUnauthenticated() {&#13;
      this.removeListener('validate', AWS.EventListeners.Core.VALIDATE_CREDENTIALS);&#13;
      this.removeListener('sign', AWS.EventListeners.Core.SIGN);&#13;
      return this;&#13;
    },&#13;
  &#13;
  &#13;
    toGet: function toGet() {&#13;
      if (this.service.api.protocol === 'query' ||&#13;
          this.service.api.protocol === 'ec2') {&#13;
        this.removeListener('build', this.buildAsGet);&#13;
        this.addListener('build', this.buildAsGet);&#13;
      }&#13;
      return this;&#13;
    },&#13;
  &#13;
  &#13;
    buildAsGet: function buildAsGet(request) {&#13;
      request.httpRequest.method = 'GET';&#13;
      request.httpRequest.path = request.service.endpoint.path +&#13;
                                 '?' + request.httpRequest.body;&#13;
      request.httpRequest.body = '';&#13;
  &#13;
      delete request.httpRequest.headers['Content-Length'];&#13;
      delete request.httpRequest.headers['Content-Type'];&#13;
    },&#13;
  &#13;
  &#13;
    haltHandlersOnError: function haltHandlersOnError() {&#13;
      this._haltHandlersOnError = true;&#13;
    }&#13;
  });&#13;
  &#13;
  &#13;
  AWS.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {&#13;
    this.prototype.promise = function promise() {&#13;
      var self = this;&#13;
      return new PromiseDependency(function(resolve, reject) {&#13;
        self.on('complete', function(resp) {&#13;
          if (resp.error) {&#13;
            reject(resp.error);&#13;
          } else {&#13;
            resolve(resp.data);&#13;
          }&#13;
        });&#13;
        self.runTo();&#13;
      });&#13;
    };&#13;
  };&#13;
  &#13;
  &#13;
  AWS.Request.deletePromisesFromClass = function deletePromisesFromClass() {&#13;
    delete this.prototype.promise;&#13;
  };&#13;
  &#13;
  AWS.util.addPromises(AWS.Request);&#13;
  &#13;
  AWS.util.mixin(AWS.Request, AWS.SequentialExecutor);&#13;
  &#13;
  }).call(this,require('_process'))&#13;
  },{"./core":10,"./state_machine":51,"_process":117,"jmespath":68}],38:[function(require,module,exports){&#13;
  &#13;
  &#13;
  var AWS = require('./core');&#13;
  var inherit = AWS.util.inherit;&#13;
  var jmespath = require('jmespath');&#13;
  &#13;
  &#13;
  function CHECK_ACCEPTORS(resp) {&#13;
    var waiter = resp.request._waiter;&#13;
    var acceptors = waiter.config.acceptors;&#13;
    var acceptorMatched = false;&#13;
    var state = 'retry';&#13;
  &#13;
    acceptors.forEach(function(acceptor) {&#13;
      if (!acceptorMatched) {&#13;
        var matcher = waiter.matchers[acceptor.matcher];&#13;
        if (matcher &amp;&amp; matcher(resp, acceptor.expected, acceptor.argument)) {&#13;
          acceptorMatched = true;&#13;
          state = acceptor.state;&#13;
        }&#13;
      }&#13;
    });&#13;
  &#13;
    if (!acceptorMatched &amp;&amp; resp.error) state = 'failure';&#13;
  &#13;
    if (state === 'success') {&#13;
      waiter.setSuccess(resp);&#13;
    } else {&#13;
      waiter.setError(resp, state === 'retry');&#13;
    }&#13;
  }&#13;
  &#13;
  &#13;
  AWS.ResourceWaiter = inherit({&#13;
  &#13;
    constructor: function constructor(service, state) {&#13;
      this.service = service;&#13;
      this.state = state;&#13;
      this.loadWaiterConfig(this.state);&#13;
    },&#13;
  &#13;
    service: null,&#13;
  &#13;
    state: null,&#13;
  &#13;
    config: null,&#13;
  &#13;
    matchers: {&#13;
      path: function(resp, expected, argument) {&#13;
        var result = jmespath.search(resp.data, argument);&#13;
        return jmespath.strictDeepEqual(result,expected);&#13;
      },&#13;
  &#13;
      pathAll: function(resp, expected, argument) {&#13;
        var results = jmespath.search(resp.data, argument);&#13;
        if (!Array.isArray(results)) results = [results];&#13;
        var numResults = results.length;&#13;
        if (!numResults) return false;&#13;
        for (var ind = 0 ; ind &lt; numResults; ind++) {&#13;
          if (!jmespath.strictDeepEqual(results[ind], expected)) {&#13;
            return false;&#13;
          }&#13;
        }&#13;
        return true;&#13;
      },&#13;
  &#13;
      pathAny: function(resp, expected, argument) {&#13;
        var results = jmespath.search(resp.data, argument);&#13;
        if (!Array.isArray(results)) results = [results];&#13;
        var numResults = results.length;&#13;
        for (var ind = 0 ; ind &lt; numResults; ind++) {&#13;
          if (jmespath.strictDeepEqual(results[ind], expected)) {&#13;
            return true;&#13;
          }&#13;
        }&#13;
        return false;&#13;
      },&#13;
  &#13;
      status: function(resp, expected) {&#13;
        var statusCode = resp.httpResponse.statusCode;&#13;
        return (typeof statusCode === 'number') &amp;&amp; (statusCode === expected);&#13;
      },&#13;
  &#13;
      error: function(resp, expected) {&#13;
        if (typeof expected === 'string' &amp;&amp; resp.error) {&#13;
          return expected === resp.error.code;&#13;
        }&#13;
        return expected === !!resp.error;&#13;
      }&#13;
    },&#13;
  &#13;
    listeners: new AWS.SequentialExecutor().addNamedListeners(function(add) {&#13;
      add('RETRY_CHECK', 'retry', function(resp) {&#13;
        var waiter = resp.request._waiter;&#13;
        if (resp.error &amp;&amp; resp.error.code === 'ResourceNotReady') {&#13;
          resp.error.retryDelay = (waiter.config.delay || 0) * 1000;&#13;
        }&#13;
      });&#13;
  &#13;
      add('CHECK_OUTPUT', 'extractData', CHECK_ACCEPTORS);&#13;
  &#13;
      add('CHECK_ERROR', 'extractError', CHECK_ACCEPTORS);&#13;
    }),&#13;
  &#13;
  &#13;
    wait: function wait(params, callback) {&#13;
      if (typeof params === 'function') {&#13;
        callback = params; params = undefined;&#13;
      }&#13;
  &#13;
      var request = this.service.makeRequest(this.config.operation, params);&#13;
      request._waiter = this;&#13;
      request.response.maxRetries = this.config.maxAttempts;&#13;
      request.addListeners(this.listeners);&#13;
  &#13;
      if (callback) request.send(callback);&#13;
      return request;&#13;
    },&#13;
  &#13;
    setSuccess: function setSuccess(resp) {&#13;
      resp.error = null;&#13;
      resp.data = resp.data || {};&#13;
      resp.request.removeAllListeners('extractData');&#13;
    },&#13;
  &#13;
    setError: function setError(resp, retryable) {&#13;
      resp.data = null;&#13;
      resp.error = AWS.util.error(resp.error || new Error(), {&#13;
        code: 'ResourceNotReady',&#13;
        message: 'Resource is not in the state ' + this.state,&#13;
        retryable: retryable&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
    loadWaiterConfig: function loadWaiterConfig(state) {&#13;
      if (!this.service.api.waiters[state]) {&#13;
        throw new AWS.util.error(new Error(), {&#13;
          code: 'StateNotFoundError',&#13;
          message: 'State ' + state + ' not found.'&#13;
        });&#13;
      }&#13;
  &#13;
      this.config = this.service.api.waiters[state];&#13;
    }&#13;
  });&#13;
  &#13;
  },{"./core":10,"jmespath":68}],39:[function(require,module,exports){&#13;
  var AWS = require('./core');&#13;
  var inherit = AWS.util.inherit;&#13;
  var jmespath = require('jmespath');&#13;
  &#13;
  &#13;
  AWS.Response = inherit({&#13;
  &#13;
  &#13;
    constructor: function Response(request) {&#13;
      this.request = request;&#13;
      this.data = null;&#13;
      this.error = null;&#13;
      this.retryCount = 0;&#13;
      this.redirectCount = 0;&#13;
      this.httpResponse = new AWS.HttpResponse();&#13;
      if (request) {&#13;
        this.maxRetries = request.service.numRetries();&#13;
        this.maxRedirects = request.service.config.maxRedirects;&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    nextPage: function nextPage(callback) {&#13;
      var config;&#13;
      var service = this.request.service;&#13;
      var operation = this.request.operation;&#13;
      try {&#13;
        config = service.paginationConfig(operation, true);&#13;
      } catch (e) { this.error = e; }&#13;
  &#13;
      if (!this.hasNextPage()) {&#13;
        if (callback) callback(this.error, null);&#13;
        else if (this.error) throw this.error;&#13;
        return null;&#13;
      }&#13;
  &#13;
      var params = AWS.util.copy(this.request.params);&#13;
      if (!this.nextPageTokens) {&#13;
        return callback ? callback(null, null) : null;&#13;
      } else {&#13;
        var inputTokens = config.inputToken;&#13;
        if (typeof inputTokens === 'string') inputTokens = [inputTokens];&#13;
        for (var i = 0; i &lt; inputTokens.length; i++) {&#13;
          params[inputTokens[i]] = this.nextPageTokens[i];&#13;
        }&#13;
        return service.makeRequest(this.request.operation, params, callback);&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    hasNextPage: function hasNextPage() {&#13;
      this.cacheNextPageTokens();&#13;
      if (this.nextPageTokens) return true;&#13;
      if (this.nextPageTokens === undefined) return undefined;&#13;
      else return false;&#13;
    },&#13;
  &#13;
  &#13;
    cacheNextPageTokens: function cacheNextPageTokens() {&#13;
      if (Object.prototype.hasOwnProperty.call(this, 'nextPageTokens')) return this.nextPageTokens;&#13;
      this.nextPageTokens = undefined;&#13;
  &#13;
      var config = this.request.service.paginationConfig(this.request.operation);&#13;
      if (!config) return this.nextPageTokens;&#13;
  &#13;
      this.nextPageTokens = null;&#13;
      if (config.moreResults) {&#13;
        if (!jmespath.search(this.data, config.moreResults)) {&#13;
          return this.nextPageTokens;&#13;
        }&#13;
      }&#13;
  &#13;
      var exprs = config.outputToken;&#13;
      if (typeof exprs === 'string') exprs = [exprs];&#13;
      AWS.util.arrayEach.call(this, exprs, function (expr) {&#13;
        var output = jmespath.search(this.data, expr);&#13;
        if (output) {&#13;
          this.nextPageTokens = this.nextPageTokens || [];&#13;
          this.nextPageTokens.push(output);&#13;
        }&#13;
      });&#13;
  &#13;
      return this.nextPageTokens;&#13;
    }&#13;
  &#13;
  });&#13;
  &#13;
  },{"./core":10,"jmespath":68}],40:[function(require,module,exports){&#13;
  var AWS = require('./core');&#13;
  &#13;
  &#13;
  AWS.SequentialExecutor = AWS.util.inherit({&#13;
  &#13;
    constructor: function SequentialExecutor() {&#13;
      this._events = {};&#13;
    },&#13;
  &#13;
  &#13;
    listeners: function listeners(eventName) {&#13;
      return this._events[eventName] ? this._events[eventName].slice(0) : [];&#13;
    },&#13;
  &#13;
    on: function on(eventName, listener) {&#13;
      if (this._events[eventName]) {&#13;
        this._events[eventName].push(listener);&#13;
      } else {&#13;
        this._events[eventName] = [listener];&#13;
      }&#13;
      return this;&#13;
    },&#13;
  &#13;
  &#13;
    onAsync: function onAsync(eventName, listener) {&#13;
      listener._isAsync = true;&#13;
      return this.on(eventName, listener);&#13;
    },&#13;
  &#13;
    removeListener: function removeListener(eventName, listener) {&#13;
      var listeners = this._events[eventName];&#13;
      if (listeners) {&#13;
        var length = listeners.length;&#13;
        var position = -1;&#13;
        for (var i = 0; i &lt; length; ++i) {&#13;
          if (listeners[i] === listener) {&#13;
            position = i;&#13;
          }&#13;
        }&#13;
        if (position &gt; -1) {&#13;
          listeners.splice(position, 1);&#13;
        }&#13;
      }&#13;
      return this;&#13;
    },&#13;
  &#13;
    removeAllListeners: function removeAllListeners(eventName) {&#13;
      if (eventName) {&#13;
        delete this._events[eventName];&#13;
      } else {&#13;
        this._events = {};&#13;
      }&#13;
      return this;&#13;
    },&#13;
  &#13;
  &#13;
    emit: function emit(eventName, eventArgs, doneCallback) {&#13;
      if (!doneCallback) doneCallback = function() { };&#13;
      var listeners = this.listeners(eventName);&#13;
      var count = listeners.length;&#13;
      this.callListeners(listeners, eventArgs, doneCallback);&#13;
      return count &gt; 0;&#13;
    },&#13;
  &#13;
  &#13;
    callListeners: function callListeners(listeners, args, doneCallback, prevError) {&#13;
      var self = this;&#13;
      var error = prevError || null;&#13;
  &#13;
      function callNextListener(err) {&#13;
        if (err) {&#13;
          error = AWS.util.error(error || new Error(), err);&#13;
          if (self._haltHandlersOnError) {&#13;
            return doneCallback.call(self, error);&#13;
          }&#13;
        }&#13;
        self.callListeners(listeners, args, doneCallback, error);&#13;
      }&#13;
  &#13;
      while (listeners.length &gt; 0) {&#13;
        var listener = listeners.shift();&#13;
        if (listener._isAsync) { // asynchronous listener&#13;
          listener.apply(self, args.concat([callNextListener]));&#13;
          return; // stop here, callNextListener will continue&#13;
        } else { // synchronous listener&#13;
          try {&#13;
            listener.apply(self, args);&#13;
          } catch (err) {&#13;
            error = AWS.util.error(error || new Error(), err);&#13;
          }&#13;
          if (error &amp;&amp; self._haltHandlersOnError) {&#13;
            doneCallback.call(self, error);&#13;
            return;&#13;
          }&#13;
        }&#13;
      }&#13;
      doneCallback.call(self, error);&#13;
    },&#13;
  &#13;
  &#13;
    addListeners: function addListeners(listeners) {&#13;
      var self = this;&#13;
  &#13;
      if (listeners._events) listeners = listeners._events;&#13;
  &#13;
      AWS.util.each(listeners, function(event, callbacks) {&#13;
        if (typeof callbacks === 'function') callbacks = [callbacks];&#13;
        AWS.util.arrayEach(callbacks, function(callback) {&#13;
          self.on(event, callback);&#13;
        });&#13;
      });&#13;
  &#13;
      return self;&#13;
    },&#13;
  &#13;
  &#13;
    addNamedListener: function addNamedListener(name, eventName, callback) {&#13;
      this[name] = callback;&#13;
      this.addListener(eventName, callback);&#13;
      return this;&#13;
    },&#13;
  &#13;
  &#13;
    addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback) {&#13;
      callback._isAsync = true;&#13;
      return this.addNamedListener(name, eventName, callback);&#13;
    },&#13;
  &#13;
  &#13;
    addNamedListeners: function addNamedListeners(callback) {&#13;
      var self = this;&#13;
      callback(&#13;
        function() {&#13;
          self.addNamedListener.apply(self, arguments);&#13;
        },&#13;
        function() {&#13;
          self.addNamedAsyncListener.apply(self, arguments);&#13;
        }&#13;
      );&#13;
      return this;&#13;
    }&#13;
  });&#13;
  &#13;
  &#13;
  AWS.SequentialExecutor.prototype.addListener = AWS.SequentialExecutor.prototype.on;&#13;
  &#13;
  module.exports = AWS.SequentialExecutor;&#13;
  &#13;
  },{"./core":10}],41:[function(require,module,exports){&#13;
  var AWS = require('./core');&#13;
  var Api = require('./model/api');&#13;
  var regionConfig = require('./region_config');&#13;
  var inherit = AWS.util.inherit;&#13;
  var clientCount = 0;&#13;
  &#13;
  &#13;
  AWS.Service = inherit({&#13;
  &#13;
    constructor: function Service(config) {&#13;
      if (!this.loadServiceClass) {&#13;
        throw AWS.util.error(new Error(),&#13;
          'Service must be constructed with `new\' operator');&#13;
      }&#13;
      var ServiceClass = this.loadServiceClass(config || {});&#13;
      if (ServiceClass) {&#13;
        var originalConfig = AWS.util.copy(config);&#13;
        var svc = new ServiceClass(config);&#13;
        Object.defineProperty(svc, '_originalConfig', {&#13;
          get: function() { return originalConfig; },&#13;
          enumerable: false,&#13;
          configurable: true&#13;
        });&#13;
        svc._clientId = ++clientCount;&#13;
        return svc;&#13;
      }&#13;
      this.initialize(config);&#13;
    },&#13;
  &#13;
  &#13;
    initialize: function initialize(config) {&#13;
      var svcConfig = AWS.config[this.serviceIdentifier];&#13;
  &#13;
      this.config = new AWS.Config(AWS.config);&#13;
      if (svcConfig) this.config.update(svcConfig, true);&#13;
      if (config) this.config.update(config, true);&#13;
  &#13;
      this.validateService();&#13;
      if (!this.config.endpoint) regionConfig(this);&#13;
  &#13;
      this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);&#13;
      this.setEndpoint(this.config.endpoint);&#13;
    },&#13;
  &#13;
  &#13;
    validateService: function validateService() {&#13;
    },&#13;
  &#13;
  &#13;
    loadServiceClass: function loadServiceClass(serviceConfig) {&#13;
      var config = serviceConfig;&#13;
      if (!AWS.util.isEmpty(this.api)) {&#13;
        return null;&#13;
      } else if (config.apiConfig) {&#13;
        return AWS.Service.defineServiceApi(this.constructor, config.apiConfig);&#13;
      } else if (!this.constructor.services) {&#13;
        return null;&#13;
      } else {&#13;
        config = new AWS.Config(AWS.config);&#13;
        config.update(serviceConfig, true);&#13;
        var version = config.apiVersions[this.constructor.serviceIdentifier];&#13;
        version = version || config.apiVersion;&#13;
        return this.getLatestServiceClass(version);&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    getLatestServiceClass: function getLatestServiceClass(version) {&#13;
      version = this.getLatestServiceVersion(version);&#13;
      if (this.constructor.services[version] === null) {&#13;
        AWS.Service.defineServiceApi(this.constructor, version);&#13;
      }&#13;
  &#13;
      return this.constructor.services[version];&#13;
    },&#13;
  &#13;
  &#13;
    getLatestServiceVersion: function getLatestServiceVersion(version) {&#13;
      if (!this.constructor.services || this.constructor.services.length === 0) {&#13;
        throw new Error('No services defined on ' +&#13;
                        this.constructor.serviceIdentifier);&#13;
      }&#13;
  &#13;
      if (!version) {&#13;
        version = 'latest';&#13;
      } else if (AWS.util.isType(version, Date)) {&#13;
        version = AWS.util.date.iso8601(version).split('T')[0];&#13;
      }&#13;
  &#13;
      if (Object.hasOwnProperty(this.constructor.services, version)) {&#13;
        return version;&#13;
      }&#13;
  &#13;
      var keys = Object.keys(this.constructor.services).sort();&#13;
      var selectedVersion = null;&#13;
      for (var i = keys.length - 1; i &gt;= 0; i--) {&#13;
        if (keys[i][keys[i].length - 1] !== '*') {&#13;
          selectedVersion = keys[i];&#13;
        }&#13;
        if (keys[i].substr(0, 10) &lt;= version) {&#13;
          return selectedVersion;&#13;
        }&#13;
      }&#13;
  &#13;
      throw new Error('Could not find ' + this.constructor.serviceIdentifier +&#13;
                      ' API to satisfy version constraint `' + version + '\'');&#13;
    },&#13;
  &#13;
  &#13;
    api: {},&#13;
  &#13;
  &#13;
    defaultRetryCount: 3,&#13;
  &#13;
  &#13;
    makeRequest: function makeRequest(operation, params, callback) {&#13;
      if (typeof params === 'function') {&#13;
        callback = params;&#13;
        params = null;&#13;
      }&#13;
  &#13;
      params = params || {};&#13;
      if (this.config.params) { // copy only toplevel bound params&#13;
        var rules = this.api.operations[operation];&#13;
        if (rules) {&#13;
          params = AWS.util.copy(params);&#13;
          AWS.util.each(this.config.params, function(key, value) {&#13;
            if (rules.input.members[key]) {&#13;
              if (params[key] === undefined || params[key] === null) {&#13;
                params[key] = value;&#13;
              }&#13;
            }&#13;
          });&#13;
        }&#13;
      }&#13;
  &#13;
      var request = new AWS.Request(this, operation, params);&#13;
      this.addAllRequestListeners(request);&#13;
  &#13;
      if (callback) request.send(callback);&#13;
      return request;&#13;
    },&#13;
  &#13;
  &#13;
    makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {&#13;
      if (typeof params === 'function') {&#13;
        callback = params;&#13;
        params = {};&#13;
      }&#13;
  &#13;
      var request = this.makeRequest(operation, params).toUnauthenticated();&#13;
      return callback ? request.send(callback) : request;&#13;
    },&#13;
  &#13;
  &#13;
    waitFor: function waitFor(state, params, callback) {&#13;
      var waiter = new AWS.ResourceWaiter(this, state);&#13;
      return waiter.wait(params, callback);&#13;
    },&#13;
  &#13;
  &#13;
    addAllRequestListeners: function addAllRequestListeners(request) {&#13;
      var list = [AWS.events, AWS.EventListeners.Core, this.serviceInterface(),&#13;
                  AWS.EventListeners.CorePost];&#13;
      for (var i = 0; i &lt; list.length; i++) {&#13;
        if (list[i]) request.addListeners(list[i]);&#13;
      }&#13;
  &#13;
      if (!this.config.paramValidation) {&#13;
        request.removeListener('validate',&#13;
          AWS.EventListeners.Core.VALIDATE_PARAMETERS);&#13;
      }&#13;
  &#13;
      if (this.config.logger) { // add logging events&#13;
        request.addListeners(AWS.EventListeners.Logger);&#13;
      }&#13;
  &#13;
      this.setupRequestListeners(request);&#13;
    },&#13;
  &#13;
  &#13;
    setupRequestListeners: function setupRequestListeners() {&#13;
    },&#13;
  &#13;
  &#13;
    getSignerClass: function getSignerClass() {&#13;
      var version;&#13;
      if (this.config.signatureVersion) {&#13;
        version = this.config.signatureVersion;&#13;
      } else {&#13;
        version = this.api.signatureVersion;&#13;
      }&#13;
      return AWS.Signers.RequestSigner.getVersion(version);&#13;
    },&#13;
  &#13;
  &#13;
    serviceInterface: function serviceInterface() {&#13;
      switch (this.api.protocol) {&#13;
        case 'ec2': return AWS.EventListeners.Query;&#13;
        case 'query': return AWS.EventListeners.Query;&#13;
        case 'json': return AWS.EventListeners.Json;&#13;
        case 'rest-json': return AWS.EventListeners.RestJson;&#13;
        case 'rest-xml': return AWS.EventListeners.RestXml;&#13;
      }&#13;
      if (this.api.protocol) {&#13;
        throw new Error('Invalid service `protocol\' ' +&#13;
          this.api.protocol + ' in API config');&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    successfulResponse: function successfulResponse(resp) {&#13;
      return resp.httpResponse.statusCode &lt; 300;&#13;
    },&#13;
  &#13;
  &#13;
    numRetries: function numRetries() {&#13;
      if (this.config.maxRetries !== undefined) {&#13;
        return this.config.maxRetries;&#13;
      } else {&#13;
        return this.defaultRetryCount;&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    retryDelays: function retryDelays(retryCount) {&#13;
      return AWS.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions);&#13;
    },&#13;
  &#13;
  &#13;
    retryableError: function retryableError(error) {&#13;
      if (this.networkingError(error)) return true;&#13;
      if (this.expiredCredentialsError(error)) return true;&#13;
      if (this.throttledError(error)) return true;&#13;
      if (error.statusCode &gt;= 500) return true;&#13;
      return false;&#13;
    },&#13;
  &#13;
  &#13;
    networkingError: function networkingError(error) {&#13;
      return error.code === 'NetworkingError';&#13;
    },&#13;
  &#13;
  &#13;
    expiredCredentialsError: function expiredCredentialsError(error) {&#13;
      return (error.code === 'ExpiredTokenException');&#13;
    },&#13;
  &#13;
  &#13;
    clockSkewError: function clockSkewError(error) {&#13;
      switch (error.code) {&#13;
        case 'RequestTimeTooSkewed':&#13;
        case 'RequestExpired':&#13;
        case 'InvalidSignatureException':&#13;
        case 'SignatureDoesNotMatch':&#13;
        case 'AuthFailure':&#13;
        case 'RequestInTheFuture':&#13;
          return true;&#13;
        default: return false;&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    throttledError: function throttledError(error) {&#13;
      switch (error.code) {&#13;
        case 'ProvisionedThroughputExceededException':&#13;
        case 'Throttling':&#13;
        case 'ThrottlingException':&#13;
        case 'RequestLimitExceeded':&#13;
        case 'RequestThrottled':&#13;
          return true;&#13;
        default:&#13;
          return false;&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    endpointFromTemplate: function endpointFromTemplate(endpoint) {&#13;
      if (typeof endpoint !== 'string') return endpoint;&#13;
  &#13;
      var e = endpoint;&#13;
      e = e.replace(/\{service\}/g, this.api.endpointPrefix);&#13;
      e = e.replace(/\{region\}/g, this.config.region);&#13;
      e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? 'https' : 'http');&#13;
      return e;&#13;
    },&#13;
  &#13;
  &#13;
    setEndpoint: function setEndpoint(endpoint) {&#13;
      this.endpoint = new AWS.Endpoint(endpoint, this.config);&#13;
    },&#13;
  &#13;
  &#13;
    paginationConfig: function paginationConfig(operation, throwException) {&#13;
      var paginator = this.api.operations[operation].paginator;&#13;
      if (!paginator) {&#13;
        if (throwException) {&#13;
          var e = new Error();&#13;
          throw AWS.util.error(e, 'No pagination configuration for ' + operation);&#13;
        }&#13;
        return null;&#13;
      }&#13;
  &#13;
      return paginator;&#13;
    }&#13;
  });&#13;
  &#13;
  AWS.util.update(AWS.Service, {&#13;
  &#13;
  &#13;
    defineMethods: function defineMethods(svc) {&#13;
      AWS.util.each(svc.prototype.api.operations, function iterator(method) {&#13;
        if (svc.prototype[method]) return;&#13;
        var operation = svc.prototype.api.operations[method];&#13;
        if (operation.authtype === 'none') {&#13;
          svc.prototype[method] = function (params, callback) {&#13;
            return this.makeUnauthenticatedRequest(method, params, callback);&#13;
          };&#13;
        } else {&#13;
          svc.prototype[method] = function (params, callback) {&#13;
            return this.makeRequest(method, params, callback);&#13;
          };&#13;
        }&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
    defineService: function defineService(serviceIdentifier, versions, features) {&#13;
      AWS.Service._serviceMap[serviceIdentifier] = true;&#13;
      if (!Array.isArray(versions)) {&#13;
        features = versions;&#13;
        versions = [];&#13;
      }&#13;
  &#13;
      var svc = inherit(AWS.Service, features || {});&#13;
  &#13;
      if (typeof serviceIdentifier === 'string') {&#13;
        AWS.Service.addVersions(svc, versions);&#13;
  &#13;
        var identifier = svc.serviceIdentifier || serviceIdentifier;&#13;
        svc.serviceIdentifier = identifier;&#13;
      } else { // defineService called with an API&#13;
        svc.prototype.api = serviceIdentifier;&#13;
        AWS.Service.defineMethods(svc);&#13;
      }&#13;
  &#13;
      return svc;&#13;
    },&#13;
  &#13;
  &#13;
    addVersions: function addVersions(svc, versions) {&#13;
      if (!Array.isArray(versions)) versions = [versions];&#13;
  &#13;
      svc.services = svc.services || {};&#13;
      for (var i = 0; i &lt; versions.length; i++) {&#13;
        if (svc.services[versions[i]] === undefined) {&#13;
          svc.services[versions[i]] = null;&#13;
        }&#13;
      }&#13;
  &#13;
      svc.apiVersions = Object.keys(svc.services).sort();&#13;
    },&#13;
  &#13;
  &#13;
    defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {&#13;
      var svc = inherit(superclass, {&#13;
        serviceIdentifier: superclass.serviceIdentifier&#13;
      });&#13;
  &#13;
      function setApi(api) {&#13;
        if (api.isApi) {&#13;
          svc.prototype.api = api;&#13;
        } else {&#13;
          svc.prototype.api = new Api(api);&#13;
        }&#13;
      }&#13;
  &#13;
      if (typeof version === 'string') {&#13;
        if (apiConfig) {&#13;
          setApi(apiConfig);&#13;
        } else {&#13;
          try {&#13;
            setApi(AWS.apiLoader(superclass.serviceIdentifier, version));&#13;
          } catch (err) {&#13;
            throw AWS.util.error(err, {&#13;
              message: 'Could not find API configuration ' +&#13;
                superclass.serviceIdentifier + '-' + version&#13;
            });&#13;
          }&#13;
        }&#13;
        if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {&#13;
          superclass.apiVersions = superclass.apiVersions.concat(version).sort();&#13;
        }&#13;
        superclass.services[version] = svc;&#13;
      } else {&#13;
        setApi(version);&#13;
      }&#13;
  &#13;
      AWS.Service.defineMethods(svc);&#13;
      return svc;&#13;
    },&#13;
  &#13;
  &#13;
    hasService: function(identifier) {&#13;
      return Object.prototype.hasOwnProperty.call(AWS.Service._serviceMap, identifier);&#13;
    },&#13;
  &#13;
  &#13;
    _serviceMap: {}&#13;
  });&#13;
  &#13;
  module.exports = AWS.Service;&#13;
  },{"./core":10,"./model/api":22,"./region_config":36}],42:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  &#13;
  AWS.util.update(AWS.CognitoIdentity.prototype, {&#13;
    getOpenIdToken: function getOpenIdToken(params, callback) {&#13;
      return this.makeUnauthenticatedRequest('getOpenIdToken', params, callback);&#13;
    },&#13;
  &#13;
    getId: function getId(params, callback) {&#13;
      return this.makeUnauthenticatedRequest('getId', params, callback);&#13;
    },&#13;
  &#13;
    getCredentialsForIdentity: function getCredentialsForIdentity(params, callback) {&#13;
      return this.makeUnauthenticatedRequest('getCredentialsForIdentity', params, callback);&#13;
    }&#13;
  });&#13;
  &#13;
  },{"../core":10}],43:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  &#13;
  AWS.util.update(AWS.STS.prototype, {&#13;
  &#13;
    credentialsFrom: function credentialsFrom(data, credentials) {&#13;
      if (!data) return null;&#13;
      if (!credentials) credentials = new AWS.TemporaryCredentials();&#13;
      credentials.expired = false;&#13;
      credentials.accessKeyId = data.Credentials.AccessKeyId;&#13;
      credentials.secretAccessKey = data.Credentials.SecretAccessKey;&#13;
      credentials.sessionToken = data.Credentials.SessionToken;&#13;
      credentials.expireTime = data.Credentials.Expiration;&#13;
      return credentials;&#13;
    },&#13;
  &#13;
    assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {&#13;
      return this.makeUnauthenticatedRequest('assumeRoleWithWebIdentity', params, callback);&#13;
    },&#13;
  &#13;
    assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {&#13;
      return this.makeUnauthenticatedRequest('assumeRoleWithSAML', params, callback);&#13;
    }&#13;
  });&#13;
  &#13;
  },{"../core":10}],44:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var inherit = AWS.util.inherit;&#13;
  &#13;
  &#13;
  var expiresHeader = 'presigned-expires';&#13;
  &#13;
  &#13;
  function signedUrlBuilder(request) {&#13;
    var expires = request.httpRequest.headers[expiresHeader];&#13;
    var signerClass = request.service.getSignerClass(request);&#13;
  &#13;
    delete request.httpRequest.headers['User-Agent'];&#13;
    delete request.httpRequest.headers['X-Amz-User-Agent'];&#13;
  &#13;
    if (signerClass === AWS.Signers.V4) {&#13;
      if (expires &gt; 604800) { // one week expiry is invalid&#13;
        var message = 'Presigning does not support expiry time greater ' +&#13;
                      'than a week with SigV4 signing.';&#13;
        throw AWS.util.error(new Error(), {&#13;
          code: 'InvalidExpiryTime', message: message, retryable: false&#13;
        });&#13;
      }&#13;
      request.httpRequest.headers[expiresHeader] = expires;&#13;
    } else if (signerClass === AWS.Signers.S3) {&#13;
      request.httpRequest.headers[expiresHeader] = parseInt(&#13;
        AWS.util.date.unixTimestamp() + expires, 10).toString();&#13;
    } else {&#13;
      throw AWS.util.error(new Error(), {&#13;
        message: 'Presigning only supports S3 or SigV4 signing.',&#13;
        code: 'UnsupportedSigner', retryable: false&#13;
      });&#13;
    }&#13;
  }&#13;
  &#13;
  &#13;
  function signedUrlSigner(request) {&#13;
    var endpoint = request.httpRequest.endpoint;&#13;
    var parsedUrl = AWS.util.urlParse(request.httpRequest.path);&#13;
    var queryParams = {};&#13;
  &#13;
    if (parsedUrl.search) {&#13;
      queryParams = AWS.util.queryStringParse(parsedUrl.search.substr(1));&#13;
    }&#13;
  &#13;
    AWS.util.each(request.httpRequest.headers, function (key, value) {&#13;
      if (key === expiresHeader) key = 'Expires';&#13;
      if (key.indexOf('x-amz-meta-') === 0) {&#13;
        delete queryParams[key];&#13;
        key = key.toLowerCase();&#13;
      }&#13;
      queryParams[key] = value;&#13;
    });&#13;
    delete request.httpRequest.headers[expiresHeader];&#13;
  &#13;
    var auth = queryParams['Authorization'].split(' ');&#13;
    if (auth[0] === 'AWS') {&#13;
      auth = auth[1].split(':');&#13;
      queryParams['AWSAccessKeyId'] = auth[0];&#13;
      queryParams['Signature'] = auth[1];&#13;
    } else if (auth[0] === 'AWS4-HMAC-SHA256') { // SigV4 signing&#13;
      auth.shift();&#13;
      var rest = auth.join(' ');&#13;
      var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];&#13;
      queryParams['X-Amz-Signature'] = signature;&#13;
      delete queryParams['Expires'];&#13;
    }&#13;
    delete queryParams['Authorization'];&#13;
    delete queryParams['Host'];&#13;
  &#13;
    endpoint.pathname = parsedUrl.pathname;&#13;
    endpoint.search = AWS.util.queryParamsToString(queryParams);&#13;
  }&#13;
  &#13;
  &#13;
  AWS.Signers.Presign = inherit({&#13;
  &#13;
    sign: function sign(request, expireTime, callback) {&#13;
      request.httpRequest.headers[expiresHeader] = expireTime || 3600;&#13;
      request.on('build', signedUrlBuilder);&#13;
      request.on('sign', signedUrlSigner);&#13;
      request.removeListener('afterBuild',&#13;
        AWS.EventListeners.Core.SET_CONTENT_LENGTH);&#13;
      request.removeListener('afterBuild',&#13;
        AWS.EventListeners.Core.COMPUTE_SHA256);&#13;
  &#13;
      request.emit('beforePresign', [request]);&#13;
  &#13;
      if (callback) {&#13;
        request.build(function() {&#13;
          if (this.response.error) callback(this.response.error);&#13;
          else {&#13;
            callback(null, AWS.util.urlFormat(request.httpRequest.endpoint));&#13;
          }&#13;
        });&#13;
      } else {&#13;
        request.build();&#13;
        if (request.response.error) throw request.response.error;&#13;
        return AWS.util.urlFormat(request.httpRequest.endpoint);&#13;
      }&#13;
    }&#13;
  });&#13;
  &#13;
  module.exports = AWS.Signers.Presign;&#13;
  &#13;
  },{"../core":10}],45:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var inherit = AWS.util.inherit;&#13;
  &#13;
  &#13;
  AWS.Signers.RequestSigner = inherit({&#13;
    constructor: function RequestSigner(request) {&#13;
      this.request = request;&#13;
    },&#13;
  &#13;
    setServiceClientId: function setServiceClientId(id) {&#13;
      this.serviceClientId = id;&#13;
    },&#13;
  &#13;
    getServiceClientId: function getServiceClientId() {&#13;
      return this.serviceClientId;&#13;
    }&#13;
  });&#13;
  &#13;
  AWS.Signers.RequestSigner.getVersion = function getVersion(version) {&#13;
    switch (version) {&#13;
      case 'v2': return AWS.Signers.V2;&#13;
      case 'v3': return AWS.Signers.V3;&#13;
      case 'v4': return AWS.Signers.V4;&#13;
      case 's3': return AWS.Signers.S3;&#13;
      case 'v3https': return AWS.Signers.V3Https;&#13;
    }&#13;
    throw new Error('Unknown signing version ' + version);&#13;
  };&#13;
  &#13;
  require('./v2');&#13;
  require('./v3');&#13;
  require('./v3https');&#13;
  require('./v4');&#13;
  require('./s3');&#13;
  require('./presign');&#13;
  &#13;
  },{"../core":10,"./presign":44,"./s3":46,"./v2":47,"./v3":48,"./v3https":49,"./v4":50}],46:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var inherit = AWS.util.inherit;&#13;
  &#13;
  &#13;
  AWS.Signers.S3 = inherit(AWS.Signers.RequestSigner, {&#13;
  &#13;
    subResources: {&#13;
      'acl': 1,&#13;
      'accelerate': 1,&#13;
      'cors': 1,&#13;
      'lifecycle': 1,&#13;
      'delete': 1,&#13;
      'location': 1,&#13;
      'logging': 1,&#13;
      'notification': 1,&#13;
      'partNumber': 1,&#13;
      'policy': 1,&#13;
      'requestPayment': 1,&#13;
      'replication': 1,&#13;
      'restore': 1,&#13;
      'tagging': 1,&#13;
      'torrent': 1,&#13;
      'uploadId': 1,&#13;
      'uploads': 1,&#13;
      'versionId': 1,&#13;
      'versioning': 1,&#13;
      'versions': 1,&#13;
      'website': 1&#13;
    },&#13;
  &#13;
    responseHeaders: {&#13;
      'response-content-type': 1,&#13;
      'response-content-language': 1,&#13;
      'response-expires': 1,&#13;
      'response-cache-control': 1,&#13;
      'response-content-disposition': 1,&#13;
      'response-content-encoding': 1&#13;
    },&#13;
  &#13;
    addAuthorization: function addAuthorization(credentials, date) {&#13;
      if (!this.request.headers['presigned-expires']) {&#13;
        this.request.headers['X-Amz-Date'] = AWS.util.date.rfc822(date);&#13;
      }&#13;
  &#13;
      if (credentials.sessionToken) {&#13;
        this.request.headers['x-amz-security-token'] = credentials.sessionToken;&#13;
      }&#13;
  &#13;
      var signature = this.sign(credentials.secretAccessKey, this.stringToSign());&#13;
      var auth = 'AWS ' + credentials.accessKeyId + ':' + signature;&#13;
  &#13;
      this.request.headers['Authorization'] = auth;&#13;
    },&#13;
  &#13;
    stringToSign: function stringToSign() {&#13;
      var r = this.request;&#13;
  &#13;
      var parts = [];&#13;
      parts.push(r.method);&#13;
      parts.push(r.headers['Content-MD5'] || '');&#13;
      parts.push(r.headers['Content-Type'] || '');&#13;
  &#13;
      parts.push(r.headers['presigned-expires'] || '');&#13;
  &#13;
      var headers = this.canonicalizedAmzHeaders();&#13;
      if (headers) parts.push(headers);&#13;
      parts.push(this.canonicalizedResource());&#13;
  &#13;
      return parts.join('\n');&#13;
  &#13;
    },&#13;
  &#13;
    canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {&#13;
  &#13;
      var amzHeaders = [];&#13;
  &#13;
      AWS.util.each(this.request.headers, function (name) {&#13;
        if (name.match(/^x-amz-/i))&#13;
          amzHeaders.push(name);&#13;
      });&#13;
  &#13;
      amzHeaders.sort(function (a, b) {&#13;
        return a.toLowerCase() &lt; b.toLowerCase() ? -1 : 1;&#13;
      });&#13;
  &#13;
      var parts = [];&#13;
      AWS.util.arrayEach.call(this, amzHeaders, function (name) {&#13;
        parts.push(name.toLowerCase() + ':' + String(this.request.headers[name]));&#13;
      });&#13;
  &#13;
      return parts.join('\n');&#13;
  &#13;
    },&#13;
  &#13;
    canonicalizedResource: function canonicalizedResource() {&#13;
  &#13;
      var r = this.request;&#13;
  &#13;
      var parts = r.path.split('?');&#13;
      var path = parts[0];&#13;
      var querystring = parts[1];&#13;
  &#13;
      var resource = '';&#13;
  &#13;
      if (r.virtualHostedBucket)&#13;
        resource += '/' + r.virtualHostedBucket;&#13;
  &#13;
      resource += path;&#13;
  &#13;
      if (querystring) {&#13;
  &#13;
        var resources = [];&#13;
  &#13;
        AWS.util.arrayEach.call(this, querystring.split('&amp;'), function (param) {&#13;
          var name = param.split('=')[0];&#13;
          var value = param.split('=')[1];&#13;
          if (this.subResources[name] || this.responseHeaders[name]) {&#13;
            var subresource = { name: name };&#13;
            if (value !== undefined) {&#13;
              if (this.subResources[name]) {&#13;
                subresource.value = value;&#13;
              } else {&#13;
                subresource.value = decodeURIComponent(value);&#13;
              }&#13;
            }&#13;
            resources.push(subresource);&#13;
          }&#13;
        });&#13;
  &#13;
        resources.sort(function (a, b) { return a.name &lt; b.name ? -1 : 1; });&#13;
  &#13;
        if (resources.length) {&#13;
  &#13;
          querystring = [];&#13;
          AWS.util.arrayEach(resources, function (res) {&#13;
            if (res.value === undefined) {&#13;
              querystring.push(res.name);&#13;
            } else {&#13;
              querystring.push(res.name + '=' + res.value);&#13;
            }&#13;
          });&#13;
  &#13;
          resource += '?' + querystring.join('&amp;');&#13;
        }&#13;
  &#13;
      }&#13;
  &#13;
      return resource;&#13;
  &#13;
    },&#13;
  &#13;
    sign: function sign(secret, string) {&#13;
      return AWS.util.crypto.hmac(secret, string, 'base64', 'sha1');&#13;
    }&#13;
  });&#13;
  &#13;
  module.exports = AWS.Signers.S3;&#13;
  &#13;
  },{"../core":10}],47:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var inherit = AWS.util.inherit;&#13;
  &#13;
  &#13;
  AWS.Signers.V2 = inherit(AWS.Signers.RequestSigner, {&#13;
    addAuthorization: function addAuthorization(credentials, date) {&#13;
  &#13;
      if (!date) date = AWS.util.date.getDate();&#13;
  &#13;
      var r = this.request;&#13;
  &#13;
      r.params.Timestamp = AWS.util.date.iso8601(date);&#13;
      r.params.SignatureVersion = '2';&#13;
      r.params.SignatureMethod = 'HmacSHA256';&#13;
      r.params.AWSAccessKeyId = credentials.accessKeyId;&#13;
  &#13;
      if (credentials.sessionToken) {&#13;
        r.params.SecurityToken = credentials.sessionToken;&#13;
      }&#13;
  &#13;
      delete r.params.Signature; // delete old Signature for re-signing&#13;
      r.params.Signature = this.signature(credentials);&#13;
  &#13;
      r.body = AWS.util.queryParamsToString(r.params);&#13;
      r.headers['Content-Length'] = r.body.length;&#13;
    },&#13;
  &#13;
    signature: function signature(credentials) {&#13;
      return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');&#13;
    },&#13;
  &#13;
    stringToSign: function stringToSign() {&#13;
      var parts = [];&#13;
      parts.push(this.request.method);&#13;
      parts.push(this.request.endpoint.host.toLowerCase());&#13;
      parts.push(this.request.pathname());&#13;
      parts.push(AWS.util.queryParamsToString(this.request.params));&#13;
      return parts.join('\n');&#13;
    }&#13;
  &#13;
  });&#13;
  &#13;
  module.exports = AWS.Signers.V2;&#13;
  &#13;
  },{"../core":10}],48:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var inherit = AWS.util.inherit;&#13;
  &#13;
  &#13;
  AWS.Signers.V3 = inherit(AWS.Signers.RequestSigner, {&#13;
    addAuthorization: function addAuthorization(credentials, date) {&#13;
  &#13;
      var datetime = AWS.util.date.rfc822(date);&#13;
  &#13;
      this.request.headers['X-Amz-Date'] = datetime;&#13;
  &#13;
      if (credentials.sessionToken) {&#13;
        this.request.headers['x-amz-security-token'] = credentials.sessionToken;&#13;
      }&#13;
  &#13;
      this.request.headers['X-Amzn-Authorization'] =&#13;
        this.authorization(credentials, datetime);&#13;
  &#13;
    },&#13;
  &#13;
    authorization: function authorization(credentials) {&#13;
      return 'AWS3 ' +&#13;
        'AWSAccessKeyId=' + credentials.accessKeyId + ',' +&#13;
        'Algorithm=HmacSHA256,' +&#13;
        'SignedHeaders=' + this.signedHeaders() + ',' +&#13;
        'Signature=' + this.signature(credentials);&#13;
    },&#13;
  &#13;
    signedHeaders: function signedHeaders() {&#13;
      var headers = [];&#13;
      AWS.util.arrayEach(this.headersToSign(), function iterator(h) {&#13;
        headers.push(h.toLowerCase());&#13;
      });&#13;
      return headers.sort().join(';');&#13;
    },&#13;
  &#13;
    canonicalHeaders: function canonicalHeaders() {&#13;
      var headers = this.request.headers;&#13;
      var parts = [];&#13;
      AWS.util.arrayEach(this.headersToSign(), function iterator(h) {&#13;
        parts.push(h.toLowerCase().trim() + ':' + String(headers[h]).trim());&#13;
      });&#13;
      return parts.sort().join('\n') + '\n';&#13;
    },&#13;
  &#13;
    headersToSign: function headersToSign() {&#13;
      var headers = [];&#13;
      AWS.util.each(this.request.headers, function iterator(k) {&#13;
        if (k === 'Host' || k === 'Content-Encoding' || k.match(/^X-Amz/i)) {&#13;
          headers.push(k);&#13;
        }&#13;
      });&#13;
      return headers;&#13;
    },&#13;
  &#13;
    signature: function signature(credentials) {&#13;
      return AWS.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), 'base64');&#13;
    },&#13;
  &#13;
    stringToSign: function stringToSign() {&#13;
      var parts = [];&#13;
      parts.push(this.request.method);&#13;
      parts.push('/');&#13;
      parts.push('');&#13;
      parts.push(this.canonicalHeaders());&#13;
      parts.push(this.request.body);&#13;
      return AWS.util.crypto.sha256(parts.join('\n'));&#13;
    }&#13;
  &#13;
  });&#13;
  &#13;
  module.exports = AWS.Signers.V3;&#13;
  &#13;
  },{"../core":10}],49:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var inherit = AWS.util.inherit;&#13;
  &#13;
  require('./v3');&#13;
  &#13;
  &#13;
  AWS.Signers.V3Https = inherit(AWS.Signers.V3, {&#13;
    authorization: function authorization(credentials) {&#13;
      return 'AWS3-HTTPS ' +&#13;
        'AWSAccessKeyId=' + credentials.accessKeyId + ',' +&#13;
        'Algorithm=HmacSHA256,' +&#13;
        'Signature=' + this.signature(credentials);&#13;
    },&#13;
  &#13;
    stringToSign: function stringToSign() {&#13;
      return this.request.headers['X-Amz-Date'];&#13;
    }&#13;
  });&#13;
  &#13;
  module.exports = AWS.Signers.V3Https;&#13;
  &#13;
  },{"../core":10,"./v3":48}],50:[function(require,module,exports){&#13;
  var AWS = require('../core');&#13;
  var inherit = AWS.util.inherit;&#13;
  &#13;
  &#13;
  var cachedSecret = {};&#13;
  &#13;
  &#13;
  var cacheQueue = [];&#13;
  &#13;
  &#13;
  var maxCacheEntries = 50;&#13;
  &#13;
  &#13;
  var expiresHeader = 'presigned-expires';&#13;
  &#13;
  &#13;
  AWS.Signers.V4 = inherit(AWS.Signers.RequestSigner, {&#13;
    constructor: function V4(request, serviceName, signatureCache) {&#13;
      AWS.Signers.RequestSigner.call(this, request);&#13;
      this.serviceName = serviceName;&#13;
      this.signatureCache = signatureCache;&#13;
    },&#13;
  &#13;
    algorithm: 'AWS4-HMAC-SHA256',&#13;
  &#13;
    addAuthorization: function addAuthorization(credentials, date) {&#13;
      var datetime = AWS.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, '');&#13;
  &#13;
      if (this.isPresigned()) {&#13;
        this.updateForPresigned(credentials, datetime);&#13;
      } else {&#13;
        this.addHeaders(credentials, datetime);&#13;
      }&#13;
  &#13;
      this.request.headers['Authorization'] =&#13;
        this.authorization(credentials, datetime);&#13;
    },&#13;
  &#13;
    addHeaders: function addHeaders(credentials, datetime) {&#13;
      this.request.headers['X-Amz-Date'] = datetime;&#13;
      if (credentials.sessionToken) {&#13;
        this.request.headers['x-amz-security-token'] = credentials.sessionToken;&#13;
      }&#13;
    },&#13;
  &#13;
    updateForPresigned: function updateForPresigned(credentials, datetime) {&#13;
      var credString = this.credentialString(datetime);&#13;
      var qs = {&#13;
        'X-Amz-Date': datetime,&#13;
        'X-Amz-Algorithm': this.algorithm,&#13;
        'X-Amz-Credential': credentials.accessKeyId + '/' + credString,&#13;
        'X-Amz-Expires': this.request.headers[expiresHeader],&#13;
        'X-Amz-SignedHeaders': this.signedHeaders()&#13;
      };&#13;
  &#13;
      if (credentials.sessionToken) {&#13;
        qs['X-Amz-Security-Token'] = credentials.sessionToken;&#13;
      }&#13;
  &#13;
      if (this.request.headers['Content-Type']) {&#13;
        qs['Content-Type'] = this.request.headers['Content-Type'];&#13;
      }&#13;
      if (this.request.headers['Content-MD5']) {&#13;
        qs['Content-MD5'] = this.request.headers['Content-MD5'];&#13;
      }&#13;
      if (this.request.headers['Cache-Control']) {&#13;
        qs['Cache-Control'] = this.request.headers['Cache-Control'];&#13;
      }&#13;
  &#13;
      AWS.util.each.call(this, this.request.headers, function(key, value) {&#13;
        if (key === expiresHeader) return;&#13;
        if (this.isSignableHeader(key)) {&#13;
          var lowerKey = key.toLowerCase();&#13;
          if (lowerKey.indexOf('x-amz-meta-') === 0) {&#13;
            qs[lowerKey] = value;&#13;
          } else if (lowerKey.indexOf('x-amz-') === 0) {&#13;
            qs[key] = value;&#13;
          }&#13;
        }&#13;
      });&#13;
  &#13;
      var sep = this.request.path.indexOf('?') &gt;= 0 ? '&amp;' : '?';&#13;
      this.request.path += sep + AWS.util.queryParamsToString(qs);&#13;
    },&#13;
  &#13;
    authorization: function authorization(credentials, datetime) {&#13;
      var parts = [];&#13;
      var credString = this.credentialString(datetime);&#13;
      parts.push(this.algorithm + ' Credential=' +&#13;
        credentials.accessKeyId + '/' + credString);&#13;
      parts.push('SignedHeaders=' + this.signedHeaders());&#13;
      parts.push('Signature=' + this.signature(credentials, datetime));&#13;
      return parts.join(', ');&#13;
    },&#13;
  &#13;
    signature: function signature(credentials, datetime) {&#13;
      var cache = null;&#13;
      var cacheIdentifier = this.serviceName + (this.getServiceClientId() ? '_' + this.getServiceClientId() : '');&#13;
      if (this.signatureCache) {&#13;
        var cache = cachedSecret[cacheIdentifier];&#13;
        if (!cache) {&#13;
          cacheQueue.push(cacheIdentifier);&#13;
          if (cacheQueue.length &gt; maxCacheEntries) {&#13;
            delete cachedSecret[cacheQueue.shift()];&#13;
          }&#13;
        }&#13;
  &#13;
      }&#13;
      var date = datetime.substr(0, 8);&#13;
  &#13;
      if (!cache ||&#13;
          cache.akid !== credentials.accessKeyId ||&#13;
          cache.region !== this.request.region ||&#13;
          cache.date !== date) {&#13;
  &#13;
        var kSecret = credentials.secretAccessKey;&#13;
        var kDate = AWS.util.crypto.hmac('AWS4' + kSecret, date, 'buffer');&#13;
        var kRegion = AWS.util.crypto.hmac(kDate, this.request.region, 'buffer');&#13;
        var kService = AWS.util.crypto.hmac(kRegion, this.serviceName, 'buffer');&#13;
        var kCredentials = AWS.util.crypto.hmac(kService, 'aws4_request', 'buffer');&#13;
  &#13;
        if (!this.signatureCache) {&#13;
          return AWS.util.crypto.hmac(kCredentials, this.stringToSign(datetime), 'hex');&#13;
        }&#13;
  &#13;
        cachedSecret[cacheIdentifier] = {&#13;
          region: this.request.region, date: date,&#13;
          key: kCredentials, akid: credentials.accessKeyId&#13;
        };&#13;
      }&#13;
  &#13;
      var key = cachedSecret[cacheIdentifier].key;&#13;
      return AWS.util.crypto.hmac(key, this.stringToSign(datetime), 'hex');&#13;
    },&#13;
  &#13;
    stringToSign: function stringToSign(datetime) {&#13;
      var parts = [];&#13;
      parts.push('AWS4-HMAC-SHA256');&#13;
      parts.push(datetime);&#13;
      parts.push(this.credentialString(datetime));&#13;
      parts.push(this.hexEncodedHash(this.canonicalString()));&#13;
      return parts.join('\n');&#13;
    },&#13;
  &#13;
    canonicalString: function canonicalString() {&#13;
      var parts = [], pathname = this.request.pathname();&#13;
      if (this.serviceName !== 's3') pathname = AWS.util.uriEscapePath(pathname);&#13;
  &#13;
      parts.push(this.request.method);&#13;
      parts.push(pathname);&#13;
      parts.push(this.request.search());&#13;
      parts.push(this.canonicalHeaders() + '\n');&#13;
      parts.push(this.signedHeaders());&#13;
      parts.push(this.hexEncodedBodyHash());&#13;
      return parts.join('\n');&#13;
    },&#13;
  &#13;
    canonicalHeaders: function canonicalHeaders() {&#13;
      var headers = [];&#13;
      AWS.util.each.call(this, this.request.headers, function (key, item) {&#13;
        headers.push([key, item]);&#13;
      });&#13;
      headers.sort(function (a, b) {&#13;
        return a[0].toLowerCase() &lt; b[0].toLowerCase() ? -1 : 1;&#13;
      });&#13;
      var parts = [];&#13;
      AWS.util.arrayEach.call(this, headers, function (item) {&#13;
        var key = item[0].toLowerCase();&#13;
        if (this.isSignableHeader(key)) {&#13;
          parts.push(key + ':' +&#13;
            this.canonicalHeaderValues(item[1].toString()));&#13;
        }&#13;
      });&#13;
      return parts.join('\n');&#13;
    },&#13;
  &#13;
    canonicalHeaderValues: function canonicalHeaderValues(values) {&#13;
      return values.replace(/\s+/g, ' ').replace(/^\s+|\s+$/g, '');&#13;
    },&#13;
  &#13;
    signedHeaders: function signedHeaders() {&#13;
      var keys = [];&#13;
      AWS.util.each.call(this, this.request.headers, function (key) {&#13;
        key = key.toLowerCase();&#13;
        if (this.isSignableHeader(key)) keys.push(key);&#13;
      });&#13;
      return keys.sort().join(';');&#13;
    },&#13;
  &#13;
    credentialString: function credentialString(datetime) {&#13;
      var parts = [];&#13;
      parts.push(datetime.substr(0, 8));&#13;
      parts.push(this.request.region);&#13;
      parts.push(this.serviceName);&#13;
      parts.push('aws4_request');&#13;
      return parts.join('/');&#13;
    },&#13;
  &#13;
    hexEncodedHash: function hash(string) {&#13;
      return AWS.util.crypto.sha256(string, 'hex');&#13;
    },&#13;
  &#13;
    hexEncodedBodyHash: function hexEncodedBodyHash() {&#13;
      if (this.isPresigned() &amp;&amp; this.serviceName === 's3' &amp;&amp; !this.request.body) {&#13;
        return 'UNSIGNED-PAYLOAD';&#13;
      } else if (this.request.headers['X-Amz-Content-Sha256']) {&#13;
        return this.request.headers['X-Amz-Content-Sha256'];&#13;
      } else {&#13;
        return this.hexEncodedHash(this.request.body || '');&#13;
      }&#13;
    },&#13;
  &#13;
    unsignableHeaders: ['authorization', 'content-type', 'content-length',&#13;
                        'user-agent', expiresHeader, 'expect'],&#13;
  &#13;
    isSignableHeader: function isSignableHeader(key) {&#13;
      if (key.toLowerCase().indexOf('x-amz-') === 0) return true;&#13;
      return this.unsignableHeaders.indexOf(key) &lt; 0;&#13;
    },&#13;
  &#13;
    isPresigned: function isPresigned() {&#13;
      return this.request.headers[expiresHeader] ? true : false;&#13;
    }&#13;
  &#13;
  });&#13;
  &#13;
  module.exports = AWS.Signers.V4;&#13;
  &#13;
  },{"../core":10}],51:[function(require,module,exports){&#13;
  function AcceptorStateMachine(states, state) {&#13;
    this.currentState = state || null;&#13;
    this.states = states || {};&#13;
  }&#13;
  &#13;
  AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {&#13;
    if (typeof finalState === 'function') {&#13;
      inputError = bindObject; bindObject = done;&#13;
      done = finalState; finalState = null;&#13;
    }&#13;
  &#13;
    var self = this;&#13;
    var state = self.states[self.currentState];&#13;
    state.fn.call(bindObject || self, inputError, function(err) {&#13;
      if (err) {&#13;
        if (state.fail) self.currentState = state.fail;&#13;
        else return done ? done.call(bindObject, err) : null;&#13;
      } else {&#13;
        if (state.accept) self.currentState = state.accept;&#13;
        else return done ? done.call(bindObject) : null;&#13;
      }&#13;
      if (self.currentState === finalState) {&#13;
        return done ? done.call(bindObject, err) : null;&#13;
      }&#13;
  &#13;
      self.runTo(finalState, done, bindObject, err);&#13;
    });&#13;
  };&#13;
  &#13;
  AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {&#13;
    if (typeof acceptState === 'function') {&#13;
      fn = acceptState; acceptState = null; failState = null;&#13;
    } else if (typeof failState === 'function') {&#13;
      fn = failState; failState = null;&#13;
    }&#13;
  &#13;
    if (!this.currentState) this.currentState = name;&#13;
    this.states[name] = { accept: acceptState, fail: failState, fn: fn };&#13;
    return this;&#13;
  };&#13;
  &#13;
  module.exports = AcceptorStateMachine;&#13;
  &#13;
  },{}],52:[function(require,module,exports){&#13;
  (function (process){&#13;
  &#13;
  var AWS;&#13;
  &#13;
  &#13;
  var util = {&#13;
    engine: function engine() {&#13;
      if (util.isBrowser() &amp;&amp; typeof navigator !== 'undefined') {&#13;
        return navigator.userAgent;&#13;
      } else {&#13;
        return process.platform + '/' + process.version;&#13;
      }&#13;
    },&#13;
  &#13;
    userAgent: function userAgent() {&#13;
      var name = util.isBrowser() ? 'js' : 'nodejs';&#13;
      var agent = 'aws-sdk-' + name + '/' + require('./core').VERSION;&#13;
      if (name === 'nodejs') agent += ' ' + util.engine();&#13;
      return agent;&#13;
    },&#13;
  &#13;
    isBrowser: function isBrowser() { return process &amp;&amp; process.browser; },&#13;
    isNode: function isNode() { return !util.isBrowser(); },&#13;
    uriEscape: function uriEscape(string) {&#13;
      var output = encodeURIComponent(string);&#13;
      output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);&#13;
  &#13;
      output = output.replace(/[*]/g, function(ch) {&#13;
        return '%' + ch.charCodeAt(0).toString(16).toUpperCase();&#13;
      });&#13;
  &#13;
      return output;&#13;
    },&#13;
  &#13;
    uriEscapePath: function uriEscapePath(string) {&#13;
      var parts = [];&#13;
      util.arrayEach(string.split('/'), function (part) {&#13;
        parts.push(util.uriEscape(part));&#13;
      });&#13;
      return parts.join('/');&#13;
    },&#13;
  &#13;
    urlParse: function urlParse(url) {&#13;
      return util.url.parse(url);&#13;
    },&#13;
  &#13;
    urlFormat: function urlFormat(url) {&#13;
      return util.url.format(url);&#13;
    },&#13;
  &#13;
    queryStringParse: function queryStringParse(qs) {&#13;
      return util.querystring.parse(qs);&#13;
    },&#13;
  &#13;
    queryParamsToString: function queryParamsToString(params) {&#13;
      var items = [];&#13;
      var escape = util.uriEscape;&#13;
      var sortedKeys = Object.keys(params).sort();&#13;
  &#13;
      util.arrayEach(sortedKeys, function(name) {&#13;
        var value = params[name];&#13;
        var ename = escape(name);&#13;
        var result = ename + '=';&#13;
        if (Array.isArray(value)) {&#13;
          var vals = [];&#13;
          util.arrayEach(value, function(item) { vals.push(escape(item)); });&#13;
          result = ename + '=' + vals.sort().join('&amp;' + ename + '=');&#13;
        } else if (value !== undefined &amp;&amp; value !== null) {&#13;
          result = ename + '=' + escape(value);&#13;
        }&#13;
        items.push(result);&#13;
      });&#13;
  &#13;
      return items.join('&amp;');&#13;
    },&#13;
  &#13;
    readFileSync: function readFileSync(path) {&#13;
      if (util.isBrowser()) return null;&#13;
      return require('fs').readFileSync(path, 'utf-8');&#13;
    },&#13;
  &#13;
    base64: {&#13;
  &#13;
      encode: function encode64(string) {&#13;
        return new util.Buffer(string).toString('base64');&#13;
      },&#13;
  &#13;
      decode: function decode64(string) {&#13;
        return new util.Buffer(string, 'base64');&#13;
      }&#13;
  &#13;
    },&#13;
  &#13;
    buffer: {&#13;
      toStream: function toStream(buffer) {&#13;
        if (!util.Buffer.isBuffer(buffer)) buffer = new util.Buffer(buffer);&#13;
  &#13;
        var readable = new (util.stream.Readable)();&#13;
        var pos = 0;&#13;
        readable._read = function(size) {&#13;
          if (pos &gt;= buffer.length) return readable.push(null);&#13;
  &#13;
          var end = pos + size;&#13;
          if (end &gt; buffer.length) end = buffer.length;&#13;
          readable.push(buffer.slice(pos, end));&#13;
          pos = end;&#13;
        };&#13;
  &#13;
        return readable;&#13;
      },&#13;
  &#13;
  &#13;
      concat: function(buffers) {&#13;
        var length = 0,&#13;
            offset = 0,&#13;
            buffer = null, i;&#13;
  &#13;
        for (i = 0; i &lt; buffers.length; i++) {&#13;
          length += buffers[i].length;&#13;
        }&#13;
  &#13;
        buffer = new util.Buffer(length);&#13;
  &#13;
        for (i = 0; i &lt; buffers.length; i++) {&#13;
          buffers[i].copy(buffer, offset);&#13;
          offset += buffers[i].length;&#13;
        }&#13;
  &#13;
        return buffer;&#13;
      }&#13;
    },&#13;
  &#13;
    string: {&#13;
      byteLength: function byteLength(string) {&#13;
        if (string === null || string === undefined) return 0;&#13;
        if (typeof string === 'string') string = new util.Buffer(string);&#13;
  &#13;
        if (typeof string.byteLength === 'number') {&#13;
          return string.byteLength;&#13;
        } else if (typeof string.length === 'number') {&#13;
          return string.length;&#13;
        } else if (typeof string.size === 'number') {&#13;
          return string.size;&#13;
        } else if (typeof string.path === 'string') {&#13;
          return require('fs').lstatSync(string.path).size;&#13;
        } else {&#13;
          throw util.error(new Error('Cannot determine length of ' + string),&#13;
            { object: string });&#13;
        }&#13;
      },&#13;
  &#13;
      upperFirst: function upperFirst(string) {&#13;
        return string[0].toUpperCase() + string.substr(1);&#13;
      },&#13;
  &#13;
      lowerFirst: function lowerFirst(string) {&#13;
        return string[0].toLowerCase() + string.substr(1);&#13;
      }&#13;
    },&#13;
  &#13;
    ini: {&#13;
      parse: function string(ini) {&#13;
        var currentSection, map = {};&#13;
        util.arrayEach(ini.split(/\r?\n/), function(line) {&#13;
          line = line.split(/(^|\s)[;#]/)[0]; // remove comments&#13;
          var section = line.match(/^\s*\[([^\[\]]+)\]\s*$/);&#13;
          if (section) {&#13;
            currentSection = section[1];&#13;
          } else if (currentSection) {&#13;
            var item = line.match(/^\s*(.+?)\s*=\s*(.+?)\s*$/);&#13;
            if (item) {&#13;
              map[currentSection] = map[currentSection] || {};&#13;
              map[currentSection][item[1]] = item[2];&#13;
            }&#13;
          }&#13;
        });&#13;
  &#13;
        return map;&#13;
      }&#13;
    },&#13;
  &#13;
    fn: {&#13;
      noop: function() {},&#13;
  &#13;
  &#13;
      makeAsync: function makeAsync(fn, expectedArgs) {&#13;
        if (expectedArgs &amp;&amp; expectedArgs &lt;= fn.length) {&#13;
          return fn;&#13;
        }&#13;
  &#13;
        return function() {&#13;
          var args = Array.prototype.slice.call(arguments, 0);&#13;
          var callback = args.pop();&#13;
          var result = fn.apply(null, args);&#13;
          callback(result);&#13;
        };&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    date: {&#13;
  &#13;
  &#13;
      getDate: function getDate() {&#13;
        if (!AWS) AWS = require('./core');&#13;
        if (AWS.config.systemClockOffset) { // use offset when non-zero&#13;
          return new Date(new Date().getTime() + AWS.config.systemClockOffset);&#13;
        } else {&#13;
          return new Date();&#13;
        }&#13;
      },&#13;
  &#13;
  &#13;
      iso8601: function iso8601(date) {&#13;
        if (date === undefined) { date = util.date.getDate(); }&#13;
        return date.toISOString().replace(/\.\d{3}Z$/, 'Z');&#13;
      },&#13;
  &#13;
  &#13;
      rfc822: function rfc822(date) {&#13;
        if (date === undefined) { date = util.date.getDate(); }&#13;
        return date.toUTCString();&#13;
      },&#13;
  &#13;
  &#13;
      unixTimestamp: function unixTimestamp(date) {&#13;
        if (date === undefined) { date = util.date.getDate(); }&#13;
        return date.getTime() / 1000;&#13;
      },&#13;
  &#13;
  &#13;
      from: function format(date) {&#13;
        if (typeof date === 'number') {&#13;
          return new Date(date * 1000); // unix timestamp&#13;
        } else {&#13;
          return new Date(date);&#13;
        }&#13;
      },&#13;
  &#13;
  &#13;
      format: function format(date, formatter) {&#13;
        if (!formatter) formatter = 'iso8601';&#13;
        return util.date[formatter](util.date.from(date));&#13;
      },&#13;
  &#13;
      parseTimestamp: function parseTimestamp(value) {&#13;
        if (typeof value === 'number') { // unix timestamp (number)&#13;
          return new Date(value * 1000);&#13;
        } else if (value.match(/^\d+$/)) { // unix timestamp&#13;
          return new Date(value * 1000);&#13;
        } else if (value.match(/^\d{4}/)) { // iso8601&#13;
          return new Date(value);&#13;
        } else if (value.match(/^\w{3},/)) { // rfc822&#13;
          return new Date(value);&#13;
        } else {&#13;
          throw util.error(&#13;
            new Error('unhandled timestamp format: ' + value),&#13;
            {code: 'TimestampParserError'});&#13;
        }&#13;
      }&#13;
  &#13;
    },&#13;
  &#13;
    crypto: {&#13;
      crc32Table: [&#13;
       0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419,&#13;
       0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4,&#13;
       0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07,&#13;
       0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,&#13;
       0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856,&#13;
       0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,&#13;
       0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4,&#13;
       0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,&#13;
       0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3,&#13;
       0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A,&#13;
       0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599,&#13;
       0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,&#13;
       0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190,&#13;
       0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F,&#13;
       0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E,&#13;
       0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,&#13;
       0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED,&#13;
       0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,&#13;
       0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3,&#13;
       0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,&#13;
       0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A,&#13;
       0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5,&#13;
       0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010,&#13;
       0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,&#13;
       0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17,&#13;
       0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6,&#13;
       0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615,&#13;
       0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,&#13;
       0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344,&#13;
       0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,&#13;
       0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A,&#13;
       0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,&#13;
       0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1,&#13;
       0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C,&#13;
       0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF,&#13;
       0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,&#13;
       0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE,&#13;
       0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31,&#13;
       0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C,&#13;
       0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,&#13;
       0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B,&#13;
       0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,&#13;
       0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1,&#13;
       0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,&#13;
       0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278,&#13;
       0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7,&#13;
       0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66,&#13;
       0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,&#13;
       0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605,&#13;
       0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8,&#13;
       0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B,&#13;
       0x2D02EF8D],&#13;
  &#13;
      crc32: function crc32(data) {&#13;
        var tbl = util.crypto.crc32Table;&#13;
        var crc = 0 ^ -1;&#13;
  &#13;
        if (typeof data === 'string') {&#13;
          data = new util.Buffer(data);&#13;
        }&#13;
  &#13;
        for (var i = 0; i &lt; data.length; i++) {&#13;
          var code = data.readUInt8(i);&#13;
          crc = (crc &gt;&gt;&gt; 8) ^ tbl[(crc ^ code) &amp; 0xFF];&#13;
        }&#13;
        return (crc ^ -1) &gt;&gt;&gt; 0;&#13;
      },&#13;
  &#13;
      hmac: function hmac(key, string, digest, fn) {&#13;
        if (!digest) digest = 'binary';&#13;
        if (digest === 'buffer') { digest = undefined; }&#13;
        if (!fn) fn = 'sha256';&#13;
        if (typeof string === 'string') string = new util.Buffer(string);&#13;
        return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);&#13;
      },&#13;
  &#13;
      md5: function md5(data, digest, callback) {&#13;
        return util.crypto.hash('md5', data, digest, callback);&#13;
      },&#13;
  &#13;
      sha256: function sha256(data, digest, callback) {&#13;
        return util.crypto.hash('sha256', data, digest, callback);&#13;
      },&#13;
  &#13;
      hash: function(algorithm, data, digest, callback) {&#13;
        var hash = util.crypto.createHash(algorithm);&#13;
        if (!digest) { digest = 'binary'; }&#13;
        if (digest === 'buffer') { digest = undefined; }&#13;
        if (typeof data === 'string') data = new util.Buffer(data);&#13;
        var sliceFn = util.arraySliceFn(data);&#13;
        var isBuffer = util.Buffer.isBuffer(data);&#13;
        if (util.isBrowser() &amp;&amp; typeof ArrayBuffer !== 'undefined' &amp;&amp; data &amp;&amp; data.buffer instanceof ArrayBuffer) isBuffer = true;&#13;
  &#13;
        if (callback &amp;&amp; typeof data === 'object' &amp;&amp;&#13;
            typeof data.on === 'function' &amp;&amp; !isBuffer) {&#13;
          data.on('data', function(chunk) { hash.update(chunk); });&#13;
          data.on('error', function(err) { callback(err); });&#13;
          data.on('end', function() { callback(null, hash.digest(digest)); });&#13;
        } else if (callback &amp;&amp; sliceFn &amp;&amp; !isBuffer &amp;&amp;&#13;
                   typeof FileReader !== 'undefined') {&#13;
          var index = 0, size = 1024 * 512;&#13;
          var reader = new FileReader();&#13;
          reader.onerror = function() {&#13;
            callback(new Error('Failed to read data.'));&#13;
          };&#13;
          reader.onload = function() {&#13;
            var buf = new util.Buffer(new Uint8Array(reader.result));&#13;
            hash.update(buf);&#13;
            index += buf.length;&#13;
            reader._continueReading();&#13;
          };&#13;
          reader._continueReading = function() {&#13;
            if (index &gt;= data.size) {&#13;
              callback(null, hash.digest(digest));&#13;
              return;&#13;
            }&#13;
  &#13;
            var back = index + size;&#13;
            if (back &gt; data.size) back = data.size;&#13;
            reader.readAsArrayBuffer(sliceFn.call(data, index, back));&#13;
          };&#13;
  &#13;
          reader._continueReading();&#13;
        } else {&#13;
          if (util.isBrowser() &amp;&amp; typeof data === 'object' &amp;&amp; !isBuffer) {&#13;
            data = new util.Buffer(new Uint8Array(data));&#13;
          }&#13;
          var out = hash.update(data).digest(digest);&#13;
          if (callback) callback(null, out);&#13;
          return out;&#13;
        }&#13;
      },&#13;
  &#13;
      toHex: function toHex(data) {&#13;
        var out = [];&#13;
        for (var i = 0; i &lt; data.length; i++) {&#13;
          out.push(('0' + data.charCodeAt(i).toString(16)).substr(-2, 2));&#13;
        }&#13;
        return out.join('');&#13;
      },&#13;
  &#13;
      createHash: function createHash(algorithm) {&#13;
        return util.crypto.lib.createHash(algorithm);&#13;
      }&#13;
  &#13;
    },&#13;
  &#13;
  &#13;
  &#13;
  &#13;
    abort: {},&#13;
  &#13;
    each: function each(object, iterFunction) {&#13;
      for (var key in object) {&#13;
        if (Object.prototype.hasOwnProperty.call(object, key)) {&#13;
          var ret = iterFunction.call(this, key, object[key]);&#13;
          if (ret === util.abort) break;&#13;
        }&#13;
      }&#13;
    },&#13;
  &#13;
    arrayEach: function arrayEach(array, iterFunction) {&#13;
      for (var idx in array) {&#13;
        if (Object.prototype.hasOwnProperty.call(array, idx)) {&#13;
          var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));&#13;
          if (ret === util.abort) break;&#13;
        }&#13;
      }&#13;
    },&#13;
  &#13;
    update: function update(obj1, obj2) {&#13;
      util.each(obj2, function iterator(key, item) {&#13;
        obj1[key] = item;&#13;
      });&#13;
      return obj1;&#13;
    },&#13;
  &#13;
    merge: function merge(obj1, obj2) {&#13;
      return util.update(util.copy(obj1), obj2);&#13;
    },&#13;
  &#13;
    copy: function copy(object) {&#13;
      if (object === null || object === undefined) return object;&#13;
      var dupe = {};&#13;
      for (var key in object) {&#13;
        dupe[key] = object[key];&#13;
      }&#13;
      return dupe;&#13;
    },&#13;
  &#13;
    isEmpty: function isEmpty(obj) {&#13;
      for (var prop in obj) {&#13;
        if (Object.prototype.hasOwnProperty.call(obj, prop)) {&#13;
          return false;&#13;
        }&#13;
      }&#13;
      return true;&#13;
    },&#13;
  &#13;
    arraySliceFn: function arraySliceFn(obj) {&#13;
      var fn = obj.slice || obj.webkitSlice || obj.mozSlice;&#13;
      return typeof fn === 'function' ? fn : null;&#13;
    },&#13;
  &#13;
    isType: function isType(obj, type) {&#13;
      if (typeof type === 'function') type = util.typeName(type);&#13;
      return Object.prototype.toString.call(obj) === '[object ' + type + ']';&#13;
    },&#13;
  &#13;
    typeName: function typeName(type) {&#13;
      if (Object.prototype.hasOwnProperty.call(type, 'name')) return type.name;&#13;
      var str = type.toString();&#13;
      var match = str.match(/^\s*function (.+)\(/);&#13;
      return match ? match[1] : str;&#13;
    },&#13;
  &#13;
    error: function error(err, options) {&#13;
      var originalError = null;&#13;
      if (typeof err.message === 'string' &amp;&amp; err.message !== '') {&#13;
        if (typeof options === 'string' || (options &amp;&amp; options.message)) {&#13;
          originalError = util.copy(err);&#13;
          originalError.message = err.message;&#13;
        }&#13;
      }&#13;
      err.message = err.message || null;&#13;
  &#13;
      if (typeof options === 'string') {&#13;
        err.message = options;&#13;
      } else if (typeof options === 'object' &amp;&amp; options !== null) {&#13;
        util.update(err, options);&#13;
        if (options.message)&#13;
          err.message = options.message;&#13;
        if (options.code || options.name)&#13;
          err.code = options.code || options.name;&#13;
        if (options.stack)&#13;
          err.stack = options.stack;&#13;
      }&#13;
  &#13;
      if (typeof Object.defineProperty === 'function') {&#13;
        Object.defineProperty(err, 'name', {writable: true, enumerable: false});&#13;
        Object.defineProperty(err, 'message', {enumerable: true});&#13;
      }&#13;
  &#13;
      err.name = options &amp;&amp; options.name || err.name || err.code || 'Error';&#13;
      err.time = new Date();&#13;
  &#13;
      if (originalError) err.originalError = originalError;&#13;
  &#13;
      return err;&#13;
    },&#13;
  &#13;
  &#13;
    inherit: function inherit(klass, features) {&#13;
      var newObject = null;&#13;
      if (features === undefined) {&#13;
        features = klass;&#13;
        klass = Object;&#13;
        newObject = {};&#13;
      } else {&#13;
        var ctor = function ConstructorWrapper() {};&#13;
        ctor.prototype = klass.prototype;&#13;
        newObject = new ctor();&#13;
      }&#13;
  &#13;
      if (features.constructor === Object) {&#13;
        features.constructor = function() {&#13;
          if (klass !== Object) {&#13;
            return klass.apply(this, arguments);&#13;
          }&#13;
        };&#13;
      }&#13;
  &#13;
      features.constructor.prototype = newObject;&#13;
      util.update(features.constructor.prototype, features);&#13;
      features.constructor.__super__ = klass;&#13;
      return features.constructor;&#13;
    },&#13;
  &#13;
  &#13;
    mixin: function mixin() {&#13;
      var klass = arguments[0];&#13;
      for (var i = 1; i &lt; arguments.length; i++) {&#13;
        for (var prop in arguments[i].prototype) {&#13;
          var fn = arguments[i].prototype[prop];&#13;
          if (prop !== 'constructor') {&#13;
            klass.prototype[prop] = fn;&#13;
          }&#13;
        }&#13;
      }&#13;
      return klass;&#13;
    },&#13;
  &#13;
  &#13;
    hideProperties: function hideProperties(obj, props) {&#13;
      if (typeof Object.defineProperty !== 'function') return;&#13;
  &#13;
      util.arrayEach(props, function (key) {&#13;
        Object.defineProperty(obj, key, {&#13;
          enumerable: false, writable: true, configurable: true });&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
    property: function property(obj, name, value, enumerable, isValue) {&#13;
      var opts = {&#13;
        configurable: true,&#13;
        enumerable: enumerable !== undefined ? enumerable : true&#13;
      };&#13;
      if (typeof value === 'function' &amp;&amp; !isValue) {&#13;
        opts.get = value;&#13;
      }&#13;
      else {&#13;
        opts.value = value; opts.writable = true;&#13;
      }&#13;
  &#13;
      Object.defineProperty(obj, name, opts);&#13;
    },&#13;
  &#13;
  &#13;
    memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {&#13;
      var cachedValue = null;&#13;
  &#13;
      util.property(obj, name, function() {&#13;
        if (cachedValue === null) {&#13;
          cachedValue = get();&#13;
        }&#13;
        return cachedValue;&#13;
      }, enumerable);&#13;
    },&#13;
  &#13;
  &#13;
    hoistPayloadMember: function hoistPayloadMember(resp) {&#13;
      var req = resp.request;&#13;
      var operation = req.operation;&#13;
      var output = req.service.api.operations[operation].output;&#13;
      if (output.payload) {&#13;
        var payloadMember = output.members[output.payload];&#13;
        var responsePayload = resp.data[output.payload];&#13;
        if (payloadMember.type === 'structure') {&#13;
          util.each(responsePayload, function(key, value) {&#13;
            util.property(resp.data, key, value, false);&#13;
          });&#13;
        }&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    computeSha256: function computeSha256(body, done) {&#13;
      if (util.isNode()) {&#13;
        var Stream = util.stream.Stream;&#13;
        var fs = require('fs');&#13;
        if (body instanceof Stream) {&#13;
          if (typeof body.path === 'string') { // assume file object&#13;
            var settings = {};&#13;
            if (typeof body.start === 'number') {&#13;
              settings.start = body.start;&#13;
            }&#13;
            if (typeof body.end === 'number') {&#13;
              settings.end = body.end;&#13;
            }&#13;
            body = fs.createReadStream(body.path, settings);&#13;
          } else { // TODO support other stream types&#13;
            return done(new Error('Non-file stream objects are ' +&#13;
                                  'not supported with SigV4'));&#13;
          }&#13;
        }&#13;
      }&#13;
  &#13;
      util.crypto.sha256(body, 'hex', function(err, sha) {&#13;
        if (err) done(err);&#13;
        else done(null, sha);&#13;
      });&#13;
    },&#13;
  &#13;
  &#13;
    isClockSkewed: function isClockSkewed(serverTime) {&#13;
      if (serverTime) {&#13;
        util.property(AWS.config, 'isClockSkewed',&#13;
          Math.abs(new Date().getTime() - serverTime) &gt;= 300000, false);&#13;
        return AWS.config.isClockSkewed;&#13;
      }&#13;
    },&#13;
  &#13;
    applyClockOffset: function applyClockOffset(serverTime) {&#13;
      if (serverTime)&#13;
        AWS.config.systemClockOffset = serverTime - new Date().getTime();&#13;
    },&#13;
  &#13;
  &#13;
    extractRequestId: function extractRequestId(resp) {&#13;
      var requestId = resp.httpResponse.headers['x-amz-request-id'] ||&#13;
                       resp.httpResponse.headers['x-amzn-requestid'];&#13;
  &#13;
      if (!requestId &amp;&amp; resp.data &amp;&amp; resp.data.ResponseMetadata) {&#13;
        requestId = resp.data.ResponseMetadata.RequestId;&#13;
      }&#13;
  &#13;
      if (requestId) {&#13;
        resp.requestId = requestId;&#13;
      }&#13;
  &#13;
      if (resp.error) {&#13;
        resp.error.requestId = requestId;&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    addPromises: function addPromises(constructors, PromiseDependency) {&#13;
      if (PromiseDependency === undefined &amp;&amp; AWS &amp;&amp; AWS.config) {&#13;
        PromiseDependency = AWS.config.getPromisesDependency();&#13;
      }&#13;
      if (PromiseDependency === undefined &amp;&amp; typeof Promise !== 'undefined') {&#13;
        PromiseDependency = Promise;&#13;
      }&#13;
      if (typeof PromiseDependency !== 'function') var deletePromises = true;&#13;
      if (!Array.isArray(constructors)) constructors = [constructors];&#13;
  &#13;
      for (var ind = 0; ind &lt; constructors.length; ind++) {&#13;
        var constructor = constructors[ind];&#13;
        if (deletePromises) {&#13;
          if (constructor.deletePromisesFromClass) {&#13;
            constructor.deletePromisesFromClass();&#13;
          }&#13;
        } else if (constructor.addPromisesToClass) {&#13;
          constructor.addPromisesToClass(PromiseDependency);&#13;
        }&#13;
      }&#13;
    },&#13;
  &#13;
  &#13;
    promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {&#13;
      return function promise() {&#13;
        var self = this;&#13;
        return new PromiseDependency(function(resolve, reject) {&#13;
          self[methodName](function(err, data) {&#13;
            if (err) {&#13;
              reject(err);&#13;
            } else {&#13;
              resolve(data);&#13;
            }&#13;
          });&#13;
        });&#13;
      };&#13;
    },&#13;
  &#13;
  &#13;
    isDualstackAvailable: function isDualstackAvailable(service) {&#13;
      if (!service) return false;&#13;
      var metadata = require('../apis/metadata.json');&#13;
      if (typeof service !== 'string') service = service.serviceIdentifier;&#13;
      if (typeof service !== 'string' || !metadata.hasOwnProperty(service)) return false;&#13;
      return !!metadata[service].dualstackAvailable;&#13;
    },&#13;
  &#13;
  &#13;
    calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions) {&#13;
      if (!retryDelayOptions) retryDelayOptions = {};&#13;
      var customBackoff = retryDelayOptions.customBackoff || null;&#13;
      if (typeof customBackoff === 'function') {&#13;
        return customBackoff(retryCount);&#13;
      }&#13;
      var base = retryDelayOptions.base || 100;&#13;
      var delay = Math.random() * (Math.pow(2, retryCount) * base);&#13;
      return delay;&#13;
    },&#13;
  &#13;
  &#13;
    handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {&#13;
      if (!options) options = {};&#13;
      var http = AWS.HttpClient.getInstance();&#13;
      var httpOptions = options.httpOptions || {};&#13;
      var retryCount = 0;&#13;
  &#13;
      var errCallback = function(err) {&#13;
        var maxRetries = options.maxRetries || 0;&#13;
        if (err &amp;&amp; err.code === 'TimeoutError') err.retryable = true;&#13;
        if (err &amp;&amp; err.retryable &amp;&amp; retryCount &lt; maxRetries) {&#13;
          retryCount++;&#13;
          var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions);&#13;
          setTimeout(sendRequest, delay + (err.retryAfter || 0));&#13;
        } else {&#13;
          cb(err);&#13;
        }&#13;
      };&#13;
  &#13;
      var sendRequest = function() {&#13;
        var data = '';&#13;
        http.handleRequest(httpRequest, httpOptions, function(httpResponse) {&#13;
          httpResponse.on('data', function(chunk) { data += chunk.toString(); });&#13;
          httpResponse.on('end', function() {&#13;
            var statusCode = httpResponse.statusCode;&#13;
            if (statusCode &lt; 300) {&#13;
              cb(null, data);&#13;
            } else {&#13;
              var retryAfter = parseInt(httpResponse.headers['retry-after'], 10) * 1000 || 0;&#13;
              var err = util.error(new Error(),&#13;
                { retryable: statusCode &gt;= 500 || statusCode === 429 }&#13;
              );&#13;
              if (retryAfter &amp;&amp; err.retryable) err.retryAfter = retryAfter;&#13;
              errCallback(err);&#13;
            }&#13;
          });&#13;
        }, errCallback);&#13;
      };&#13;
  &#13;
      process.nextTick(sendRequest);&#13;
    }&#13;
  &#13;
  };&#13;
  &#13;
  module.exports = util;&#13;
  &#13;
  }).call(this,require('_process'))&#13;
  },{"../apis/metadata.json":3,"./core":10,"_process":117,"fs":56}],53:[function(require,module,exports){&#13;
  var util = require('../util');&#13;
  var Shape = require('../model/shape');&#13;
  &#13;
  function DomXmlParser() { }&#13;
  &#13;
  DomXmlParser.prototype.parse = function(xml, shape) {&#13;
    if (xml.replace(/^\s+/, '') === '') return {};&#13;
  &#13;
    var result, error;&#13;
    try {&#13;
      if (window.DOMParser) {&#13;
        try {&#13;
          var parser = new DOMParser();&#13;
          result = parser.parseFromString(xml, 'text/xml');&#13;
        } catch (syntaxError) {&#13;
          throw util.error(new Error('Parse error in document'),&#13;
            {&#13;
              originalError: syntaxError,&#13;
              code: 'XMLParserError',&#13;
              retryable: true&#13;
            });&#13;
        }&#13;
  &#13;
        if (result.documentElement === null) {&#13;
          throw util.error(new Error('Cannot parse empty document.'),&#13;
            {&#13;
              code: 'XMLParserError',&#13;
              retryable: true&#13;
            });&#13;
        }&#13;
  &#13;
        var isError = result.getElementsByTagName('parsererror')[0];&#13;
        if (isError &amp;&amp; (isError.parentNode === result ||&#13;
            isError.parentNode.nodeName === 'body' ||&#13;
            isError.parentNode.parentNode === result ||&#13;
            isError.parentNode.parentNode.nodeName === 'body')) {&#13;
          var errorElement = isError.getElementsByTagName('div')[0] || isError;&#13;
          throw util.error(new Error(errorElement.textContent || 'Parser error in document'),&#13;
            {&#13;
              code: 'XMLParserError',&#13;
              retryable: true&#13;
            });&#13;
        }&#13;
      } else if (window.ActiveXObject) {&#13;
        result = new window.ActiveXObject('Microsoft.XMLDOM');&#13;
        result.async = false;&#13;
  &#13;
        if (!result.loadXML(xml)) {&#13;
          throw util.error(new Error('Parse error in document'),&#13;
            {&#13;
              code: 'XMLParserError',&#13;
              retryable: true&#13;
            });&#13;
        }&#13;
      } else {&#13;
        throw new Error('Cannot load XML parser');&#13;
      }&#13;
    } catch (e) {&#13;
      error = e;&#13;
    }&#13;
  &#13;
    if (result &amp;&amp; result.documentElement &amp;&amp; !error) {&#13;
      var data = parseXml(result.documentElement, shape);&#13;
      var metadata = result.getElementsByTagName('ResponseMetadata')[0];&#13;
      if (metadata) {&#13;
        data.ResponseMetadata = parseXml(metadata, {});&#13;
      }&#13;
      return data;&#13;
    } else if (error) {&#13;
      throw util.error(error || new Error(), {code: 'XMLParserError', retryable: true});&#13;
    } else { // empty xml document&#13;
      return {};&#13;
    }&#13;
  };&#13;
  &#13;
  function parseXml(xml, shape) {&#13;
    if (!shape) shape = {};&#13;
    switch (shape.type) {&#13;
      case 'structure': return parseStructure(xml, shape);&#13;
      case 'map': return parseMap(xml, shape);&#13;
      case 'list': return parseList(xml, shape);&#13;
      case undefined: case null: return parseUnknown(xml);&#13;
      default: return parseScalar(xml, shape);&#13;
    }&#13;
  }&#13;
  &#13;
  function parseStructure(xml, shape) {&#13;
    var data = {};&#13;
    if (xml === null) return data;&#13;
  &#13;
    util.each(shape.members, function(memberName, memberShape) {&#13;
      if (memberShape.isXmlAttribute) {&#13;
        if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {&#13;
          var value = xml.attributes[memberShape.name].value;&#13;
          data[memberName] = parseXml({textContent: value}, memberShape);&#13;
        }&#13;
      } else {&#13;
        var xmlChild = memberShape.flattened ? xml :&#13;
          xml.getElementsByTagName(memberShape.name)[0];&#13;
        if (xmlChild) {&#13;
          data[memberName] = parseXml(xmlChild, memberShape);&#13;
        } else if (!memberShape.flattened &amp;&amp; memberShape.type === 'list') {&#13;
          data[memberName] = memberShape.defaultValue;&#13;
        }&#13;
      }&#13;
    });&#13;
  &#13;
    return data;&#13;
  }&#13;
  &#13;
  function parseMap(xml, shape) {&#13;
    var data = {};&#13;
    var xmlKey = shape.key.name || 'key';&#13;
    var xmlValue = shape.value.name || 'value';&#13;
    var tagName = shape.flattened ? shape.name : 'entry';&#13;
  &#13;
    var child = xml.firstElementChild;&#13;
    while (child) {&#13;
      if (child.nodeName === tagName) {&#13;
        var key = child.getElementsByTagName(xmlKey)[0].textContent;&#13;
        var value = child.getElementsByTagName(xmlValue)[0];&#13;
        data[key] = parseXml(value, shape.value);&#13;
      }&#13;
      child = child.nextElementSibling;&#13;
    }&#13;
    return data;&#13;
  }&#13;
  &#13;
  function parseList(xml, shape) {&#13;
    var data = [];&#13;
    var tagName = shape.flattened ? shape.name : (shape.member.name || 'member');&#13;
  &#13;
    var child = xml.firstElementChild;&#13;
    while (child) {&#13;
      if (child.nodeName === tagName) {&#13;
        data.push(parseXml(child, shape.member));&#13;
      }&#13;
      child = child.nextElementSibling;&#13;
    }&#13;
    return data;&#13;
  }&#13;
  &#13;
  function parseScalar(xml, shape) {&#13;
    if (xml.getAttribute) {&#13;
      var encoding = xml.getAttribute('encoding');&#13;
      if (encoding === 'base64') {&#13;
        shape = new Shape.create({type: encoding});&#13;
      }&#13;
    }&#13;
  &#13;
    var text = xml.textContent;&#13;
    if (text === '') text = null;&#13;
    if (typeof shape.toType === 'function') {&#13;
      return shape.toType(text);&#13;
    } else {&#13;
      return text;&#13;
    }&#13;
  }&#13;
  &#13;
  function parseUnknown(xml) {&#13;
    if (xml === undefined || xml === null) return '';&#13;
  &#13;
    if (!xml.firstElementChild) {&#13;
      if (xml.parentNode.parentNode === null) return {};&#13;
      if (xml.childNodes.length === 0) return '';&#13;
      else return xml.textContent;&#13;
    }&#13;
  &#13;
    var shape = {type: 'structure', members: {}};&#13;
    var child = xml.firstElementChild;&#13;
    while (child) {&#13;
      var tag = child.nodeName;&#13;
      if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {&#13;
        shape.members[tag].type = 'list';&#13;
      } else {&#13;
        shape.members[tag] = {name: tag};&#13;
      }&#13;
      child = child.nextElementSibling;&#13;
    }&#13;
    return parseStructure(xml, shape);&#13;
  }&#13;
  &#13;
  module.exports = DomXmlParser;&#13;
  &#13;
  },{"../model/shape":27,"../util":52}],54:[function(require,module,exports){&#13;
  var util = require('../util');&#13;
  var builder = require('xmlbuilder');&#13;
  &#13;
  function XmlBuilder() { }&#13;
  &#13;
  XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {&#13;
    var xml = builder.create(rootElement);&#13;
    applyNamespaces(xml, shape);&#13;
    serialize(xml, params, shape);&#13;
    return xml.children.length &gt; 0 || noEmpty ? xml.root().toString() : '';&#13;
  };&#13;
  &#13;
  function serialize(xml, value, shape) {&#13;
    switch (shape.type) {&#13;
      case 'structure': return serializeStructure(xml, value, shape);&#13;
      case 'map': return serializeMap(xml, value, shape);&#13;
      case 'list': return serializeList(xml, value, shape);&#13;
      default: return serializeScalar(xml, value, shape);&#13;
    }&#13;
  }&#13;
  &#13;
  function serializeStructure(xml, params, shape) {&#13;
    util.arrayEach(shape.memberNames, function(memberName) {&#13;
      var memberShape = shape.members[memberName];&#13;
      if (memberShape.location !== 'body') return;&#13;
  &#13;
      var value = params[memberName];&#13;
      var name = memberShape.name;&#13;
      if (value !== undefined &amp;&amp; value !== null) {&#13;
        if (memberShape.isXmlAttribute) {&#13;
          xml.att(name, value);&#13;
        } else if (memberShape.flattened) {&#13;
          serialize(xml, value, memberShape);&#13;
        } else {&#13;
          var element = xml.ele(name);&#13;
          applyNamespaces(element, memberShape);&#13;
          serialize(element, value, memberShape);&#13;
        }&#13;
      }&#13;
    });&#13;
  }&#13;
  &#13;
  function serializeMap(xml, map, shape) {&#13;
    var xmlKey = shape.key.name || 'key';&#13;
    var xmlValue = shape.value.name || 'value';&#13;
  &#13;
    util.each(map, function(key, value) {&#13;
      var entry = xml.ele(shape.flattened ? shape.name : 'entry');&#13;
      serialize(entry.ele(xmlKey), key, shape.key);&#13;
      serialize(entry.ele(xmlValue), value, shape.value);&#13;
    });&#13;
  }&#13;
  &#13;
  function serializeList(xml, list, shape) {&#13;
    if (shape.flattened) {&#13;
      util.arrayEach(list, function(value) {&#13;
        var name = shape.member.name || shape.name;&#13;
        var element = xml.ele(name);&#13;
        serialize(element, value, shape.member);&#13;
      });&#13;
    } else {&#13;
      util.arrayEach(list, function(value) {&#13;
        var name = shape.member.name || 'member';&#13;
        var element = xml.ele(name);&#13;
        serialize(element, value, shape.member);&#13;
      });&#13;
    }&#13;
  }&#13;
  &#13;
  function serializeScalar(xml, value, shape) {&#13;
    xml.txt(shape.toWireFormat(value));&#13;
  }&#13;
  &#13;
  function applyNamespaces(xml, shape) {&#13;
    var uri, prefix = 'xmlns';&#13;
    if (shape.xmlNamespaceUri) {&#13;
      uri = shape.xmlNamespaceUri;&#13;
      if (shape.xmlNamespacePrefix) prefix += ':' + shape.xmlNamespacePrefix;&#13;
    } else if (xml.isRoot &amp;&amp; shape.api.xmlNamespaceUri) {&#13;
      uri = shape.api.xmlNamespaceUri;&#13;
    }&#13;
  &#13;
    if (uri) xml.att(prefix, uri);&#13;
  }&#13;
  &#13;
  module.exports = XmlBuilder;&#13;
  &#13;
  },{"../util":52,"xmlbuilder":145}],55:[function(require,module,exports){&#13;
  'use strict'&#13;
  &#13;
  exports.byteLength = byteLength&#13;
  exports.toByteArray = toByteArray&#13;
  exports.fromByteArray = fromByteArray&#13;
  &#13;
  var lookup = []&#13;
  var revLookup = []&#13;
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array&#13;
  &#13;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'&#13;
  for (var i = 0, len = code.length; i &lt; len; ++i) {&#13;
    lookup[i] = code[i]&#13;
    revLookup[code.charCodeAt(i)] = i&#13;
  }&#13;
  &#13;
  revLookup['-'.charCodeAt(0)] = 62&#13;
  revLookup['_'.charCodeAt(0)] = 63&#13;
  &#13;
  function placeHoldersCount (b64) {&#13;
    var len = b64.length&#13;
    if (len % 4 &gt; 0) {&#13;
      throw new Error('Invalid string. Length must be a multiple of 4')&#13;
    }&#13;
  &#13;
    return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0&#13;
  }&#13;
  &#13;
  function byteLength (b64) {&#13;
    return b64.length * 3 / 4 - placeHoldersCount(b64)&#13;
  }&#13;
  &#13;
  function toByteArray (b64) {&#13;
    var i, j, l, tmp, placeHolders, arr&#13;
    var len = b64.length&#13;
    placeHolders = placeHoldersCount(b64)&#13;
  &#13;
    arr = new Arr(len * 3 / 4 - placeHolders)&#13;
  &#13;
    l = placeHolders &gt; 0 ? len - 4 : len&#13;
  &#13;
    var L = 0&#13;
  &#13;
    for (i = 0, j = 0; i &lt; l; i += 4, j += 3) {&#13;
      tmp = (revLookup[b64.charCodeAt(i)] &lt;&lt; 18) | (revLookup[b64.charCodeAt(i + 1)] &lt;&lt; 12) | (revLookup[b64.charCodeAt(i + 2)] &lt;&lt; 6) | revLookup[b64.charCodeAt(i + 3)]&#13;
      arr[L++] = (tmp &gt;&gt; 16) &amp; 0xFF&#13;
      arr[L++] = (tmp &gt;&gt; 8) &amp; 0xFF&#13;
      arr[L++] = tmp &amp; 0xFF&#13;
    }&#13;
  &#13;
    if (placeHolders === 2) {&#13;
      tmp = (revLookup[b64.charCodeAt(i)] &lt;&lt; 2) | (revLookup[b64.charCodeAt(i + 1)] &gt;&gt; 4)&#13;
      arr[L++] = tmp &amp; 0xFF&#13;
    } else if (placeHolders === 1) {&#13;
      tmp = (revLookup[b64.charCodeAt(i)] &lt;&lt; 10) | (revLookup[b64.charCodeAt(i + 1)] &lt;&lt; 4) | (revLookup[b64.charCodeAt(i + 2)] &gt;&gt; 2)&#13;
      arr[L++] = (tmp &gt;&gt; 8) &amp; 0xFF&#13;
      arr[L++] = tmp &amp; 0xFF&#13;
    }&#13;
  &#13;
    return arr&#13;
  }&#13;
  &#13;
  function tripletToBase64 (num) {&#13;
    return lookup[num &gt;&gt; 18 &amp; 0x3F] + lookup[num &gt;&gt; 12 &amp; 0x3F] + lookup[num &gt;&gt; 6 &amp; 0x3F] + lookup[num &amp; 0x3F]&#13;
  }&#13;
  &#13;
  function encodeChunk (uint8, start, end) {&#13;
    var tmp&#13;
    var output = []&#13;
    for (var i = start; i &lt; end; i += 3) {&#13;
      tmp = (uint8[i] &lt;&lt; 16) + (uint8[i + 1] &lt;&lt; 8) + (uint8[i + 2])&#13;
      output.push(tripletToBase64(tmp))&#13;
    }&#13;
    return output.join('')&#13;
  }&#13;
  &#13;
  function fromByteArray (uint8) {&#13;
    var tmp&#13;
    var len = uint8.length&#13;
    var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes&#13;
    var output = ''&#13;
    var parts = []&#13;
    var maxChunkLength = 16383 // must be multiple of 3&#13;
  &#13;
    for (var i = 0, len2 = len - extraBytes; i &lt; len2; i += maxChunkLength) {&#13;
      parts.push(encodeChunk(uint8, i, (i + maxChunkLength) &gt; len2 ? len2 : (i + maxChunkLength)))&#13;
    }&#13;
  &#13;
    if (extraBytes === 1) {&#13;
      tmp = uint8[len - 1]&#13;
      output += lookup[tmp &gt;&gt; 2]&#13;
      output += lookup[(tmp &lt;&lt; 4) &amp; 0x3F]&#13;
      output += '=='&#13;
    } else if (extraBytes === 2) {&#13;
      tmp = (uint8[len - 2] &lt;&lt; 8) + (uint8[len - 1])&#13;
      output += lookup[tmp &gt;&gt; 10]&#13;
      output += lookup[(tmp &gt;&gt; 4) &amp; 0x3F]&#13;
      output += lookup[(tmp &lt;&lt; 2) &amp; 0x3F]&#13;
      output += '='&#13;
    }&#13;
  &#13;
    parts.push(output)&#13;
  &#13;
    return parts.join('')&#13;
  }&#13;
  &#13;
  },{}],56:[function(require,module,exports){&#13;
  &#13;
  },{}],57:[function(require,module,exports){&#13;
  (function (global){&#13;
  &#13;
  &#13;
  &#13;
  'use strict'&#13;
  &#13;
  var base64 = require('base64-js')&#13;
  var ieee754 = require('ieee754')&#13;
  var isArray = require('isarray')&#13;
  &#13;
  exports.Buffer = Buffer&#13;
  exports.SlowBuffer = SlowBuffer&#13;
  exports.INSPECT_MAX_BYTES = 50&#13;
  &#13;
  &#13;
  Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined&#13;
    ? global.TYPED_ARRAY_SUPPORT&#13;
    : typedArraySupport()&#13;
  &#13;
  &#13;
  exports.kMaxLength = kMaxLength()&#13;
  &#13;
  function typedArraySupport () {&#13;
    try {&#13;
      var arr = new Uint8Array(1)&#13;
      arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}&#13;
      return arr.foo() === 42 &amp;&amp; // typed array instances can be augmented&#13;
          typeof arr.subarray === 'function' &amp;&amp; // chrome 9-10 lack `subarray`&#13;
          arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`&#13;
    } catch (e) {&#13;
      return false&#13;
    }&#13;
  }&#13;
  &#13;
  function kMaxLength () {&#13;
    return Buffer.TYPED_ARRAY_SUPPORT&#13;
      ? 0x7fffffff&#13;
      : 0x3fffffff&#13;
  }&#13;
  &#13;
  function createBuffer (that, length) {&#13;
    if (kMaxLength() &lt; length) {&#13;
      throw new RangeError('Invalid typed array length')&#13;
    }&#13;
    if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      that = new Uint8Array(length)&#13;
      that.__proto__ = Buffer.prototype&#13;
    } else {&#13;
      if (that === null) {&#13;
        that = new Buffer(length)&#13;
      }&#13;
      that.length = length&#13;
    }&#13;
  &#13;
    return that&#13;
  }&#13;
  &#13;
  &#13;
  &#13;
  function Buffer (arg, encodingOrOffset, length) {&#13;
    if (!Buffer.TYPED_ARRAY_SUPPORT &amp;&amp; !(this instanceof Buffer)) {&#13;
      return new Buffer(arg, encodingOrOffset, length)&#13;
    }&#13;
  &#13;
    if (typeof arg === 'number') {&#13;
      if (typeof encodingOrOffset === 'string') {&#13;
        throw new Error(&#13;
          'If encoding is specified then the first argument must be a string'&#13;
        )&#13;
      }&#13;
      return allocUnsafe(this, arg)&#13;
    }&#13;
    return from(this, arg, encodingOrOffset, length)&#13;
  }&#13;
  &#13;
  Buffer.poolSize = 8192 // not used by this implementation&#13;
  &#13;
  Buffer._augment = function (arr) {&#13;
    arr.__proto__ = Buffer.prototype&#13;
    return arr&#13;
  }&#13;
  &#13;
  function from (that, value, encodingOrOffset, length) {&#13;
    if (typeof value === 'number') {&#13;
      throw new TypeError('"value" argument must not be a number')&#13;
    }&#13;
  &#13;
    if (typeof ArrayBuffer !== 'undefined' &amp;&amp; value instanceof ArrayBuffer) {&#13;
      return fromArrayBuffer(that, value, encodingOrOffset, length)&#13;
    }&#13;
  &#13;
    if (typeof value === 'string') {&#13;
      return fromString(that, value, encodingOrOffset)&#13;
    }&#13;
  &#13;
    return fromObject(that, value)&#13;
  }&#13;
  &#13;
  &#13;
  Buffer.from = function (value, encodingOrOffset, length) {&#13;
    return from(null, value, encodingOrOffset, length)&#13;
  }&#13;
  &#13;
  if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
    Buffer.prototype.__proto__ = Uint8Array.prototype&#13;
    Buffer.__proto__ = Uint8Array&#13;
    if (typeof Symbol !== 'undefined' &amp;&amp; Symbol.species &amp;&amp;&#13;
        Buffer[Symbol.species] === Buffer) {&#13;
      Object.defineProperty(Buffer, Symbol.species, {&#13;
        value: null,&#13;
        configurable: true&#13;
      })&#13;
    }&#13;
  }&#13;
  &#13;
  function assertSize (size) {&#13;
    if (typeof size !== 'number') {&#13;
      throw new TypeError('"size" argument must be a number')&#13;
    } else if (size &lt; 0) {&#13;
      throw new RangeError('"size" argument must not be negative')&#13;
    }&#13;
  }&#13;
  &#13;
  function alloc (that, size, fill, encoding) {&#13;
    assertSize(size)&#13;
    if (size &lt;= 0) {&#13;
      return createBuffer(that, size)&#13;
    }&#13;
    if (fill !== undefined) {&#13;
      return typeof encoding === 'string'&#13;
        ? createBuffer(that, size).fill(fill, encoding)&#13;
        : createBuffer(that, size).fill(fill)&#13;
    }&#13;
    return createBuffer(that, size)&#13;
  }&#13;
  &#13;
  &#13;
  Buffer.alloc = function (size, fill, encoding) {&#13;
    return alloc(null, size, fill, encoding)&#13;
  }&#13;
  &#13;
  function allocUnsafe (that, size) {&#13;
    assertSize(size)&#13;
    that = createBuffer(that, size &lt; 0 ? 0 : checked(size) | 0)&#13;
    if (!Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      for (var i = 0; i &lt; size; ++i) {&#13;
        that[i] = 0&#13;
      }&#13;
    }&#13;
    return that&#13;
  }&#13;
  &#13;
  &#13;
  Buffer.allocUnsafe = function (size) {&#13;
    return allocUnsafe(null, size)&#13;
  }&#13;
  &#13;
  Buffer.allocUnsafeSlow = function (size) {&#13;
    return allocUnsafe(null, size)&#13;
  }&#13;
  &#13;
  function fromString (that, string, encoding) {&#13;
    if (typeof encoding !== 'string' || encoding === '') {&#13;
      encoding = 'utf8'&#13;
    }&#13;
  &#13;
    if (!Buffer.isEncoding(encoding)) {&#13;
      throw new TypeError('"encoding" must be a valid string encoding')&#13;
    }&#13;
  &#13;
    var length = byteLength(string, encoding) | 0&#13;
    that = createBuffer(that, length)&#13;
  &#13;
    var actual = that.write(string, encoding)&#13;
  &#13;
    if (actual !== length) {&#13;
      that = that.slice(0, actual)&#13;
    }&#13;
  &#13;
    return that&#13;
  }&#13;
  &#13;
  function fromArrayLike (that, array) {&#13;
    var length = array.length &lt; 0 ? 0 : checked(array.length) | 0&#13;
    that = createBuffer(that, length)&#13;
    for (var i = 0; i &lt; length; i += 1) {&#13;
      that[i] = array[i] &amp; 255&#13;
    }&#13;
    return that&#13;
  }&#13;
  &#13;
  function fromArrayBuffer (that, array, byteOffset, length) {&#13;
    array.byteLength // this throws if `array` is not a valid ArrayBuffer&#13;
  &#13;
    if (byteOffset &lt; 0 || array.byteLength &lt; byteOffset) {&#13;
      throw new RangeError('\'offset\' is out of bounds')&#13;
    }&#13;
  &#13;
    if (array.byteLength &lt; byteOffset + (length || 0)) {&#13;
      throw new RangeError('\'length\' is out of bounds')&#13;
    }&#13;
  &#13;
    if (byteOffset === undefined &amp;&amp; length === undefined) {&#13;
      array = new Uint8Array(array)&#13;
    } else if (length === undefined) {&#13;
      array = new Uint8Array(array, byteOffset)&#13;
    } else {&#13;
      array = new Uint8Array(array, byteOffset, length)&#13;
    }&#13;
  &#13;
    if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      that = array&#13;
      that.__proto__ = Buffer.prototype&#13;
    } else {&#13;
      that = fromArrayLike(that, array)&#13;
    }&#13;
    return that&#13;
  }&#13;
  &#13;
  function fromObject (that, obj) {&#13;
    if (Buffer.isBuffer(obj)) {&#13;
      var len = checked(obj.length) | 0&#13;
      that = createBuffer(that, len)&#13;
  &#13;
      if (that.length === 0) {&#13;
        return that&#13;
      }&#13;
  &#13;
      obj.copy(that, 0, 0, len)&#13;
      return that&#13;
    }&#13;
  &#13;
    if (obj) {&#13;
      if ((typeof ArrayBuffer !== 'undefined' &amp;&amp;&#13;
          obj.buffer instanceof ArrayBuffer) || 'length' in obj) {&#13;
        if (typeof obj.length !== 'number' || isnan(obj.length)) {&#13;
          return createBuffer(that, 0)&#13;
        }&#13;
        return fromArrayLike(that, obj)&#13;
      }&#13;
  &#13;
      if (obj.type === 'Buffer' &amp;&amp; isArray(obj.data)) {&#13;
        return fromArrayLike(that, obj.data)&#13;
      }&#13;
    }&#13;
  &#13;
    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')&#13;
  }&#13;
  &#13;
  function checked (length) {&#13;
    if (length &gt;= kMaxLength()) {&#13;
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' +&#13;
                           'size: 0x' + kMaxLength().toString(16) + ' bytes')&#13;
    }&#13;
    return length | 0&#13;
  }&#13;
  &#13;
  function SlowBuffer (length) {&#13;
    if (+length != length) { // eslint-disable-line eqeqeq&#13;
      length = 0&#13;
    }&#13;
    return Buffer.alloc(+length)&#13;
  }&#13;
  &#13;
  Buffer.isBuffer = function isBuffer (b) {&#13;
    return !!(b != null &amp;&amp; b._isBuffer)&#13;
  }&#13;
  &#13;
  Buffer.compare = function compare (a, b) {&#13;
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {&#13;
      throw new TypeError('Arguments must be Buffers')&#13;
    }&#13;
  &#13;
    if (a === b) return 0&#13;
  &#13;
    var x = a.length&#13;
    var y = b.length&#13;
  &#13;
    for (var i = 0, len = Math.min(x, y); i &lt; len; ++i) {&#13;
      if (a[i] !== b[i]) {&#13;
        x = a[i]&#13;
        y = b[i]&#13;
        break&#13;
      }&#13;
    }&#13;
  &#13;
    if (x &lt; y) return -1&#13;
    if (y &lt; x) return 1&#13;
    return 0&#13;
  }&#13;
  &#13;
  Buffer.isEncoding = function isEncoding (encoding) {&#13;
    switch (String(encoding).toLowerCase()) {&#13;
      case 'hex':&#13;
      case 'utf8':&#13;
      case 'utf-8':&#13;
      case 'ascii':&#13;
      case 'latin1':&#13;
      case 'binary':&#13;
      case 'base64':&#13;
      case 'ucs2':&#13;
      case 'ucs-2':&#13;
      case 'utf16le':&#13;
      case 'utf-16le':&#13;
        return true&#13;
      default:&#13;
        return false&#13;
    }&#13;
  }&#13;
  &#13;
  Buffer.concat = function concat (list, length) {&#13;
    if (!isArray(list)) {&#13;
      throw new TypeError('"list" argument must be an Array of Buffers')&#13;
    }&#13;
  &#13;
    if (list.length === 0) {&#13;
      return Buffer.alloc(0)&#13;
    }&#13;
  &#13;
    var i&#13;
    if (length === undefined) {&#13;
      length = 0&#13;
      for (i = 0; i &lt; list.length; ++i) {&#13;
        length += list[i].length&#13;
      }&#13;
    }&#13;
  &#13;
    var buffer = Buffer.allocUnsafe(length)&#13;
    var pos = 0&#13;
    for (i = 0; i &lt; list.length; ++i) {&#13;
      var buf = list[i]&#13;
      if (!Buffer.isBuffer(buf)) {&#13;
        throw new TypeError('"list" argument must be an Array of Buffers')&#13;
      }&#13;
      buf.copy(buffer, pos)&#13;
      pos += buf.length&#13;
    }&#13;
    return buffer&#13;
  }&#13;
  &#13;
  function byteLength (string, encoding) {&#13;
    if (Buffer.isBuffer(string)) {&#13;
      return string.length&#13;
    }&#13;
    if (typeof ArrayBuffer !== 'undefined' &amp;&amp; typeof ArrayBuffer.isView === 'function' &amp;&amp;&#13;
        (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {&#13;
      return string.byteLength&#13;
    }&#13;
    if (typeof string !== 'string') {&#13;
      string = '' + string&#13;
    }&#13;
  &#13;
    var len = string.length&#13;
    if (len === 0) return 0&#13;
  &#13;
    var loweredCase = false&#13;
    for (;;) {&#13;
      switch (encoding) {&#13;
        case 'ascii':&#13;
        case 'latin1':&#13;
        case 'binary':&#13;
          return len&#13;
        case 'utf8':&#13;
        case 'utf-8':&#13;
        case undefined:&#13;
          return utf8ToBytes(string).length&#13;
        case 'ucs2':&#13;
        case 'ucs-2':&#13;
        case 'utf16le':&#13;
        case 'utf-16le':&#13;
          return len * 2&#13;
        case 'hex':&#13;
          return len &gt;&gt;&gt; 1&#13;
        case 'base64':&#13;
          return base64ToBytes(string).length&#13;
        default:&#13;
          if (loweredCase) return utf8ToBytes(string).length // assume utf8&#13;
          encoding = ('' + encoding).toLowerCase()&#13;
          loweredCase = true&#13;
      }&#13;
    }&#13;
  }&#13;
  Buffer.byteLength = byteLength&#13;
  &#13;
  function slowToString (encoding, start, end) {&#13;
    var loweredCase = false&#13;
  &#13;
  &#13;
    if (start === undefined || start &lt; 0) {&#13;
      start = 0&#13;
    }&#13;
    if (start &gt; this.length) {&#13;
      return ''&#13;
    }&#13;
  &#13;
    if (end === undefined || end &gt; this.length) {&#13;
      end = this.length&#13;
    }&#13;
  &#13;
    if (end &lt;= 0) {&#13;
      return ''&#13;
    }&#13;
  &#13;
    end &gt;&gt;&gt;= 0&#13;
    start &gt;&gt;&gt;= 0&#13;
  &#13;
    if (end &lt;= start) {&#13;
      return ''&#13;
    }&#13;
  &#13;
    if (!encoding) encoding = 'utf8'&#13;
  &#13;
    while (true) {&#13;
      switch (encoding) {&#13;
        case 'hex':&#13;
          return hexSlice(this, start, end)&#13;
  &#13;
        case 'utf8':&#13;
        case 'utf-8':&#13;
          return utf8Slice(this, start, end)&#13;
  &#13;
        case 'ascii':&#13;
          return asciiSlice(this, start, end)&#13;
  &#13;
        case 'latin1':&#13;
        case 'binary':&#13;
          return latin1Slice(this, start, end)&#13;
  &#13;
        case 'base64':&#13;
          return base64Slice(this, start, end)&#13;
  &#13;
        case 'ucs2':&#13;
        case 'ucs-2':&#13;
        case 'utf16le':&#13;
        case 'utf-16le':&#13;
          return utf16leSlice(this, start, end)&#13;
  &#13;
        default:&#13;
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)&#13;
          encoding = (encoding + '').toLowerCase()&#13;
          loweredCase = true&#13;
      }&#13;
    }&#13;
  }&#13;
  &#13;
  Buffer.prototype._isBuffer = true&#13;
  &#13;
  function swap (b, n, m) {&#13;
    var i = b[n]&#13;
    b[n] = b[m]&#13;
    b[m] = i&#13;
  }&#13;
  &#13;
  Buffer.prototype.swap16 = function swap16 () {&#13;
    var len = this.length&#13;
    if (len % 2 !== 0) {&#13;
      throw new RangeError('Buffer size must be a multiple of 16-bits')&#13;
    }&#13;
    for (var i = 0; i &lt; len; i += 2) {&#13;
      swap(this, i, i + 1)&#13;
    }&#13;
    return this&#13;
  }&#13;
  &#13;
  Buffer.prototype.swap32 = function swap32 () {&#13;
    var len = this.length&#13;
    if (len % 4 !== 0) {&#13;
      throw new RangeError('Buffer size must be a multiple of 32-bits')&#13;
    }&#13;
    for (var i = 0; i &lt; len; i += 4) {&#13;
      swap(this, i, i + 3)&#13;
      swap(this, i + 1, i + 2)&#13;
    }&#13;
    return this&#13;
  }&#13;
  &#13;
  Buffer.prototype.swap64 = function swap64 () {&#13;
    var len = this.length&#13;
    if (len % 8 !== 0) {&#13;
      throw new RangeError('Buffer size must be a multiple of 64-bits')&#13;
    }&#13;
    for (var i = 0; i &lt; len; i += 8) {&#13;
      swap(this, i, i + 7)&#13;
      swap(this, i + 1, i + 6)&#13;
      swap(this, i + 2, i + 5)&#13;
      swap(this, i + 3, i + 4)&#13;
    }&#13;
    return this&#13;
  }&#13;
  &#13;
  Buffer.prototype.toString = function toString () {&#13;
    var length = this.length | 0&#13;
    if (length === 0) return ''&#13;
    if (arguments.length === 0) return utf8Slice(this, 0, length)&#13;
    return slowToString.apply(this, arguments)&#13;
  }&#13;
  &#13;
  Buffer.prototype.equals = function equals (b) {&#13;
    if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')&#13;
    if (this === b) return true&#13;
    return Buffer.compare(this, b) === 0&#13;
  }&#13;
  &#13;
  Buffer.prototype.inspect = function inspect () {&#13;
    var str = ''&#13;
    var max = exports.INSPECT_MAX_BYTES&#13;
    if (this.length &gt; 0) {&#13;
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')&#13;
      if (this.length &gt; max) str += ' ... '&#13;
    }&#13;
    return '&lt;Buffer ' + str + '&gt;'&#13;
  }&#13;
  &#13;
  Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {&#13;
    if (!Buffer.isBuffer(target)) {&#13;
      throw new TypeError('Argument must be a Buffer')&#13;
    }&#13;
  &#13;
    if (start === undefined) {&#13;
      start = 0&#13;
    }&#13;
    if (end === undefined) {&#13;
      end = target ? target.length : 0&#13;
    }&#13;
    if (thisStart === undefined) {&#13;
      thisStart = 0&#13;
    }&#13;
    if (thisEnd === undefined) {&#13;
      thisEnd = this.length&#13;
    }&#13;
  &#13;
    if (start &lt; 0 || end &gt; target.length || thisStart &lt; 0 || thisEnd &gt; this.length) {&#13;
      throw new RangeError('out of range index')&#13;
    }&#13;
  &#13;
    if (thisStart &gt;= thisEnd &amp;&amp; start &gt;= end) {&#13;
      return 0&#13;
    }&#13;
    if (thisStart &gt;= thisEnd) {&#13;
      return -1&#13;
    }&#13;
    if (start &gt;= end) {&#13;
      return 1&#13;
    }&#13;
  &#13;
    start &gt;&gt;&gt;= 0&#13;
    end &gt;&gt;&gt;= 0&#13;
    thisStart &gt;&gt;&gt;= 0&#13;
    thisEnd &gt;&gt;&gt;= 0&#13;
  &#13;
    if (this === target) return 0&#13;
  &#13;
    var x = thisEnd - thisStart&#13;
    var y = end - start&#13;
    var len = Math.min(x, y)&#13;
  &#13;
    var thisCopy = this.slice(thisStart, thisEnd)&#13;
    var targetCopy = target.slice(start, end)&#13;
  &#13;
    for (var i = 0; i &lt; len; ++i) {&#13;
      if (thisCopy[i] !== targetCopy[i]) {&#13;
        x = thisCopy[i]&#13;
        y = targetCopy[i]&#13;
        break&#13;
      }&#13;
    }&#13;
  &#13;
    if (x &lt; y) return -1&#13;
    if (y &lt; x) return 1&#13;
    return 0&#13;
  }&#13;
  &#13;
  function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {&#13;
    if (buffer.length === 0) return -1&#13;
  &#13;
    if (typeof byteOffset === 'string') {&#13;
      encoding = byteOffset&#13;
      byteOffset = 0&#13;
    } else if (byteOffset &gt; 0x7fffffff) {&#13;
      byteOffset = 0x7fffffff&#13;
    } else if (byteOffset &lt; -0x80000000) {&#13;
      byteOffset = -0x80000000&#13;
    }&#13;
    byteOffset = +byteOffset  // Coerce to Number.&#13;
    if (isNaN(byteOffset)) {&#13;
      byteOffset = dir ? 0 : (buffer.length - 1)&#13;
    }&#13;
  &#13;
    if (byteOffset &lt; 0) byteOffset = buffer.length + byteOffset&#13;
    if (byteOffset &gt;= buffer.length) {&#13;
      if (dir) return -1&#13;
      else byteOffset = buffer.length - 1&#13;
    } else if (byteOffset &lt; 0) {&#13;
      if (dir) byteOffset = 0&#13;
      else return -1&#13;
    }&#13;
  &#13;
    if (typeof val === 'string') {&#13;
      val = Buffer.from(val, encoding)&#13;
    }&#13;
  &#13;
    if (Buffer.isBuffer(val)) {&#13;
      if (val.length === 0) {&#13;
        return -1&#13;
      }&#13;
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir)&#13;
    } else if (typeof val === 'number') {&#13;
      val = val &amp; 0xFF // Search for a byte value [0-255]&#13;
      if (Buffer.TYPED_ARRAY_SUPPORT &amp;&amp;&#13;
          typeof Uint8Array.prototype.indexOf === 'function') {&#13;
        if (dir) {&#13;
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)&#13;
        } else {&#13;
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)&#13;
        }&#13;
      }&#13;
      return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)&#13;
    }&#13;
  &#13;
    throw new TypeError('val must be string, number or Buffer')&#13;
  }&#13;
  &#13;
  function arrayIndexOf (arr, val, byteOffset, encoding, dir) {&#13;
    var indexSize = 1&#13;
    var arrLength = arr.length&#13;
    var valLength = val.length&#13;
  &#13;
    if (encoding !== undefined) {&#13;
      encoding = String(encoding).toLowerCase()&#13;
      if (encoding === 'ucs2' || encoding === 'ucs-2' ||&#13;
          encoding === 'utf16le' || encoding === 'utf-16le') {&#13;
        if (arr.length &lt; 2 || val.length &lt; 2) {&#13;
          return -1&#13;
        }&#13;
        indexSize = 2&#13;
        arrLength /= 2&#13;
        valLength /= 2&#13;
        byteOffset /= 2&#13;
      }&#13;
    }&#13;
  &#13;
    function read (buf, i) {&#13;
      if (indexSize === 1) {&#13;
        return buf[i]&#13;
      } else {&#13;
        return buf.readUInt16BE(i * indexSize)&#13;
      }&#13;
    }&#13;
  &#13;
    var i&#13;
    if (dir) {&#13;
      var foundIndex = -1&#13;
      for (i = byteOffset; i &lt; arrLength; i++) {&#13;
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {&#13;
          if (foundIndex === -1) foundIndex = i&#13;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize&#13;
        } else {&#13;
          if (foundIndex !== -1) i -= i - foundIndex&#13;
          foundIndex = -1&#13;
        }&#13;
      }&#13;
    } else {&#13;
      if (byteOffset + valLength &gt; arrLength) byteOffset = arrLength - valLength&#13;
      for (i = byteOffset; i &gt;= 0; i--) {&#13;
        var found = true&#13;
        for (var j = 0; j &lt; valLength; j++) {&#13;
          if (read(arr, i + j) !== read(val, j)) {&#13;
            found = false&#13;
            break&#13;
          }&#13;
        }&#13;
        if (found) return i&#13;
      }&#13;
    }&#13;
  &#13;
    return -1&#13;
  }&#13;
  &#13;
  Buffer.prototype.includes = function includes (val, byteOffset, encoding) {&#13;
    return this.indexOf(val, byteOffset, encoding) !== -1&#13;
  }&#13;
  &#13;
  Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {&#13;
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true)&#13;
  }&#13;
  &#13;
  Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {&#13;
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false)&#13;
  }&#13;
  &#13;
  function hexWrite (buf, string, offset, length) {&#13;
    offset = Number(offset) || 0&#13;
    var remaining = buf.length - offset&#13;
    if (!length) {&#13;
      length = remaining&#13;
    } else {&#13;
      length = Number(length)&#13;
      if (length &gt; remaining) {&#13;
        length = remaining&#13;
      }&#13;
    }&#13;
  &#13;
    var strLen = string.length&#13;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')&#13;
  &#13;
    if (length &gt; strLen / 2) {&#13;
      length = strLen / 2&#13;
    }&#13;
    for (var i = 0; i &lt; length; ++i) {&#13;
      var parsed = parseInt(string.substr(i * 2, 2), 16)&#13;
      if (isNaN(parsed)) return i&#13;
      buf[offset + i] = parsed&#13;
    }&#13;
    return i&#13;
  }&#13;
  &#13;
  function utf8Write (buf, string, offset, length) {&#13;
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)&#13;
  }&#13;
  &#13;
  function asciiWrite (buf, string, offset, length) {&#13;
    return blitBuffer(asciiToBytes(string), buf, offset, length)&#13;
  }&#13;
  &#13;
  function latin1Write (buf, string, offset, length) {&#13;
    return asciiWrite(buf, string, offset, length)&#13;
  }&#13;
  &#13;
  function base64Write (buf, string, offset, length) {&#13;
    return blitBuffer(base64ToBytes(string), buf, offset, length)&#13;
  }&#13;
  &#13;
  function ucs2Write (buf, string, offset, length) {&#13;
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)&#13;
  }&#13;
  &#13;
  Buffer.prototype.write = function write (string, offset, length, encoding) {&#13;
    if (offset === undefined) {&#13;
      encoding = 'utf8'&#13;
      length = this.length&#13;
      offset = 0&#13;
    } else if (length === undefined &amp;&amp; typeof offset === 'string') {&#13;
      encoding = offset&#13;
      length = this.length&#13;
      offset = 0&#13;
    } else if (isFinite(offset)) {&#13;
      offset = offset | 0&#13;
      if (isFinite(length)) {&#13;
        length = length | 0&#13;
        if (encoding === undefined) encoding = 'utf8'&#13;
      } else {&#13;
        encoding = length&#13;
        length = undefined&#13;
      }&#13;
    } else {&#13;
      throw new Error(&#13;
        'Buffer.write(string, encoding, offset[, length]) is no longer supported'&#13;
      )&#13;
    }&#13;
  &#13;
    var remaining = this.length - offset&#13;
    if (length === undefined || length &gt; remaining) length = remaining&#13;
  &#13;
    if ((string.length &gt; 0 &amp;&amp; (length &lt; 0 || offset &lt; 0)) || offset &gt; this.length) {&#13;
      throw new RangeError('Attempt to write outside buffer bounds')&#13;
    }&#13;
  &#13;
    if (!encoding) encoding = 'utf8'&#13;
  &#13;
    var loweredCase = false&#13;
    for (;;) {&#13;
      switch (encoding) {&#13;
        case 'hex':&#13;
          return hexWrite(this, string, offset, length)&#13;
  &#13;
        case 'utf8':&#13;
        case 'utf-8':&#13;
          return utf8Write(this, string, offset, length)&#13;
  &#13;
        case 'ascii':&#13;
          return asciiWrite(this, string, offset, length)&#13;
  &#13;
        case 'latin1':&#13;
        case 'binary':&#13;
          return latin1Write(this, string, offset, length)&#13;
  &#13;
        case 'base64':&#13;
          return base64Write(this, string, offset, length)&#13;
  &#13;
        case 'ucs2':&#13;
        case 'ucs-2':&#13;
        case 'utf16le':&#13;
        case 'utf-16le':&#13;
          return ucs2Write(this, string, offset, length)&#13;
  &#13;
        default:&#13;
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)&#13;
          encoding = ('' + encoding).toLowerCase()&#13;
          loweredCase = true&#13;
      }&#13;
    }&#13;
  }&#13;
  &#13;
  Buffer.prototype.toJSON = function toJSON () {&#13;
    return {&#13;
      type: 'Buffer',&#13;
      data: Array.prototype.slice.call(this._arr || this, 0)&#13;
    }&#13;
  }&#13;
  &#13;
  function base64Slice (buf, start, end) {&#13;
    if (start === 0 &amp;&amp; end === buf.length) {&#13;
      return base64.fromByteArray(buf)&#13;
    } else {&#13;
      return base64.fromByteArray(buf.slice(start, end))&#13;
    }&#13;
  }&#13;
  &#13;
  function utf8Slice (buf, start, end) {&#13;
    end = Math.min(buf.length, end)&#13;
    var res = []&#13;
  &#13;
    var i = start&#13;
    while (i &lt; end) {&#13;
      var firstByte = buf[i]&#13;
      var codePoint = null&#13;
      var bytesPerSequence = (firstByte &gt; 0xEF) ? 4&#13;
        : (firstByte &gt; 0xDF) ? 3&#13;
        : (firstByte &gt; 0xBF) ? 2&#13;
        : 1&#13;
  &#13;
      if (i + bytesPerSequence &lt;= end) {&#13;
        var secondByte, thirdByte, fourthByte, tempCodePoint&#13;
  &#13;
        switch (bytesPerSequence) {&#13;
          case 1:&#13;
            if (firstByte &lt; 0x80) {&#13;
              codePoint = firstByte&#13;
            }&#13;
            break&#13;
          case 2:&#13;
            secondByte = buf[i + 1]&#13;
            if ((secondByte &amp; 0xC0) === 0x80) {&#13;
              tempCodePoint = (firstByte &amp; 0x1F) &lt;&lt; 0x6 | (secondByte &amp; 0x3F)&#13;
              if (tempCodePoint &gt; 0x7F) {&#13;
                codePoint = tempCodePoint&#13;
              }&#13;
            }&#13;
            break&#13;
          case 3:&#13;
            secondByte = buf[i + 1]&#13;
            thirdByte = buf[i + 2]&#13;
            if ((secondByte &amp; 0xC0) === 0x80 &amp;&amp; (thirdByte &amp; 0xC0) === 0x80) {&#13;
              tempCodePoint = (firstByte &amp; 0xF) &lt;&lt; 0xC | (secondByte &amp; 0x3F) &lt;&lt; 0x6 | (thirdByte &amp; 0x3F)&#13;
              if (tempCodePoint &gt; 0x7FF &amp;&amp; (tempCodePoint &lt; 0xD800 || tempCodePoint &gt; 0xDFFF)) {&#13;
                codePoint = tempCodePoint&#13;
              }&#13;
            }&#13;
            break&#13;
          case 4:&#13;
            secondByte = buf[i + 1]&#13;
            thirdByte = buf[i + 2]&#13;
            fourthByte = buf[i + 3]&#13;
            if ((secondByte &amp; 0xC0) === 0x80 &amp;&amp; (thirdByte &amp; 0xC0) === 0x80 &amp;&amp; (fourthByte &amp; 0xC0) === 0x80) {&#13;
              tempCodePoint = (firstByte &amp; 0xF) &lt;&lt; 0x12 | (secondByte &amp; 0x3F) &lt;&lt; 0xC | (thirdByte &amp; 0x3F) &lt;&lt; 0x6 | (fourthByte &amp; 0x3F)&#13;
              if (tempCodePoint &gt; 0xFFFF &amp;&amp; tempCodePoint &lt; 0x110000) {&#13;
                codePoint = tempCodePoint&#13;
              }&#13;
            }&#13;
        }&#13;
      }&#13;
  &#13;
      if (codePoint === null) {&#13;
        codePoint = 0xFFFD&#13;
        bytesPerSequence = 1&#13;
      } else if (codePoint &gt; 0xFFFF) {&#13;
        codePoint -= 0x10000&#13;
        res.push(codePoint &gt;&gt;&gt; 10 &amp; 0x3FF | 0xD800)&#13;
        codePoint = 0xDC00 | codePoint &amp; 0x3FF&#13;
      }&#13;
  &#13;
      res.push(codePoint)&#13;
      i += bytesPerSequence&#13;
    }&#13;
  &#13;
    return decodeCodePointsArray(res)&#13;
  }&#13;
  &#13;
  var MAX_ARGUMENTS_LENGTH = 0x1000&#13;
  &#13;
  function decodeCodePointsArray (codePoints) {&#13;
    var len = codePoints.length&#13;
    if (len &lt;= MAX_ARGUMENTS_LENGTH) {&#13;
      return String.fromCharCode.apply(String, codePoints) // avoid extra slice()&#13;
    }&#13;
  &#13;
    var res = ''&#13;
    var i = 0&#13;
    while (i &lt; len) {&#13;
      res += String.fromCharCode.apply(&#13;
        String,&#13;
        codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)&#13;
      )&#13;
    }&#13;
    return res&#13;
  }&#13;
  &#13;
  function asciiSlice (buf, start, end) {&#13;
    var ret = ''&#13;
    end = Math.min(buf.length, end)&#13;
  &#13;
    for (var i = start; i &lt; end; ++i) {&#13;
      ret += String.fromCharCode(buf[i] &amp; 0x7F)&#13;
    }&#13;
    return ret&#13;
  }&#13;
  &#13;
  function latin1Slice (buf, start, end) {&#13;
    var ret = ''&#13;
    end = Math.min(buf.length, end)&#13;
  &#13;
    for (var i = start; i &lt; end; ++i) {&#13;
      ret += String.fromCharCode(buf[i])&#13;
    }&#13;
    return ret&#13;
  }&#13;
  &#13;
  function hexSlice (buf, start, end) {&#13;
    var len = buf.length&#13;
  &#13;
    if (!start || start &lt; 0) start = 0&#13;
    if (!end || end &lt; 0 || end &gt; len) end = len&#13;
  &#13;
    var out = ''&#13;
    for (var i = start; i &lt; end; ++i) {&#13;
      out += toHex(buf[i])&#13;
    }&#13;
    return out&#13;
  }&#13;
  &#13;
  function utf16leSlice (buf, start, end) {&#13;
    var bytes = buf.slice(start, end)&#13;
    var res = ''&#13;
    for (var i = 0; i &lt; bytes.length; i += 2) {&#13;
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)&#13;
    }&#13;
    return res&#13;
  }&#13;
  &#13;
  Buffer.prototype.slice = function slice (start, end) {&#13;
    var len = this.length&#13;
    start = ~~start&#13;
    end = end === undefined ? len : ~~end&#13;
  &#13;
    if (start &lt; 0) {&#13;
      start += len&#13;
      if (start &lt; 0) start = 0&#13;
    } else if (start &gt; len) {&#13;
      start = len&#13;
    }&#13;
  &#13;
    if (end &lt; 0) {&#13;
      end += len&#13;
      if (end &lt; 0) end = 0&#13;
    } else if (end &gt; len) {&#13;
      end = len&#13;
    }&#13;
  &#13;
    if (end &lt; start) end = start&#13;
  &#13;
    var newBuf&#13;
    if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      newBuf = this.subarray(start, end)&#13;
      newBuf.__proto__ = Buffer.prototype&#13;
    } else {&#13;
      var sliceLen = end - start&#13;
      newBuf = new Buffer(sliceLen, undefined)&#13;
      for (var i = 0; i &lt; sliceLen; ++i) {&#13;
        newBuf[i] = this[i + start]&#13;
      }&#13;
    }&#13;
  &#13;
    return newBuf&#13;
  }&#13;
  &#13;
  &#13;
  function checkOffset (offset, ext, length) {&#13;
    if ((offset % 1) !== 0 || offset &lt; 0) throw new RangeError('offset is not uint')&#13;
    if (offset + ext &gt; length) throw new RangeError('Trying to access beyond buffer length')&#13;
  }&#13;
  &#13;
  Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {&#13;
    offset = offset | 0&#13;
    byteLength = byteLength | 0&#13;
    if (!noAssert) checkOffset(offset, byteLength, this.length)&#13;
  &#13;
    var val = this[offset]&#13;
    var mul = 1&#13;
    var i = 0&#13;
    while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {&#13;
      val += this[offset + i] * mul&#13;
    }&#13;
  &#13;
    return val&#13;
  }&#13;
  &#13;
  Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {&#13;
    offset = offset | 0&#13;
    byteLength = byteLength | 0&#13;
    if (!noAssert) {&#13;
      checkOffset(offset, byteLength, this.length)&#13;
    }&#13;
  &#13;
    var val = this[offset + --byteLength]&#13;
    var mul = 1&#13;
    while (byteLength &gt; 0 &amp;&amp; (mul *= 0x100)) {&#13;
      val += this[offset + --byteLength] * mul&#13;
    }&#13;
  &#13;
    return val&#13;
  }&#13;
  &#13;
  Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 1, this.length)&#13;
    return this[offset]&#13;
  }&#13;
  &#13;
  Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 2, this.length)&#13;
    return this[offset] | (this[offset + 1] &lt;&lt; 8)&#13;
  }&#13;
  &#13;
  Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 2, this.length)&#13;
    return (this[offset] &lt;&lt; 8) | this[offset + 1]&#13;
  }&#13;
  &#13;
  Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 4, this.length)&#13;
  &#13;
    return ((this[offset]) |&#13;
        (this[offset + 1] &lt;&lt; 8) |&#13;
        (this[offset + 2] &lt;&lt; 16)) +&#13;
        (this[offset + 3] * 0x1000000)&#13;
  }&#13;
  &#13;
  Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 4, this.length)&#13;
  &#13;
    return (this[offset] * 0x1000000) +&#13;
      ((this[offset + 1] &lt;&lt; 16) |&#13;
      (this[offset + 2] &lt;&lt; 8) |&#13;
      this[offset + 3])&#13;
  }&#13;
  &#13;
  Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {&#13;
    offset = offset | 0&#13;
    byteLength = byteLength | 0&#13;
    if (!noAssert) checkOffset(offset, byteLength, this.length)&#13;
  &#13;
    var val = this[offset]&#13;
    var mul = 1&#13;
    var i = 0&#13;
    while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {&#13;
      val += this[offset + i] * mul&#13;
    }&#13;
    mul *= 0x80&#13;
  &#13;
    if (val &gt;= mul) val -= Math.pow(2, 8 * byteLength)&#13;
  &#13;
    return val&#13;
  }&#13;
  &#13;
  Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {&#13;
    offset = offset | 0&#13;
    byteLength = byteLength | 0&#13;
    if (!noAssert) checkOffset(offset, byteLength, this.length)&#13;
  &#13;
    var i = byteLength&#13;
    var mul = 1&#13;
    var val = this[offset + --i]&#13;
    while (i &gt; 0 &amp;&amp; (mul *= 0x100)) {&#13;
      val += this[offset + --i] * mul&#13;
    }&#13;
    mul *= 0x80&#13;
  &#13;
    if (val &gt;= mul) val -= Math.pow(2, 8 * byteLength)&#13;
  &#13;
    return val&#13;
  }&#13;
  &#13;
  Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 1, this.length)&#13;
    if (!(this[offset] &amp; 0x80)) return (this[offset])&#13;
    return ((0xff - this[offset] + 1) * -1)&#13;
  }&#13;
  &#13;
  Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 2, this.length)&#13;
    var val = this[offset] | (this[offset + 1] &lt;&lt; 8)&#13;
    return (val &amp; 0x8000) ? val | 0xFFFF0000 : val&#13;
  }&#13;
  &#13;
  Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 2, this.length)&#13;
    var val = this[offset + 1] | (this[offset] &lt;&lt; 8)&#13;
    return (val &amp; 0x8000) ? val | 0xFFFF0000 : val&#13;
  }&#13;
  &#13;
  Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 4, this.length)&#13;
  &#13;
    return (this[offset]) |&#13;
      (this[offset + 1] &lt;&lt; 8) |&#13;
      (this[offset + 2] &lt;&lt; 16) |&#13;
      (this[offset + 3] &lt;&lt; 24)&#13;
  }&#13;
  &#13;
  Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 4, this.length)&#13;
  &#13;
    return (this[offset] &lt;&lt; 24) |&#13;
      (this[offset + 1] &lt;&lt; 16) |&#13;
      (this[offset + 2] &lt;&lt; 8) |&#13;
      (this[offset + 3])&#13;
  }&#13;
  &#13;
  Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 4, this.length)&#13;
    return ieee754.read(this, offset, true, 23, 4)&#13;
  }&#13;
  &#13;
  Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 4, this.length)&#13;
    return ieee754.read(this, offset, false, 23, 4)&#13;
  }&#13;
  &#13;
  Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 8, this.length)&#13;
    return ieee754.read(this, offset, true, 52, 8)&#13;
  }&#13;
  &#13;
  Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {&#13;
    if (!noAssert) checkOffset(offset, 8, this.length)&#13;
    return ieee754.read(this, offset, false, 52, 8)&#13;
  }&#13;
  &#13;
  function checkInt (buf, value, offset, ext, max, min) {&#13;
    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')&#13;
    if (value &gt; max || value &lt; min) throw new RangeError('"value" argument is out of bounds')&#13;
    if (offset + ext &gt; buf.length) throw new RangeError('Index out of range')&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    byteLength = byteLength | 0&#13;
    if (!noAssert) {&#13;
      var maxBytes = Math.pow(2, 8 * byteLength) - 1&#13;
      checkInt(this, value, offset, byteLength, maxBytes, 0)&#13;
    }&#13;
  &#13;
    var mul = 1&#13;
    var i = 0&#13;
    this[offset] = value &amp; 0xFF&#13;
    while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {&#13;
      this[offset + i] = (value / mul) &amp; 0xFF&#13;
    }&#13;
  &#13;
    return offset + byteLength&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    byteLength = byteLength | 0&#13;
    if (!noAssert) {&#13;
      var maxBytes = Math.pow(2, 8 * byteLength) - 1&#13;
      checkInt(this, value, offset, byteLength, maxBytes, 0)&#13;
    }&#13;
  &#13;
    var i = byteLength - 1&#13;
    var mul = 1&#13;
    this[offset + i] = value &amp; 0xFF&#13;
    while (--i &gt;= 0 &amp;&amp; (mul *= 0x100)) {&#13;
      this[offset + i] = (value / mul) &amp; 0xFF&#13;
    }&#13;
  &#13;
    return offset + byteLength&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)&#13;
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)&#13;
    this[offset] = (value &amp; 0xff)&#13;
    return offset + 1&#13;
  }&#13;
  &#13;
  function objectWriteUInt16 (buf, value, offset, littleEndian) {&#13;
    if (value &lt; 0) value = 0xffff + value + 1&#13;
    for (var i = 0, j = Math.min(buf.length - offset, 2); i &lt; j; ++i) {&#13;
      buf[offset + i] = (value &amp; (0xff &lt;&lt; (8 * (littleEndian ? i : 1 - i)))) &gt;&gt;&gt;&#13;
        (littleEndian ? i : 1 - i) * 8&#13;
    }&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)&#13;
    if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      this[offset] = (value &amp; 0xff)&#13;
      this[offset + 1] = (value &gt;&gt;&gt; 8)&#13;
    } else {&#13;
      objectWriteUInt16(this, value, offset, true)&#13;
    }&#13;
    return offset + 2&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)&#13;
    if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      this[offset] = (value &gt;&gt;&gt; 8)&#13;
      this[offset + 1] = (value &amp; 0xff)&#13;
    } else {&#13;
      objectWriteUInt16(this, value, offset, false)&#13;
    }&#13;
    return offset + 2&#13;
  }&#13;
  &#13;
  function objectWriteUInt32 (buf, value, offset, littleEndian) {&#13;
    if (value &lt; 0) value = 0xffffffff + value + 1&#13;
    for (var i = 0, j = Math.min(buf.length - offset, 4); i &lt; j; ++i) {&#13;
      buf[offset + i] = (value &gt;&gt;&gt; (littleEndian ? i : 3 - i) * 8) &amp; 0xff&#13;
    }&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)&#13;
    if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      this[offset + 3] = (value &gt;&gt;&gt; 24)&#13;
      this[offset + 2] = (value &gt;&gt;&gt; 16)&#13;
      this[offset + 1] = (value &gt;&gt;&gt; 8)&#13;
      this[offset] = (value &amp; 0xff)&#13;
    } else {&#13;
      objectWriteUInt32(this, value, offset, true)&#13;
    }&#13;
    return offset + 4&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)&#13;
    if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      this[offset] = (value &gt;&gt;&gt; 24)&#13;
      this[offset + 1] = (value &gt;&gt;&gt; 16)&#13;
      this[offset + 2] = (value &gt;&gt;&gt; 8)&#13;
      this[offset + 3] = (value &amp; 0xff)&#13;
    } else {&#13;
      objectWriteUInt32(this, value, offset, false)&#13;
    }&#13;
    return offset + 4&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    if (!noAssert) {&#13;
      var limit = Math.pow(2, 8 * byteLength - 1)&#13;
  &#13;
      checkInt(this, value, offset, byteLength, limit - 1, -limit)&#13;
    }&#13;
  &#13;
    var i = 0&#13;
    var mul = 1&#13;
    var sub = 0&#13;
    this[offset] = value &amp; 0xFF&#13;
    while (++i &lt; byteLength &amp;&amp; (mul *= 0x100)) {&#13;
      if (value &lt; 0 &amp;&amp; sub === 0 &amp;&amp; this[offset + i - 1] !== 0) {&#13;
        sub = 1&#13;
      }&#13;
      this[offset + i] = ((value / mul) &gt;&gt; 0) - sub &amp; 0xFF&#13;
    }&#13;
  &#13;
    return offset + byteLength&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    if (!noAssert) {&#13;
      var limit = Math.pow(2, 8 * byteLength - 1)&#13;
  &#13;
      checkInt(this, value, offset, byteLength, limit - 1, -limit)&#13;
    }&#13;
  &#13;
    var i = byteLength - 1&#13;
    var mul = 1&#13;
    var sub = 0&#13;
    this[offset + i] = value &amp; 0xFF&#13;
    while (--i &gt;= 0 &amp;&amp; (mul *= 0x100)) {&#13;
      if (value &lt; 0 &amp;&amp; sub === 0 &amp;&amp; this[offset + i + 1] !== 0) {&#13;
        sub = 1&#13;
      }&#13;
      this[offset + i] = ((value / mul) &gt;&gt; 0) - sub &amp; 0xFF&#13;
    }&#13;
  &#13;
    return offset + byteLength&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)&#13;
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)&#13;
    if (value &lt; 0) value = 0xff + value + 1&#13;
    this[offset] = (value &amp; 0xff)&#13;
    return offset + 1&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)&#13;
    if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      this[offset] = (value &amp; 0xff)&#13;
      this[offset + 1] = (value &gt;&gt;&gt; 8)&#13;
    } else {&#13;
      objectWriteUInt16(this, value, offset, true)&#13;
    }&#13;
    return offset + 2&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)&#13;
    if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      this[offset] = (value &gt;&gt;&gt; 8)&#13;
      this[offset + 1] = (value &amp; 0xff)&#13;
    } else {&#13;
      objectWriteUInt16(this, value, offset, false)&#13;
    }&#13;
    return offset + 2&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)&#13;
    if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      this[offset] = (value &amp; 0xff)&#13;
      this[offset + 1] = (value &gt;&gt;&gt; 8)&#13;
      this[offset + 2] = (value &gt;&gt;&gt; 16)&#13;
      this[offset + 3] = (value &gt;&gt;&gt; 24)&#13;
    } else {&#13;
      objectWriteUInt32(this, value, offset, true)&#13;
    }&#13;
    return offset + 4&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {&#13;
    value = +value&#13;
    offset = offset | 0&#13;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)&#13;
    if (value &lt; 0) value = 0xffffffff + value + 1&#13;
    if (Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      this[offset] = (value &gt;&gt;&gt; 24)&#13;
      this[offset + 1] = (value &gt;&gt;&gt; 16)&#13;
      this[offset + 2] = (value &gt;&gt;&gt; 8)&#13;
      this[offset + 3] = (value &amp; 0xff)&#13;
    } else {&#13;
      objectWriteUInt32(this, value, offset, false)&#13;
    }&#13;
    return offset + 4&#13;
  }&#13;
  &#13;
  function checkIEEE754 (buf, value, offset, ext, max, min) {&#13;
    if (offset + ext &gt; buf.length) throw new RangeError('Index out of range')&#13;
    if (offset &lt; 0) throw new RangeError('Index out of range')&#13;
  }&#13;
  &#13;
  function writeFloat (buf, value, offset, littleEndian, noAssert) {&#13;
    if (!noAssert) {&#13;
      checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)&#13;
    }&#13;
    ieee754.write(buf, value, offset, littleEndian, 23, 4)&#13;
    return offset + 4&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {&#13;
    return writeFloat(this, value, offset, true, noAssert)&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {&#13;
    return writeFloat(this, value, offset, false, noAssert)&#13;
  }&#13;
  &#13;
  function writeDouble (buf, value, offset, littleEndian, noAssert) {&#13;
    if (!noAssert) {&#13;
      checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)&#13;
    }&#13;
    ieee754.write(buf, value, offset, littleEndian, 52, 8)&#13;
    return offset + 8&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {&#13;
    return writeDouble(this, value, offset, true, noAssert)&#13;
  }&#13;
  &#13;
  Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {&#13;
    return writeDouble(this, value, offset, false, noAssert)&#13;
  }&#13;
  &#13;
  Buffer.prototype.copy = function copy (target, targetStart, start, end) {&#13;
    if (!start) start = 0&#13;
    if (!end &amp;&amp; end !== 0) end = this.length&#13;
    if (targetStart &gt;= target.length) targetStart = target.length&#13;
    if (!targetStart) targetStart = 0&#13;
    if (end &gt; 0 &amp;&amp; end &lt; start) end = start&#13;
  &#13;
    if (end === start) return 0&#13;
    if (target.length === 0 || this.length === 0) return 0&#13;
  &#13;
    if (targetStart &lt; 0) {&#13;
      throw new RangeError('targetStart out of bounds')&#13;
    }&#13;
    if (start &lt; 0 || start &gt;= this.length) throw new RangeError('sourceStart out of bounds')&#13;
    if (end &lt; 0) throw new RangeError('sourceEnd out of bounds')&#13;
  &#13;
    if (end &gt; this.length) end = this.length&#13;
    if (target.length - targetStart &lt; end - start) {&#13;
      end = target.length - targetStart + start&#13;
    }&#13;
  &#13;
    var len = end - start&#13;
    var i&#13;
  &#13;
    if (this === target &amp;&amp; start &lt; targetStart &amp;&amp; targetStart &lt; end) {&#13;
      for (i = len - 1; i &gt;= 0; --i) {&#13;
        target[i + targetStart] = this[i + start]&#13;
      }&#13;
    } else if (len &lt; 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {&#13;
      for (i = 0; i &lt; len; ++i) {&#13;
        target[i + targetStart] = this[i + start]&#13;
      }&#13;
    } else {&#13;
      Uint8Array.prototype.set.call(&#13;
        target,&#13;
        this.subarray(start, start + len),&#13;
        targetStart&#13;
      )&#13;
    }&#13;
  &#13;
    return len&#13;
  }&#13;
  &#13;
  Buffer.prototype.fill = function fill (val, start, end, encoding) {&#13;
    if (typeof val === 'string') {&#13;
      if (typeof start === 'string') {&#13;
        encoding = start&#13;
        start = 0&#13;
        end = this.length&#13;
      } else if (typeof end === 'string') {&#13;
        encoding = end&#13;
        end = this.length&#13;
      }&#13;
      if (val.length === 1) {&#13;
        var code = val.charCodeAt(0)&#13;
        if (code &lt; 256) {&#13;
          val = code&#13;
        }&#13;
      }&#13;
      if (encoding !== undefined &amp;&amp; typeof encoding !== 'string') {&#13;
        throw new TypeError('encoding must be a string')&#13;
      }&#13;
      if (typeof encoding === 'string' &amp;&amp; !Buffer.isEncoding(encoding)) {&#13;
        throw new TypeError('Unknown encoding: ' + encoding)&#13;
      }&#13;
    } else if (typeof val === 'number') {&#13;
      val = val &amp; 255&#13;
    }&#13;
  &#13;
    if (start &lt; 0 || this.length &lt; start || this.length &lt; end) {&#13;
      throw new RangeError('Out of range index')&#13;
    }&#13;
  &#13;
    if (end &lt;= start) {&#13;
      return this&#13;
    }&#13;
  &#13;
    start = start &gt;&gt;&gt; 0&#13;
    end = end === undefined ? this.length : end &gt;&gt;&gt; 0&#13;
  &#13;
    if (!val) val = 0&#13;
  &#13;
    var i&#13;
    if (typeof val === 'number') {&#13;
      for (i = start; i &lt; end; ++i) {&#13;
        this[i] = val&#13;
      }&#13;
    } else {&#13;
      var bytes = Buffer.isBuffer(val)&#13;
        ? val&#13;
        : utf8ToBytes(new Buffer(val, encoding).toString())&#13;
      var len = bytes.length&#13;
      for (i = 0; i &lt; end - start; ++i) {&#13;
        this[i + start] = bytes[i % len]&#13;
      }&#13;
    }&#13;
  &#13;
    return this&#13;
  }&#13;
  &#13;
  &#13;
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g&#13;
  &#13;
  function base64clean (str) {&#13;
    str = stringtrim(str).replace(INVALID_BASE64_RE, '')&#13;
    if (str.length &lt; 2) return ''&#13;
    while (str.length % 4 !== 0) {&#13;
      str = str + '='&#13;
    }&#13;
    return str&#13;
  }&#13;
  &#13;
  function stringtrim (str) {&#13;
    if (str.trim) return str.trim()&#13;
    return str.replace(/^\s+|\s+$/g, '')&#13;
  }&#13;
  &#13;
  function toHex (n) {&#13;
    if (n &lt; 16) return '0' + n.toString(16)&#13;
    return n.toString(16)&#13;
  }&#13;
  &#13;
  function utf8ToBytes (string, units) {&#13;
    units = units || Infinity&#13;
    var codePoint&#13;
    var length = string.length&#13;
    var leadSurrogate = null&#13;
    var bytes = []&#13;
  &#13;
    for (var i = 0; i &lt; length; ++i) {&#13;
      codePoint = string.charCodeAt(i)&#13;
  &#13;
      if (codePoint &gt; 0xD7FF &amp;&amp; codePoint &lt; 0xE000) {&#13;
        if (!leadSurrogate) {&#13;
          if (codePoint &gt; 0xDBFF) {&#13;
            if ((units -= 3) &gt; -1) bytes.push(0xEF, 0xBF, 0xBD)&#13;
            continue&#13;
          } else if (i + 1 === length) {&#13;
            if ((units -= 3) &gt; -1) bytes.push(0xEF, 0xBF, 0xBD)&#13;
            continue&#13;
          }&#13;
  &#13;
          leadSurrogate = codePoint&#13;
  &#13;
          continue&#13;
        }&#13;
  &#13;
        if (codePoint &lt; 0xDC00) {&#13;
          if ((units -= 3) &gt; -1) bytes.push(0xEF, 0xBF, 0xBD)&#13;
          leadSurrogate = codePoint&#13;
          continue&#13;
        }&#13;
  &#13;
        codePoint = (leadSurrogate - 0xD800 &lt;&lt; 10 | codePoint - 0xDC00) + 0x10000&#13;
      } else if (leadSurrogate) {&#13;
        if ((units -= 3) &gt; -1) bytes.push(0xEF, 0xBF, 0xBD)&#13;
      }&#13;
  &#13;
      leadSurrogate = null&#13;
  &#13;
      if (codePoint &lt; 0x80) {&#13;
        if ((units -= 1) &lt; 0) break&#13;
        bytes.push(codePoint)&#13;
      } else if (codePoint &lt; 0x800) {&#13;
        if ((units -= 2) &lt; 0) break&#13;
        bytes.push(&#13;
          codePoint &gt;&gt; 0x6 | 0xC0,&#13;
          codePoint &amp; 0x3F | 0x80&#13;
        )&#13;
      } else if (codePoint &lt; 0x10000) {&#13;
        if ((units -= 3) &lt; 0) break&#13;
        bytes.push(&#13;
          codePoint &gt;&gt; 0xC | 0xE0,&#13;
          codePoint &gt;&gt; 0x6 &amp; 0x3F | 0x80,&#13;
          codePoint &amp; 0x3F | 0x80&#13;
        )&#13;
      } else if (codePoint &lt; 0x110000) {&#13;
        if ((units -= 4) &lt; 0) break&#13;
        bytes.push(&#13;
          codePoint &gt;&gt; 0x12 | 0xF0,&#13;
          codePoint &gt;&gt; 0xC &amp; 0x3F | 0x80,&#13;
          codePoint &gt;&gt; 0x6 &amp; 0x3F | 0x80,&#13;
          codePoint &amp; 0x3F | 0x80&#13;
        )&#13;
      } else {&#13;
        throw new Error('Invalid code point')&#13;
      }&#13;
    }&#13;
  &#13;
    return bytes&#13;
  }&#13;
  &#13;
  function asciiToBytes (str) {&#13;
    var byteArray = []&#13;
    for (var i = 0; i &lt; str.length; ++i) {&#13;
      byteArray.push(str.charCodeAt(i) &amp; 0xFF)&#13;
    }&#13;
    return byteArray&#13;
  }&#13;
  &#13;
  function utf16leToBytes (str, units) {&#13;
    var c, hi, lo&#13;
    var byteArray = []&#13;
    for (var i = 0; i &lt; str.length; ++i) {&#13;
      if ((units -= 2) &lt; 0) break&#13;
  &#13;
      c = str.charCodeAt(i)&#13;
      hi = c &gt;&gt; 8&#13;
      lo = c % 256&#13;
      byteArray.push(lo)&#13;
      byteArray.push(hi)&#13;
    }&#13;
  &#13;
    return byteArray&#13;
  }&#13;
  &#13;
  function base64ToBytes (str) {&#13;
    return base64.toByteArray(base64clean(str))&#13;
  }&#13;
  &#13;
  function blitBuffer (src, dst, offset, length) {&#13;
    for (var i = 0; i &lt; length; ++i) {&#13;
      if ((i + offset &gt;= dst.length) || (i &gt;= src.length)) break&#13;
      dst[i + offset] = src[i]&#13;
    }&#13;
    return i&#13;
  }&#13;
  &#13;
  function isnan (val) {&#13;
    return val !== val // eslint-disable-line no-self-compare&#13;
  }&#13;
  &#13;
  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})&#13;
  },{"base64-js":55,"ieee754":66,"isarray":67}],58:[function(require,module,exports){&#13;
  arguments[4][57][0].apply(exports,arguments)&#13;
  },{"base64-js":55,"dup":57,"ieee754":66,"isarray":67}],59:[function(require,module,exports){&#13;
  var Buffer = require('buffer').Buffer;&#13;
  var intSize = 4;&#13;
  var zeroBuffer = new Buffer(intSize); zeroBuffer.fill(0);&#13;
  var chrsz = 8;&#13;
  &#13;
  function toArray(buf, bigEndian) {&#13;
    if ((buf.length % intSize) !== 0) {&#13;
      var len = buf.length + (intSize - (buf.length % intSize));&#13;
      buf = Buffer.concat([buf, zeroBuffer], len);&#13;
    }&#13;
  &#13;
    var arr = [];&#13;
    var fn = bigEndian ? buf.readInt32BE : buf.readInt32LE;&#13;
    for (var i = 0; i &lt; buf.length; i += intSize) {&#13;
      arr.push(fn.call(buf, i));&#13;
    }&#13;
    return arr;&#13;
  }&#13;
  &#13;
  function toBuffer(arr, size, bigEndian) {&#13;
    var buf = new Buffer(size);&#13;
    var fn = bigEndian ? buf.writeInt32BE : buf.writeInt32LE;&#13;
    for (var i = 0; i &lt; arr.length; i++) {&#13;
      fn.call(buf, arr[i], i * 4, true);&#13;
    }&#13;
    return buf;&#13;
  }&#13;
  &#13;
  function hash(buf, fn, hashSize, bigEndian) {&#13;
    if (!Buffer.isBuffer(buf)) buf = new Buffer(buf);&#13;
    var arr = fn(toArray(buf, bigEndian), buf.length * chrsz);&#13;
    return toBuffer(arr, hashSize, bigEndian);&#13;
  }&#13;
  &#13;
  module.exports = { hash: hash };&#13;
  &#13;
  },{"buffer":57}],60:[function(require,module,exports){&#13;
  var Buffer = require('buffer').Buffer&#13;
  var sha = require('./sha')&#13;
  var sha256 = require('./sha256')&#13;
  var rng = require('./rng')&#13;
  var md5 = require('./md5')&#13;
  &#13;
  var algorithms = {&#13;
    sha1: sha,&#13;
    sha256: sha256,&#13;
    md5: md5&#13;
  }&#13;
  &#13;
  var blocksize = 64&#13;
  var zeroBuffer = new Buffer(blocksize); zeroBuffer.fill(0)&#13;
  function hmac(fn, key, data) {&#13;
    if(!Buffer.isBuffer(key)) key = new Buffer(key)&#13;
    if(!Buffer.isBuffer(data)) data = new Buffer(data)&#13;
  &#13;
    if(key.length &gt; blocksize) {&#13;
      key = fn(key)&#13;
    } else if(key.length &lt; blocksize) {&#13;
      key = Buffer.concat([key, zeroBuffer], blocksize)&#13;
    }&#13;
  &#13;
    var ipad = new Buffer(blocksize), opad = new Buffer(blocksize)&#13;
    for(var i = 0; i &lt; blocksize; i++) {&#13;
      ipad[i] = key[i] ^ 0x36&#13;
      opad[i] = key[i] ^ 0x5C&#13;
    }&#13;
  &#13;
    var hash = fn(Buffer.concat([ipad, data]))&#13;
    return fn(Buffer.concat([opad, hash]))&#13;
  }&#13;
  &#13;
  function hash(alg, key) {&#13;
    alg = alg || 'sha1'&#13;
    var fn = algorithms[alg]&#13;
    var bufs = []&#13;
    var length = 0&#13;
    if(!fn) error('algorithm:', alg, 'is not yet supported')&#13;
    return {&#13;
      update: function (data) {&#13;
        if(!Buffer.isBuffer(data)) data = new Buffer(data)&#13;
          &#13;
        bufs.push(data)&#13;
        length += data.length&#13;
        return this&#13;
      },&#13;
      digest: function (enc) {&#13;
        var buf = Buffer.concat(bufs)&#13;
        var r = key ? hmac(fn, key, buf) : fn(buf)&#13;
        bufs = null&#13;
        return enc ? r.toString(enc) : r&#13;
      }&#13;
    }&#13;
  }&#13;
  &#13;
  function error () {&#13;
    var m = [].slice.call(arguments).join(' ')&#13;
    throw new Error([&#13;
      m,&#13;
      'we accept pull requests',&#13;
      'http://github.com/dominictarr/crypto-browserify'&#13;
      ].join('\n'))&#13;
  }&#13;
  &#13;
  exports.createHash = function (alg) { return hash(alg) }&#13;
  exports.createHmac = function (alg, key) { return hash(alg, key) }&#13;
  exports.randomBytes = function(size, callback) {&#13;
    if (callback &amp;&amp; callback.call) {&#13;
      try {&#13;
        callback.call(this, undefined, new Buffer(rng(size)))&#13;
      } catch (err) { callback(err) }&#13;
    } else {&#13;
      return new Buffer(rng(size))&#13;
    }&#13;
  }&#13;
  &#13;
  function each(a, f) {&#13;
    for(var i in a)&#13;
      f(a[i], i)&#13;
  }&#13;
  &#13;
  each(['createCredentials'&#13;
  , 'createCipher'&#13;
  , 'createCipheriv'&#13;
  , 'createDecipher'&#13;
  , 'createDecipheriv'&#13;
  , 'createSign'&#13;
  , 'createVerify'&#13;
  , 'createDiffieHellman'&#13;
  , 'pbkdf2'], function (name) {&#13;
    exports[name] = function () {&#13;
      error('sorry,', name, 'is not implemented yet')&#13;
    }&#13;
  })&#13;
  &#13;
  },{"./md5":61,"./rng":62,"./sha":63,"./sha256":64,"buffer":57}],61:[function(require,module,exports){&#13;
  &#13;
  &#13;
  var helpers = require('./helpers');&#13;
  &#13;
  &#13;
  function md5_vm_test()&#13;
  {&#13;
    return hex_md5("abc") == "900150983cd24fb0d6963f7d28e17f72";&#13;
  }&#13;
  &#13;
  &#13;
  function core_md5(x, len)&#13;
  {&#13;
  &#13;
    x[len &gt;&gt; 5] |= 0x80 &lt;&lt; ((len) % 32);&#13;
    x[(((len + 64) &gt;&gt;&gt; 9) &lt;&lt; 4) + 14] = len;&#13;
  &#13;
    var a =  1732584193;&#13;
    var b = -271733879;&#13;
    var c = -1732584194;&#13;
    var d =  271733878;&#13;
  &#13;
    for(var i = 0; i &lt; x.length; i += 16)&#13;
    {&#13;
      var olda = a;&#13;
      var oldb = b;&#13;
      var oldc = c;&#13;
      var oldd = d;&#13;
  &#13;
      a = md5_ff(a, b, c, d, x[i+ 0], 7 , -680876936);&#13;
      d = md5_ff(d, a, b, c, x[i+ 1], 12, -389564586);&#13;
      c = md5_ff(c, d, a, b, x[i+ 2], 17,  606105819);&#13;
      b = md5_ff(b, c, d, a, x[i+ 3], 22, -1044525330);&#13;
      a = md5_ff(a, b, c, d, x[i+ 4], 7 , -176418897);&#13;
      d = md5_ff(d, a, b, c, x[i+ 5], 12,  1200080426);&#13;
      c = md5_ff(c, d, a, b, x[i+ 6], 17, -1473231341);&#13;
      b = md5_ff(b, c, d, a, x[i+ 7], 22, -45705983);&#13;
      a = md5_ff(a, b, c, d, x[i+ 8], 7 ,  1770035416);&#13;
      d = md5_ff(d, a, b, c, x[i+ 9], 12, -1958414417);&#13;
      c = md5_ff(c, d, a, b, x[i+10], 17, -42063);&#13;
      b = md5_ff(b, c, d, a, x[i+11], 22, -1990404162);&#13;
      a = md5_ff(a, b, c, d, x[i+12], 7 ,  1804603682);&#13;
      d = md5_ff(d, a, b, c, x[i+13], 12, -40341101);&#13;
      c = md5_ff(c, d, a, b, x[i+14], 17, -1502002290);&#13;
      b = md5_ff(b, c, d, a, x[i+15], 22,  1236535329);&#13;
  &#13;
      a = md5_gg(a, b, c, d, x[i+ 1], 5 , -165796510);&#13;
      d = md5_gg(d, a, b, c, x[i+ 6], 9 , -1069501632);&#13;
      c = md5_gg(c, d, a, b, x[i+11], 14,  643717713);&#13;
      b = md5_gg(b, c, d, a, x[i+ 0], 20, -373897302);&#13;
      a = md5_gg(a, b, c, d, x[i+ 5], 5 , -701558691);&#13;
      d = md5_gg(d, a, b, c, x[i+10], 9 ,  38016083);&#13;
      c = md5_gg(c, d, a, b, x[i+15], 14, -660478335);&#13;
      b = md5_gg(b, c, d, a, x[i+ 4], 20, -405537848);&#13;
      a = md5_gg(a, b, c, d, x[i+ 9], 5 ,  568446438);&#13;
      d = md5_gg(d, a, b, c, x[i+14], 9 , -1019803690);&#13;
      c = md5_gg(c, d, a, b, x[i+ 3], 14, -187363961);&#13;
      b = md5_gg(b, c, d, a, x[i+ 8], 20,  1163531501);&#13;
      a = md5_gg(a, b, c, d, x[i+13], 5 , -1444681467);&#13;
      d = md5_gg(d, a, b, c, x[i+ 2], 9 , -51403784);&#13;
      c = md5_gg(c, d, a, b, x[i+ 7], 14,  1735328473);&#13;
      b = md5_gg(b, c, d, a, x[i+12], 20, -1926607734);&#13;
  &#13;
      a = md5_hh(a, b, c, d, x[i+ 5], 4 , -378558);&#13;
      d = md5_hh(d, a, b, c, x[i+ 8], 11, -2022574463);&#13;
      c = md5_hh(c, d, a, b, x[i+11], 16,  1839030562);&#13;
      b = md5_hh(b, c, d, a, x[i+14], 23, -35309556);&#13;
      a = md5_hh(a, b, c, d, x[i+ 1], 4 , -1530992060);&#13;
      d = md5_hh(d, a, b, c, x[i+ 4], 11,  1272893353);&#13;
      c = md5_hh(c, d, a, b, x[i+ 7], 16, -155497632);&#13;
      b = md5_hh(b, c, d, a, x[i+10], 23, -1094730640);&#13;
      a = md5_hh(a, b, c, d, x[i+13], 4 ,  681279174);&#13;
      d = md5_hh(d, a, b, c, x[i+ 0], 11, -358537222);&#13;
      c = md5_hh(c, d, a, b, x[i+ 3], 16, -722521979);&#13;
      b = md5_hh(b, c, d, a, x[i+ 6], 23,  76029189);&#13;
      a = md5_hh(a, b, c, d, x[i+ 9], 4 , -640364487);&#13;
      d = md5_hh(d, a, b, c, x[i+12], 11, -421815835);&#13;
      c = md5_hh(c, d, a, b, x[i+15], 16,  530742520);&#13;
      b = md5_hh(b, c, d, a, x[i+ 2], 23, -995338651);&#13;
  &#13;
      a = md5_ii(a, b, c, d, x[i+ 0], 6 , -198630844);&#13;
      d = md5_ii(d, a, b, c, x[i+ 7], 10,  1126891415);&#13;
      c = md5_ii(c, d, a, b, x[i+14], 15, -1416354905);&#13;
      b = md5_ii(b, c, d, a, x[i+ 5], 21, -57434055);&#13;
      a = md5_ii(a, b, c, d, x[i+12], 6 ,  1700485571);&#13;
      d = md5_ii(d, a, b, c, x[i+ 3], 10, -1894986606);&#13;
      c = md5_ii(c, d, a, b, x[i+10], 15, -1051523);&#13;
      b = md5_ii(b, c, d, a, x[i+ 1], 21, -2054922799);&#13;
      a = md5_ii(a, b, c, d, x[i+ 8], 6 ,  1873313359);&#13;
      d = md5_ii(d, a, b, c, x[i+15], 10, -30611744);&#13;
      c = md5_ii(c, d, a, b, x[i+ 6], 15, -1560198380);&#13;
      b = md5_ii(b, c, d, a, x[i+13], 21,  1309151649);&#13;
      a = md5_ii(a, b, c, d, x[i+ 4], 6 , -145523070);&#13;
      d = md5_ii(d, a, b, c, x[i+11], 10, -1120210379);&#13;
      c = md5_ii(c, d, a, b, x[i+ 2], 15,  718787259);&#13;
      b = md5_ii(b, c, d, a, x[i+ 9], 21, -343485551);&#13;
  &#13;
      a = safe_add(a, olda);&#13;
      b = safe_add(b, oldb);&#13;
      c = safe_add(c, oldc);&#13;
      d = safe_add(d, oldd);&#13;
    }&#13;
    return Array(a, b, c, d);&#13;
  &#13;
  }&#13;
  &#13;
  &#13;
  function md5_cmn(q, a, b, x, s, t)&#13;
  {&#13;
    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s),b);&#13;
  }&#13;
  function md5_ff(a, b, c, d, x, s, t)&#13;
  {&#13;
    return md5_cmn((b &amp; c) | ((~b) &amp; d), a, b, x, s, t);&#13;
  }&#13;
  function md5_gg(a, b, c, d, x, s, t)&#13;
  {&#13;
    return md5_cmn((b &amp; d) | (c &amp; (~d)), a, b, x, s, t);&#13;
  }&#13;
  function md5_hh(a, b, c, d, x, s, t)&#13;
  {&#13;
    return md5_cmn(b ^ c ^ d, a, b, x, s, t);&#13;
  }&#13;
  function md5_ii(a, b, c, d, x, s, t)&#13;
  {&#13;
    return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);&#13;
  }&#13;
  &#13;
  &#13;
  function safe_add(x, y)&#13;
  {&#13;
    var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);&#13;
    var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);&#13;
    return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);&#13;
  }&#13;
  &#13;
  &#13;
  function bit_rol(num, cnt)&#13;
  {&#13;
    return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));&#13;
  }&#13;
  &#13;
  module.exports = function md5(buf) {&#13;
    return helpers.hash(buf, core_md5, 16);&#13;
  };&#13;
  &#13;
  },{"./helpers":59}],62:[function(require,module,exports){&#13;
  (function() {&#13;
    var _global = this;&#13;
  &#13;
    var mathRNG, whatwgRNG;&#13;
  &#13;
    mathRNG = function(size) {&#13;
      var bytes = new Array(size);&#13;
      var r;&#13;
  &#13;
      for (var i = 0, r; i &lt; size; i++) {&#13;
        if ((i &amp; 0x03) == 0) r = Math.random() * 0x100000000;&#13;
        bytes[i] = r &gt;&gt;&gt; ((i &amp; 0x03) &lt;&lt; 3) &amp; 0xff;&#13;
      }&#13;
  &#13;
      return bytes;&#13;
    }&#13;
  &#13;
    if (_global.crypto &amp;&amp; crypto.getRandomValues) {&#13;
      whatwgRNG = function(size) {&#13;
        var bytes = new Uint8Array(size);&#13;
        crypto.getRandomValues(bytes);&#13;
        return bytes;&#13;
      }&#13;
    }&#13;
  &#13;
    module.exports = whatwgRNG || mathRNG;&#13;
  &#13;
  }())&#13;
  &#13;
  },{}],63:[function(require,module,exports){&#13;
  &#13;
  &#13;
  var helpers = require('./helpers');&#13;
  &#13;
  &#13;
  function core_sha1(x, len)&#13;
  {&#13;
  &#13;
    x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32);&#13;
    x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len;&#13;
  &#13;
    var w = Array(80);&#13;
    var a =  1732584193;&#13;
    var b = -271733879;&#13;
    var c = -1732584194;&#13;
    var d =  271733878;&#13;
    var e = -1009589776;&#13;
  &#13;
    for(var i = 0; i &lt; x.length; i += 16)&#13;
    {&#13;
      var olda = a;&#13;
      var oldb = b;&#13;
      var oldc = c;&#13;
      var oldd = d;&#13;
      var olde = e;&#13;
  &#13;
      for(var j = 0; j &lt; 80; j++)&#13;
      {&#13;
        if(j &lt; 16) w[j] = x[i + j];&#13;
        else w[j] = rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);&#13;
        var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)),&#13;
                         safe_add(safe_add(e, w[j]), sha1_kt(j)));&#13;
        e = d;&#13;
        d = c;&#13;
        c = rol(b, 30);&#13;
        b = a;&#13;
        a = t;&#13;
      }&#13;
  &#13;
      a = safe_add(a, olda);&#13;
      b = safe_add(b, oldb);&#13;
      c = safe_add(c, oldc);&#13;
      d = safe_add(d, oldd);&#13;
      e = safe_add(e, olde);&#13;
    }&#13;
    return Array(a, b, c, d, e);&#13;
  &#13;
  }&#13;
  &#13;
  &#13;
  function sha1_ft(t, b, c, d)&#13;
  {&#13;
    if(t &lt; 20) return (b &amp; c) | ((~b) &amp; d);&#13;
    if(t &lt; 40) return b ^ c ^ d;&#13;
    if(t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d);&#13;
    return b ^ c ^ d;&#13;
  }&#13;
  &#13;
  &#13;
  function sha1_kt(t)&#13;
  {&#13;
    return (t &lt; 20) ?  1518500249 : (t &lt; 40) ?  1859775393 :&#13;
           (t &lt; 60) ? -1894007588 : -899497514;&#13;
  }&#13;
  &#13;
  &#13;
  function safe_add(x, y)&#13;
  {&#13;
    var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);&#13;
    var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);&#13;
    return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);&#13;
  }&#13;
  &#13;
  &#13;
  function rol(num, cnt)&#13;
  {&#13;
    return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt));&#13;
  }&#13;
  &#13;
  module.exports = function sha1(buf) {&#13;
    return helpers.hash(buf, core_sha1, 20, true);&#13;
  };&#13;
  &#13;
  },{"./helpers":59}],64:[function(require,module,exports){&#13;
  &#13;
  &#13;
  &#13;
  var helpers = require('./helpers');&#13;
  &#13;
  var safe_add = function(x, y) {&#13;
    var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF);&#13;
    var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16);&#13;
    return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF);&#13;
  };&#13;
  &#13;
  var S = function(X, n) {&#13;
    return (X &gt;&gt;&gt; n) | (X &lt;&lt; (32 - n));&#13;
  };&#13;
  &#13;
  var R = function(X, n) {&#13;
    return (X &gt;&gt;&gt; n);&#13;
  };&#13;
  &#13;
  var Ch = function(x, y, z) {&#13;
    return ((x &amp; y) ^ ((~x) &amp; z));&#13;
  };&#13;
  &#13;
  var Maj = function(x, y, z) {&#13;
    return ((x &amp; y) ^ (x &amp; z) ^ (y &amp; z));&#13;
  };&#13;
  &#13;
  var Sigma0256 = function(x) {&#13;
    return (S(x, 2) ^ S(x, 13) ^ S(x, 22));&#13;
  };&#13;
  &#13;
  var Sigma1256 = function(x) {&#13;
    return (S(x, 6) ^ S(x, 11) ^ S(x, 25));&#13;
  };&#13;
  &#13;
  var Gamma0256 = function(x) {&#13;
    return (S(x, 7) ^ S(x, 18) ^ R(x, 3));&#13;
  };&#13;
  &#13;
  var Gamma1256 = function(x) {&#13;
    return (S(x, 17) ^ S(x, 19) ^ R(x, 10));&#13;
  };&#13;
  &#13;
  var core_sha256 = function(m, l) {&#13;
    var K = new Array(0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,0xE49B69C1,0xEFBE4786,0xFC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x6CA6351,0x14292967,0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2);&#13;
    var HASH = new Array(0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A, 0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19);&#13;
      var W = new Array(64);&#13;
      var a, b, c, d, e, f, g, h, i, j;&#13;
      var T1, T2;&#13;
  &#13;
    m[l &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - l % 32);&#13;
    m[((l + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = l;&#13;
    for (var i = 0; i &lt; m.length; i += 16) {&#13;
      a = HASH[0]; b = HASH[1]; c = HASH[2]; d = HASH[3]; e = HASH[4]; f = HASH[5]; g = HASH[6]; h = HASH[7];&#13;
      for (var j = 0; j &lt; 64; j++) {&#13;
        if (j &lt; 16) {&#13;
          W[j] = m[j + i];&#13;
        } else {&#13;
          W[j] = safe_add(safe_add(safe_add(Gamma1256(W[j - 2]), W[j - 7]), Gamma0256(W[j - 15])), W[j - 16]);&#13;
        }&#13;
        T1 = safe_add(safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]), W[j]);&#13;
        T2 = safe_add(Sigma0256(a), Maj(a, b, c));&#13;
        h = g; g = f; f = e; e = safe_add(d, T1); d = c; c = b; b = a; a = safe_add(T1, T2);&#13;
      }&#13;
      HASH[0] = safe_add(a, HASH[0]); HASH[1] = safe_add(b, HASH[1]); HASH[2] = safe_add(c, HASH[2]); HASH[3] = safe_add(d, HASH[3]);&#13;
      HASH[4] = safe_add(e, HASH[4]); HASH[5] = safe_add(f, HASH[5]); HASH[6] = safe_add(g, HASH[6]); HASH[7] = safe_add(h, HASH[7]);&#13;
    }&#13;
    return HASH;&#13;
  };&#13;
  &#13;
  module.exports = function sha256(buf) {&#13;
    return helpers.hash(buf, core_sha256, 32, true);&#13;
  };&#13;
  &#13;
  },{"./helpers":59}],65:[function(require,module,exports){&#13;
  &#13;
  function EventEmitter() {&#13;
    this._events = this._events || {};&#13;
    this._maxListeners = this._maxListeners || undefined;&#13;
  }&#13;
  module.exports = EventEmitter;&#13;
  &#13;
  EventEmitter.EventEmitter = EventEmitter;&#13;
  &#13;
  EventEmitter.prototype._events = undefined;&#13;
  EventEmitter.prototype._maxListeners = undefined;&#13;
  &#13;
  EventEmitter.defaultMaxListeners = 10;&#13;
  &#13;
  EventEmitter.prototype.setMaxListeners = function(n) {&#13;
    if (!isNumber(n) || n &lt; 0 || isNaN(n))&#13;
      throw TypeError('n must be a positive number');&#13;
    this._maxListeners = n;&#13;
    return this;&#13;
  };&#13;
  &#13;
  EventEmitter.prototype.emit = function(type) {&#13;
    var er, handler, len, args, i, listeners;&#13;
  &#13;
    if (!this._events)&#13;
      this._events = {};&#13;
  &#13;
    if (type === 'error') {&#13;
      if (!this._events.error ||&#13;
          (isObject(this._events.error) &amp;&amp; !this._events.error.length)) {&#13;
        er = arguments[1];&#13;
        if (er instanceof Error) {&#13;
          throw er; // Unhandled 'error' event&#13;
        } else {&#13;
          var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');&#13;
          err.context = er;&#13;
          throw err;&#13;
        }&#13;
      }&#13;
    }&#13;
  &#13;
    handler = this._events[type];&#13;
  &#13;
    if (isUndefined(handler))&#13;
      return false;&#13;
  &#13;
    if (isFunction(handler)) {&#13;
      switch (arguments.length) {&#13;
        case 1:&#13;
          handler.call(this);&#13;
          break;&#13;
        case 2:&#13;
          handler.call(this, arguments[1]);&#13;
          break;&#13;
        case 3:&#13;
          handler.call(this, arguments[1], arguments[2]);&#13;
          break;&#13;
        default:&#13;
          args = Array.prototype.slice.call(arguments, 1);&#13;
          handler.apply(this, args);&#13;
      }&#13;
    } else if (isObject(handler)) {&#13;
      args = Array.prototype.slice.call(arguments, 1);&#13;
      listeners = handler.slice();&#13;
      len = listeners.length;&#13;
      for (i = 0; i &lt; len; i++)&#13;
        listeners[i].apply(this, args);&#13;
    }&#13;
  &#13;
    return true;&#13;
  };&#13;
  &#13;
  EventEmitter.prototype.addListener = function(type, listener) {&#13;
    var m;&#13;
  &#13;
    if (!isFunction(listener))&#13;
      throw TypeError('listener must be a function');&#13;
  &#13;
    if (!this._events)&#13;
      this._events = {};&#13;
  &#13;
    if (this._events.newListener)&#13;
      this.emit('newListener', type,&#13;
                isFunction(listener.listener) ?&#13;
                listener.listener : listener);&#13;
  &#13;
    if (!this._events[type])&#13;
      this._events[type] = listener;&#13;
    else if (isObject(this._events[type]))&#13;
      this._events[type].push(listener);&#13;
    else&#13;
      this._events[type] = [this._events[type], listener];&#13;
  &#13;
    if (isObject(this._events[type]) &amp;&amp; !this._events[type].warned) {&#13;
      if (!isUndefined(this._maxListeners)) {&#13;
        m = this._maxListeners;&#13;
      } else {&#13;
        m = EventEmitter.defaultMaxListeners;&#13;
      }&#13;
  &#13;
      if (m &amp;&amp; m &gt; 0 &amp;&amp; this._events[type].length &gt; m) {&#13;
        this._events[type].warned = true;&#13;
        console.error('(node) warning: possible EventEmitter memory ' +&#13;
                      'leak detected. %d listeners added. ' +&#13;
                      'Use emitter.setMaxListeners() to increase limit.',&#13;
                      this._events[type].length);&#13;
        if (typeof console.trace === 'function') {&#13;
          console.trace();&#13;
        }&#13;
      }&#13;
    }&#13;
  &#13;
    return this;&#13;
  };&#13;
  &#13;
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;&#13;
  &#13;
  EventEmitter.prototype.once = function(type, listener) {&#13;
    if (!isFunction(listener))&#13;
      throw TypeError('listener must be a function');&#13;
  &#13;
    var fired = false;&#13;
  &#13;
    function g() {&#13;
      this.removeListener(type, g);&#13;
  &#13;
      if (!fired) {&#13;
        fired = true;&#13;
        listener.apply(this, arguments);&#13;
      }&#13;
    }&#13;
  &#13;
    g.listener = listener;&#13;
    this.on(type, g);&#13;
  &#13;
    return this;&#13;
  };&#13;
  &#13;
  EventEmitter.prototype.removeListener = function(type, listener) {&#13;
    var list, position, length, i;&#13;
  &#13;
    if (!isFunction(listener))&#13;
      throw TypeError('listener must be a function');&#13;
  &#13;
    if (!this._events || !this._events[type])&#13;
      return this;&#13;
  &#13;
    list = this._events[type];&#13;
    length = list.length;&#13;
    position = -1;&#13;
  &#13;
    if (list === listener ||&#13;
        (isFunction(list.listener) &amp;&amp; list.listener === listener)) {&#13;
      delete this._events[type];&#13;
      if (this._events.removeListener)&#13;
        this.emit('removeListener', type, listener);&#13;
  &#13;
    } else if (isObject(list)) {&#13;
      for (i = length; i-- &gt; 0;) {&#13;
        if (list[i] === listener ||&#13;
            (list[i].listener &amp;&amp; list[i].listener === listener)) {&#13;
          position = i;&#13;
          break;&#13;
        }&#13;
      }&#13;
  &#13;
      if (position &lt; 0)&#13;
        return this;&#13;
  &#13;
      if (list.length === 1) {&#13;
        list.length = 0;&#13;
        delete this._events[type];&#13;
      } else {&#13;
        list.splice(position, 1);&#13;
      }&#13;
  &#13;
      if (this._events.removeListener)&#13;
        this.emit('removeListener', type, listener);&#13;
    }&#13;
  &#13;
    return this;&#13;
  };&#13;
  &#13;
  EventEmitter.prototype.removeAllListeners = function(type) {&#13;
    var key, listeners;&#13;
  &#13;
    if (!this._events)&#13;
      return this;&#13;
  &#13;
    if (!this._events.removeListener) {&#13;
      if (arguments.length === 0)&#13;
        this._events = {};&#13;
      else if (this._events[type])&#13;
        delete this._events[type];&#13;
      return this;&#13;
    }&#13;
  &#13;
    if (arguments.length === 0) {&#13;
      for (key in this._events) {&#13;
        if (key === 'removeListener') continue;&#13;
        this.removeAllListeners(key);&#13;
      }&#13;
      this.removeAllListeners('removeListener');&#13;
      this._events = {};&#13;
      return this;&#13;
    }&#13;
  &#13;
    listeners = this._events[type];&#13;
  &#13;
    if (isFunction(listeners)) {&#13;
      this.removeListener(type, listeners);&#13;
    } else if (listeners) {&#13;
      while (listeners.length)&#13;
        this.removeListener(type, listeners[listeners.length - 1]);&#13;
    }&#13;
    delete this._events[type];&#13;
  &#13;
    return this;&#13;
  };&#13;
  &#13;
  EventEmitter.prototype.listeners = function(type) {&#13;
    var ret;&#13;
    if (!this._events || !this._events[type])&#13;
      ret = [];&#13;
    else if (isFunction(this._events[type]))&#13;
      ret = [this._events[type]];&#13;
    else&#13;
      ret = this._events[type].slice();&#13;
    return ret;&#13;
  };&#13;
  &#13;
  EventEmitter.prototype.listenerCount = function(type) {&#13;
    if (this._events) {&#13;
      var evlistener = this._events[type];&#13;
  &#13;
      if (isFunction(evlistener))&#13;
        return 1;&#13;
      else if (evlistener)&#13;
        return evlistener.length;&#13;
    }&#13;
    return 0;&#13;
  };&#13;
  &#13;
  EventEmitter.listenerCount = function(emitter, type) {&#13;
    return emitter.listenerCount(type);&#13;
  };&#13;
  &#13;
  function isFunction(arg) {&#13;
    return typeof arg === 'function';&#13;
  }&#13;
  &#13;
  function isNumber(arg) {&#13;
    return typeof arg === 'number';&#13;
  }&#13;
  &#13;
  function isObject(arg) {&#13;
    return typeof arg === 'object' &amp;&amp; arg !== null;&#13;
  }&#13;
  &#13;
  function isUndefined(arg) {&#13;
    return arg === void 0;&#13;
  }&#13;
  &#13;
  },{}],66:[function(require,module,exports){&#13;
  exports.read = function (buffer, offset, isLE, mLen, nBytes) {&#13;
    var e, m&#13;
    var eLen = nBytes * 8 - mLen - 1&#13;
    var eMax = (1 &lt;&lt; eLen) - 1&#13;
    var eBias = eMax &gt;&gt; 1&#13;
    var nBits = -7&#13;
    var i = isLE ? (nBytes - 1) : 0&#13;
    var d = isLE ? -1 : 1&#13;
    var s = buffer[offset + i]&#13;
  &#13;
    i += d&#13;
  &#13;
    e = s &amp; ((1 &lt;&lt; (-nBits)) - 1)&#13;
    s &gt;&gt;= (-nBits)&#13;
    nBits += eLen&#13;
    for (; nBits &gt; 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}&#13;
  &#13;
    m = e &amp; ((1 &lt;&lt; (-nBits)) - 1)&#13;
    e &gt;&gt;= (-nBits)&#13;
    nBits += mLen&#13;
    for (; nBits &gt; 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}&#13;
  &#13;
    if (e === 0) {&#13;
      e = 1 - eBias&#13;
    } else if (e === eMax) {&#13;
      return m ? NaN : ((s ? -1 : 1) * Infinity)&#13;
    } else {&#13;
      m = m + Math.pow(2, mLen)&#13;
      e = e - eBias&#13;
    }&#13;
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen)&#13;
  }&#13;
  &#13;
  exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {&#13;
    var e, m, c&#13;
    var eLen = nBytes * 8 - mLen - 1&#13;
    var eMax = (1 &lt;&lt; eLen) - 1&#13;
    var eBias = eMax &gt;&gt; 1&#13;
    var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)&#13;
    var i = isLE ? 0 : (nBytes - 1)&#13;
    var d = isLE ? 1 : -1&#13;
    var s = value &lt; 0 || (value === 0 &amp;&amp; 1 / value &lt; 0) ? 1 : 0&#13;
  &#13;
    value = Math.abs(value)&#13;
  &#13;
    if (isNaN(value) || value === Infinity) {&#13;
      m = isNaN(value) ? 1 : 0&#13;
      e = eMax&#13;
    } else {&#13;
      e = Math.floor(Math.log(value) / Math.LN2)&#13;
      if (value * (c = Math.pow(2, -e)) &lt; 1) {&#13;
        e--&#13;
        c *= 2&#13;
      }&#13;
      if (e + eBias &gt;= 1) {&#13;
        value += rt / c&#13;
      } else {&#13;
        value += rt * Math.pow(2, 1 - eBias)&#13;
      }&#13;
      if (value * c &gt;= 2) {&#13;
        e++&#13;
        c /= 2&#13;
      }&#13;
  &#13;
      if (e + eBias &gt;= eMax) {&#13;
        m = 0&#13;
        e = eMax&#13;
      } else if (e + eBias &gt;= 1) {&#13;
        m = (value * c - 1) * Math.pow(2, mLen)&#13;
        e = e + eBias&#13;
      } else {&#13;
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)&#13;
        e = 0&#13;
      }&#13;
    }&#13;
  &#13;
    for (; mLen &gt;= 8; buffer[offset + i] = m &amp; 0xff, i += d, m /= 256, mLen -= 8) {}&#13;
  &#13;
    e = (e &lt;&lt; mLen) | m&#13;
    eLen += mLen&#13;
    for (; eLen &gt; 0; buffer[offset + i] = e &amp; 0xff, i += d, e /= 256, eLen -= 8) {}&#13;
  &#13;
    buffer[offset + i - d] |= s * 128&#13;
  }&#13;
  &#13;
  },{}],67:[function(require,module,exports){&#13;
  var toString = {}.toString;&#13;
  &#13;
  module.exports = Array.isArray || function (arr) {&#13;
    return toString.call(arr) == '[object Array]';&#13;
  };&#13;
  &#13;
  },{}],68:[function(require,module,exports){&#13;
  (function(exports) {&#13;
    "use strict";&#13;
  &#13;
    function isArray(obj) {&#13;
      if (obj !== null) {&#13;
        return Object.prototype.toString.call(obj) === "[object Array]";&#13;
      } else {&#13;
        return false;&#13;
      }&#13;
    }&#13;
  &#13;
    function isObject(obj) {&#13;
      if (obj !== null) {&#13;
        return Object.prototype.toString.call(obj) === "[object Object]";&#13;
      } else {&#13;
        return false;&#13;
      }&#13;
    }&#13;
  &#13;
    function strictDeepEqual(first, second) {&#13;
      if (first === second) {&#13;
        return true;&#13;
      }&#13;
  &#13;
      var firstType = Object.prototype.toString.call(first);&#13;
      if (firstType !== Object.prototype.toString.call(second)) {&#13;
        return false;&#13;
      }&#13;
      if (isArray(first) === true) {&#13;
        if (first.length !== second.length) {&#13;
          return false;&#13;
        }&#13;
        for (var i = 0; i &lt; first.length; i++) {&#13;
          if (strictDeepEqual(first[i], second[i]) === false) {&#13;
            return false;&#13;
          }&#13;
        }&#13;
        return true;&#13;
      }&#13;
      if (isObject(first) === true) {&#13;
        var keysSeen = {};&#13;
        for (var key in first) {&#13;
          if (hasOwnProperty.call(first, key)) {&#13;
            if (strictDeepEqual(first[key], second[key]) === false) {&#13;
              return false;&#13;
            }&#13;
            keysSeen[key] = true;&#13;
          }&#13;
        }&#13;
        for (var key2 in second) {&#13;
          if (hasOwnProperty.call(second, key2)) {&#13;
            if (keysSeen[key2] !== true) {&#13;
              return false;&#13;
            }&#13;
          }&#13;
        }&#13;
        return true;&#13;
      }&#13;
      return false;&#13;
    }&#13;
  &#13;
    function isFalse(obj) {&#13;
  &#13;
      if (obj === "" || obj === false || obj === null) {&#13;
          return true;&#13;
      } else if (isArray(obj) &amp;&amp; obj.length === 0) {&#13;
          return true;&#13;
      } else if (isObject(obj)) {&#13;
          for (var key in obj) {&#13;
              if (obj.hasOwnProperty(key)) {&#13;
                return false;&#13;
              }&#13;
          }&#13;
          return true;&#13;
      } else {&#13;
          return false;&#13;
      }&#13;
    }&#13;
  &#13;
    function objValues(obj) {&#13;
      var keys = Object.keys(obj);&#13;
      var values = [];&#13;
      for (var i = 0; i &lt; keys.length; i++) {&#13;
        values.push(obj[keys[i]]);&#13;
      }&#13;
      return values;&#13;
    }&#13;
  &#13;
    function merge(a, b) {&#13;
        var merged = {};&#13;
        for (var key in a) {&#13;
            merged[key] = a[key];&#13;
        }&#13;
        for (var key2 in b) {&#13;
            merged[key2] = b[key2];&#13;
        }&#13;
        return merged;&#13;
    }&#13;
  &#13;
    var trimLeft;&#13;
    if (typeof String.prototype.trimLeft === "function") {&#13;
      trimLeft = function(str) {&#13;
        return str.trimLeft();&#13;
      };&#13;
    } else {&#13;
      trimLeft = function(str) {&#13;
        return str.match(/^\s*(.*)/)[1];&#13;
      };&#13;
    }&#13;
  &#13;
    var TYPE_NUMBER = 0;&#13;
    var TYPE_ANY = 1;&#13;
    var TYPE_STRING = 2;&#13;
    var TYPE_ARRAY = 3;&#13;
    var TYPE_OBJECT = 4;&#13;
    var TYPE_BOOLEAN = 5;&#13;
    var TYPE_EXPREF = 6;&#13;
    var TYPE_NULL = 7;&#13;
    var TYPE_ARRAY_NUMBER = 8;&#13;
    var TYPE_ARRAY_STRING = 9;&#13;
  &#13;
    var TOK_EOF = "EOF";&#13;
    var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";&#13;
    var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";&#13;
    var TOK_RBRACKET = "Rbracket";&#13;
    var TOK_RPAREN = "Rparen";&#13;
    var TOK_COMMA = "Comma";&#13;
    var TOK_COLON = "Colon";&#13;
    var TOK_RBRACE = "Rbrace";&#13;
    var TOK_NUMBER = "Number";&#13;
    var TOK_CURRENT = "Current";&#13;
    var TOK_EXPREF = "Expref";&#13;
    var TOK_PIPE = "Pipe";&#13;
    var TOK_OR = "Or";&#13;
    var TOK_AND = "And";&#13;
    var TOK_EQ = "EQ";&#13;
    var TOK_GT = "GT";&#13;
    var TOK_LT = "LT";&#13;
    var TOK_GTE = "GTE";&#13;
    var TOK_LTE = "LTE";&#13;
    var TOK_NE = "NE";&#13;
    var TOK_FLATTEN = "Flatten";&#13;
    var TOK_STAR = "Star";&#13;
    var TOK_FILTER = "Filter";&#13;
    var TOK_DOT = "Dot";&#13;
    var TOK_NOT = "Not";&#13;
    var TOK_LBRACE = "Lbrace";&#13;
    var TOK_LBRACKET = "Lbracket";&#13;
    var TOK_LPAREN= "Lparen";&#13;
    var TOK_LITERAL= "Literal";&#13;
  &#13;
  &#13;
    var basicTokens = {&#13;
      ".": TOK_DOT,&#13;
      "*": TOK_STAR,&#13;
      ",": TOK_COMMA,&#13;
      ":": TOK_COLON,&#13;
      "{": TOK_LBRACE,&#13;
      "}": TOK_RBRACE,&#13;
      "]": TOK_RBRACKET,&#13;
      "(": TOK_LPAREN,&#13;
      ")": TOK_RPAREN,&#13;
      "@": TOK_CURRENT&#13;
    };&#13;
  &#13;
    var operatorStartToken = {&#13;
        "&lt;": true,&#13;
        "&gt;": true,&#13;
        "=": true,&#13;
        "!": true&#13;
    };&#13;
  &#13;
    var skipChars = {&#13;
        " ": true,&#13;
        "\t": true,&#13;
        "\n": true&#13;
    };&#13;
  &#13;
  &#13;
    function isAlpha(ch) {&#13;
        return (ch &gt;= "a" &amp;&amp; ch &lt;= "z") ||&#13;
               (ch &gt;= "A" &amp;&amp; ch &lt;= "Z") ||&#13;
               ch === "_";&#13;
    }&#13;
  &#13;
    function isNum(ch) {&#13;
        return (ch &gt;= "0" &amp;&amp; ch &lt;= "9") ||&#13;
               ch === "-";&#13;
    }&#13;
    function isAlphaNum(ch) {&#13;
        return (ch &gt;= "a" &amp;&amp; ch &lt;= "z") ||&#13;
               (ch &gt;= "A" &amp;&amp; ch &lt;= "Z") ||&#13;
               (ch &gt;= "0" &amp;&amp; ch &lt;= "9") ||&#13;
               ch === "_";&#13;
    }&#13;
  &#13;
    function Lexer() {&#13;
    }&#13;
    Lexer.prototype = {&#13;
        tokenize: function(stream) {&#13;
            var tokens = [];&#13;
            this._current = 0;&#13;
            var start;&#13;
            var identifier;&#13;
            var token;&#13;
            while (this._current &lt; stream.length) {&#13;
                if (isAlpha(stream[this._current])) {&#13;
                    start = this._current;&#13;
                    identifier = this._consumeUnquotedIdentifier(stream);&#13;
                    tokens.push({type: TOK_UNQUOTEDIDENTIFIER,&#13;
                                 value: identifier,&#13;
                                 start: start});&#13;
                } else if (basicTokens[stream[this._current]] !== undefined) {&#13;
                    tokens.push({type: basicTokens[stream[this._current]],&#13;
                                value: stream[this._current],&#13;
                                start: this._current});&#13;
                    this._current++;&#13;
                } else if (isNum(stream[this._current])) {&#13;
                    token = this._consumeNumber(stream);&#13;
                    tokens.push(token);&#13;
                } else if (stream[this._current] === "[") {&#13;
                    token = this._consumeLBracket(stream);&#13;
                    tokens.push(token);&#13;
                } else if (stream[this._current] === "\"") {&#13;
                    start = this._current;&#13;
                    identifier = this._consumeQuotedIdentifier(stream);&#13;
                    tokens.push({type: TOK_QUOTEDIDENTIFIER,&#13;
                                 value: identifier,&#13;
                                 start: start});&#13;
                } else if (stream[this._current] === "'") {&#13;
                    start = this._current;&#13;
                    identifier = this._consumeRawStringLiteral(stream);&#13;
                    tokens.push({type: TOK_LITERAL,&#13;
                                 value: identifier,&#13;
                                 start: start});&#13;
                } else if (stream[this._current] === "`") {&#13;
                    start = this._current;&#13;
                    var literal = this._consumeLiteral(stream);&#13;
                    tokens.push({type: TOK_LITERAL,&#13;
                                 value: literal,&#13;
                                 start: start});&#13;
                } else if (operatorStartToken[stream[this._current]] !== undefined) {&#13;
                    tokens.push(this._consumeOperator(stream));&#13;
                } else if (skipChars[stream[this._current]] !== undefined) {&#13;
                    this._current++;&#13;
                } else if (stream[this._current] === "&amp;") {&#13;
                    start = this._current;&#13;
                    this._current++;&#13;
                    if (stream[this._current] === "&amp;") {&#13;
                        this._current++;&#13;
                        tokens.push({type: TOK_AND, value: "&amp;&amp;", start: start});&#13;
                    } else {&#13;
                        tokens.push({type: TOK_EXPREF, value: "&amp;", start: start});&#13;
                    }&#13;
                } else if (stream[this._current] === "|") {&#13;
                    start = this._current;&#13;
                    this._current++;&#13;
                    if (stream[this._current] === "|") {&#13;
                        this._current++;&#13;
                        tokens.push({type: TOK_OR, value: "||", start: start});&#13;
                    } else {&#13;
                        tokens.push({type: TOK_PIPE, value: "|", start: start});&#13;
                    }&#13;
                } else {&#13;
                    var error = new Error("Unknown character:" + stream[this._current]);&#13;
                    error.name = "LexerError";&#13;
                    throw error;&#13;
                }&#13;
            }&#13;
            return tokens;&#13;
        },&#13;
  &#13;
        _consumeUnquotedIdentifier: function(stream) {&#13;
            var start = this._current;&#13;
            this._current++;&#13;
            while (this._current &lt; stream.length &amp;&amp; isAlphaNum(stream[this._current])) {&#13;
                this._current++;&#13;
            }&#13;
            return stream.slice(start, this._current);&#13;
        },&#13;
  &#13;
        _consumeQuotedIdentifier: function(stream) {&#13;
            var start = this._current;&#13;
            this._current++;&#13;
            var maxLength = stream.length;&#13;
            while (stream[this._current] !== "\"" &amp;&amp; this._current &lt; maxLength) {&#13;
                var current = this._current;&#13;
                if (stream[current] === "\\" &amp;&amp; (stream[current + 1] === "\\" ||&#13;
                                                 stream[current + 1] === "\"")) {&#13;
                    current += 2;&#13;
                } else {&#13;
                    current++;&#13;
                }&#13;
                this._current = current;&#13;
            }&#13;
            this._current++;&#13;
            return JSON.parse(stream.slice(start, this._current));&#13;
        },&#13;
  &#13;
        _consumeRawStringLiteral: function(stream) {&#13;
            var start = this._current;&#13;
            this._current++;&#13;
            var maxLength = stream.length;&#13;
            while (stream[this._current] !== "'" &amp;&amp; this._current &lt; maxLength) {&#13;
                var current = this._current;&#13;
                if (stream[current] === "\\" &amp;&amp; (stream[current + 1] === "\\" ||&#13;
                                                 stream[current + 1] === "'")) {&#13;
                    current += 2;&#13;
                } else {&#13;
                    current++;&#13;
                }&#13;
                this._current = current;&#13;
            }&#13;
            this._current++;&#13;
            var literal = stream.slice(start + 1, this._current - 1);&#13;
            return literal.replace("\\'", "'");&#13;
        },&#13;
  &#13;
        _consumeNumber: function(stream) {&#13;
            var start = this._current;&#13;
            this._current++;&#13;
            var maxLength = stream.length;&#13;
            while (isNum(stream[this._current]) &amp;&amp; this._current &lt; maxLength) {&#13;
                this._current++;&#13;
            }&#13;
            var value = parseInt(stream.slice(start, this._current));&#13;
            return {type: TOK_NUMBER, value: value, start: start};&#13;
        },&#13;
  &#13;
        _consumeLBracket: function(stream) {&#13;
            var start = this._current;&#13;
            this._current++;&#13;
            if (stream[this._current] === "?") {&#13;
                this._current++;&#13;
                return {type: TOK_FILTER, value: "[?", start: start};&#13;
            } else if (stream[this._current] === "]") {&#13;
                this._current++;&#13;
                return {type: TOK_FLATTEN, value: "[]", start: start};&#13;
            } else {&#13;
                return {type: TOK_LBRACKET, value: "[", start: start};&#13;
            }&#13;
        },&#13;
  &#13;
        _consumeOperator: function(stream) {&#13;
            var start = this._current;&#13;
            var startingChar = stream[start];&#13;
            this._current++;&#13;
            if (startingChar === "!") {&#13;
                if (stream[this._current] === "=") {&#13;
                    this._current++;&#13;
                    return {type: TOK_NE, value: "!=", start: start};&#13;
                } else {&#13;
                  return {type: TOK_NOT, value: "!", start: start};&#13;
                }&#13;
            } else if (startingChar === "&lt;") {&#13;
                if (stream[this._current] === "=") {&#13;
                    this._current++;&#13;
                    return {type: TOK_LTE, value: "&lt;=", start: start};&#13;
                } else {&#13;
                    return {type: TOK_LT, value: "&lt;", start: start};&#13;
                }&#13;
            } else if (startingChar === "&gt;") {&#13;
                if (stream[this._current] === "=") {&#13;
                    this._current++;&#13;
                    return {type: TOK_GTE, value: "&gt;=", start: start};&#13;
                } else {&#13;
                    return {type: TOK_GT, value: "&gt;", start: start};&#13;
                }&#13;
            } else if (startingChar === "=") {&#13;
                if (stream[this._current] === "=") {&#13;
                    this._current++;&#13;
                    return {type: TOK_EQ, value: "==", start: start};&#13;
                }&#13;
            }&#13;
        },&#13;
  &#13;
        _consumeLiteral: function(stream) {&#13;
            this._current++;&#13;
            var start = this._current;&#13;
            var maxLength = stream.length;&#13;
            var literal;&#13;
            while(stream[this._current] !== "`" &amp;&amp; this._current &lt; maxLength) {&#13;
                var current = this._current;&#13;
                if (stream[current] === "\\" &amp;&amp; (stream[current + 1] === "\\" ||&#13;
                                                 stream[current + 1] === "`")) {&#13;
                    current += 2;&#13;
                } else {&#13;
                    current++;&#13;
                }&#13;
                this._current = current;&#13;
            }&#13;
            var literalString = trimLeft(stream.slice(start, this._current));&#13;
            literalString = literalString.replace("\\`", "`");&#13;
            if (this._looksLikeJSON(literalString)) {&#13;
                literal = JSON.parse(literalString);&#13;
            } else {&#13;
                literal = JSON.parse("\"" + literalString + "\"");&#13;
            }&#13;
            this._current++;&#13;
            return literal;&#13;
        },&#13;
  &#13;
        _looksLikeJSON: function(literalString) {&#13;
            var startingChars = "[{\"";&#13;
            var jsonLiterals = ["true", "false", "null"];&#13;
            var numberLooking = "-0123456789";&#13;
  &#13;
            if (literalString === "") {&#13;
                return false;&#13;
            } else if (startingChars.indexOf(literalString[0]) &gt;= 0) {&#13;
                return true;&#13;
            } else if (jsonLiterals.indexOf(literalString) &gt;= 0) {&#13;
                return true;&#13;
            } else if (numberLooking.indexOf(literalString[0]) &gt;= 0) {&#13;
                try {&#13;
                    JSON.parse(literalString);&#13;
                    return true;&#13;
                } catch (ex) {&#13;
                    return false;&#13;
                }&#13;
            } else {&#13;
                return false;&#13;
            }&#13;
        }&#13;
    };&#13;
  &#13;
        var bindingPower = {};&#13;
        bindingPower[TOK_EOF] = 0;&#13;
        bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;&#13;
        bindingPower[TOK_QUOTEDIDENTIFIER] = 0;&#13;
        bindingPower[TOK_RBRACKET] = 0;&#13;
        bindingPower[TOK_RPAREN] = 0;&#13;
        bindingPower[TOK_COMMA] = 0;&#13;
        bindingPower[TOK_RBRACE] = 0;&#13;
        bindingPower[TOK_NUMBER] = 0;&#13;
        bindingPower[TOK_CURRENT] = 0;&#13;
        bindingPower[TOK_EXPREF] = 0;&#13;
        bindingPower[TOK_PIPE] = 1;&#13;
        bindingPower[TOK_OR] = 2;&#13;
        bindingPower[TOK_AND] = 3;&#13;
        bindingPower[TOK_EQ] = 5;&#13;
        bindingPower[TOK_GT] = 5;&#13;
        bindingPower[TOK_LT] = 5;&#13;
        bindingPower[TOK_GTE] = 5;&#13;
        bindingPower[TOK_LTE] = 5;&#13;
        bindingPower[TOK_NE] = 5;&#13;
        bindingPower[TOK_FLATTEN] = 9;&#13;
        bindingPower[TOK_STAR] = 20;&#13;
        bindingPower[TOK_FILTER] = 21;&#13;
        bindingPower[TOK_DOT] = 40;&#13;
        bindingPower[TOK_NOT] = 45;&#13;
        bindingPower[TOK_LBRACE] = 50;&#13;
        bindingPower[TOK_LBRACKET] = 55;&#13;
        bindingPower[TOK_LPAREN] = 60;&#13;
  &#13;
    function Parser() {&#13;
    }&#13;
  &#13;
    Parser.prototype = {&#13;
        parse: function(expression) {&#13;
            this._loadTokens(expression);&#13;
            this.index = 0;&#13;
            var ast = this.expression(0);&#13;
            if (this._lookahead(0) !== TOK_EOF) {&#13;
                var t = this._lookaheadToken(0);&#13;
                var error = new Error(&#13;
                    "Unexpected token type: " + t.type + ", value: " + t.value);&#13;
                error.name = "ParserError";&#13;
                throw error;&#13;
            }&#13;
            return ast;&#13;
        },&#13;
  &#13;
        _loadTokens: function(expression) {&#13;
            var lexer = new Lexer();&#13;
            var tokens = lexer.tokenize(expression);&#13;
            tokens.push({type: TOK_EOF, value: "", start: expression.length});&#13;
            this.tokens = tokens;&#13;
        },&#13;
  &#13;
        expression: function(rbp) {&#13;
            var leftToken = this._lookaheadToken(0);&#13;
            this._advance();&#13;
            var left = this.nud(leftToken);&#13;
            var currentToken = this._lookahead(0);&#13;
            while (rbp &lt; bindingPower[currentToken]) {&#13;
                this._advance();&#13;
                left = this.led(currentToken, left);&#13;
                currentToken = this._lookahead(0);&#13;
            }&#13;
            return left;&#13;
        },&#13;
  &#13;
        _lookahead: function(number) {&#13;
            return this.tokens[this.index + number].type;&#13;
        },&#13;
  &#13;
        _lookaheadToken: function(number) {&#13;
            return this.tokens[this.index + number];&#13;
        },&#13;
  &#13;
        _advance: function() {&#13;
            this.index++;&#13;
        },&#13;
  &#13;
        nud: function(token) {&#13;
          var left;&#13;
          var right;&#13;
          var expression;&#13;
          switch (token.type) {&#13;
            case TOK_LITERAL:&#13;
              return {type: "Literal", value: token.value};&#13;
            case TOK_UNQUOTEDIDENTIFIER:&#13;
              return {type: "Field", name: token.value};&#13;
            case TOK_QUOTEDIDENTIFIER:&#13;
              var node = {type: "Field", name: token.value};&#13;
              if (this._lookahead(0) === TOK_LPAREN) {&#13;
                  throw new Error("Quoted identifier not allowed for function names.");&#13;
              } else {&#13;
                  return node;&#13;
              }&#13;
              break;&#13;
            case TOK_NOT:&#13;
              right = this.expression(bindingPower.Not);&#13;
              return {type: "NotExpression", children: [right]};&#13;
            case TOK_STAR:&#13;
              left = {type: "Identity"};&#13;
              right = null;&#13;
              if (this._lookahead(0) === TOK_RBRACKET) {&#13;
                  right = {type: "Identity"};&#13;
              } else {&#13;
                  right = this._parseProjectionRHS(bindingPower.Star);&#13;
              }&#13;
              return {type: "ValueProjection", children: [left, right]};&#13;
            case TOK_FILTER:&#13;
              return this.led(token.type, {type: "Identity"});&#13;
            case TOK_LBRACE:&#13;
              return this._parseMultiselectHash();&#13;
            case TOK_FLATTEN:&#13;
              left = {type: TOK_FLATTEN, children: [{type: "Identity"}]};&#13;
              right = this._parseProjectionRHS(bindingPower.Flatten);&#13;
              return {type: "Projection", children: [left, right]};&#13;
            case TOK_LBRACKET:&#13;
              if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {&#13;
                  right = this._parseIndexExpression();&#13;
                  return this._projectIfSlice({type: "Identity"}, right);&#13;
              } else if (this._lookahead(0) === TOK_STAR &amp;&amp;&#13;
                         this._lookahead(1) === TOK_RBRACKET) {&#13;
                  this._advance();&#13;
                  this._advance();&#13;
                  right = this._parseProjectionRHS(bindingPower.Star);&#13;
                  return {type: "Projection",&#13;
                          children: [{type: "Identity"}, right]};&#13;
              } else {&#13;
                  return this._parseMultiselectList();&#13;
              }&#13;
              break;&#13;
            case TOK_CURRENT:&#13;
              return {type: TOK_CURRENT};&#13;
            case TOK_EXPREF:&#13;
              expression = this.expression(bindingPower.Expref);&#13;
              return {type: "ExpressionReference", children: [expression]};&#13;
            case TOK_LPAREN:&#13;
              var args = [];&#13;
              while (this._lookahead(0) !== TOK_RPAREN) {&#13;
                if (this._lookahead(0) === TOK_CURRENT) {&#13;
                  expression = {type: TOK_CURRENT};&#13;
                  this._advance();&#13;
                } else {&#13;
                  expression = this.expression(0);&#13;
                }&#13;
                args.push(expression);&#13;
              }&#13;
              this._match(TOK_RPAREN);&#13;
              return args[0];&#13;
            default:&#13;
              this._errorToken(token);&#13;
          }&#13;
        },&#13;
  &#13;
        led: function(tokenName, left) {&#13;
          var right;&#13;
          switch(tokenName) {&#13;
            case TOK_DOT:&#13;
              var rbp = bindingPower.Dot;&#13;
              if (this._lookahead(0) !== TOK_STAR) {&#13;
                  right = this._parseDotRHS(rbp);&#13;
                  return {type: "Subexpression", children: [left, right]};&#13;
              } else {&#13;
                  this._advance();&#13;
                  right = this._parseProjectionRHS(rbp);&#13;
                  return {type: "ValueProjection", children: [left, right]};&#13;
              }&#13;
              break;&#13;
            case TOK_PIPE:&#13;
              right = this.expression(bindingPower.Pipe);&#13;
              return {type: TOK_PIPE, children: [left, right]};&#13;
            case TOK_OR:&#13;
              right = this.expression(bindingPower.Or);&#13;
              return {type: "OrExpression", children: [left, right]};&#13;
            case TOK_AND:&#13;
              right = this.expression(bindingPower.And);&#13;
              return {type: "AndExpression", children: [left, right]};&#13;
            case TOK_LPAREN:&#13;
              var name = left.name;&#13;
              var args = [];&#13;
              var expression, node;&#13;
              while (this._lookahead(0) !== TOK_RPAREN) {&#13;
                if (this._lookahead(0) === TOK_CURRENT) {&#13;
                  expression = {type: TOK_CURRENT};&#13;
                  this._advance();&#13;
                } else {&#13;
                  expression = this.expression(0);&#13;
                }&#13;
                if (this._lookahead(0) === TOK_COMMA) {&#13;
                  this._match(TOK_COMMA);&#13;
                }&#13;
                args.push(expression);&#13;
              }&#13;
              this._match(TOK_RPAREN);&#13;
              node = {type: "Function", name: name, children: args};&#13;
              return node;&#13;
            case TOK_FILTER:&#13;
              var condition = this.expression(0);&#13;
              this._match(TOK_RBRACKET);&#13;
              if (this._lookahead(0) === TOK_FLATTEN) {&#13;
                right = {type: "Identity"};&#13;
              } else {&#13;
                right = this._parseProjectionRHS(bindingPower.Filter);&#13;
              }&#13;
              return {type: "FilterProjection", children: [left, right, condition]};&#13;
            case TOK_FLATTEN:&#13;
              var leftNode = {type: TOK_FLATTEN, children: [left]};&#13;
              var rightNode = this._parseProjectionRHS(bindingPower.Flatten);&#13;
              return {type: "Projection", children: [leftNode, rightNode]};&#13;
            case TOK_EQ:&#13;
            case TOK_NE:&#13;
            case TOK_GT:&#13;
            case TOK_GTE:&#13;
            case TOK_LT:&#13;
            case TOK_LTE:&#13;
              return this._parseComparator(left, tokenName);&#13;
            case TOK_LBRACKET:&#13;
              var token = this._lookaheadToken(0);&#13;
              if (token.type === TOK_NUMBER || token.type === TOK_COLON) {&#13;
                  right = this._parseIndexExpression();&#13;
                  return this._projectIfSlice(left, right);&#13;
              } else {&#13;
                  this._match(TOK_STAR);&#13;
                  this._match(TOK_RBRACKET);&#13;
                  right = this._parseProjectionRHS(bindingPower.Star);&#13;
                  return {type: "Projection", children: [left, right]};&#13;
              }&#13;
              break;&#13;
            default:&#13;
              this._errorToken(this._lookaheadToken(0));&#13;
          }&#13;
        },&#13;
  &#13;
        _match: function(tokenType) {&#13;
            if (this._lookahead(0) === tokenType) {&#13;
                this._advance();&#13;
            } else {&#13;
                var t = this._lookaheadToken(0);&#13;
                var error = new Error("Expected " + tokenType + ", got: " + t.type);&#13;
                error.name = "ParserError";&#13;
                throw error;&#13;
            }&#13;
        },&#13;
  &#13;
        _errorToken: function(token) {&#13;
            var error = new Error("Invalid token (" +&#13;
                                  token.type + "): \"" +&#13;
                                  token.value + "\"");&#13;
            error.name = "ParserError";&#13;
            throw error;&#13;
        },&#13;
  &#13;
  &#13;
        _parseIndexExpression: function() {&#13;
            if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {&#13;
                return this._parseSliceExpression();&#13;
            } else {&#13;
                var node = {&#13;
                    type: "Index",&#13;
                    value: this._lookaheadToken(0).value};&#13;
                this._advance();&#13;
                this._match(TOK_RBRACKET);&#13;
                return node;&#13;
            }&#13;
        },&#13;
  &#13;
        _projectIfSlice: function(left, right) {&#13;
            var indexExpr = {type: "IndexExpression", children: [left, right]};&#13;
            if (right.type === "Slice") {&#13;
                return {&#13;
                    type: "Projection",&#13;
                    children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]&#13;
                };&#13;
            } else {&#13;
                return indexExpr;&#13;
            }&#13;
        },&#13;
  &#13;
        _parseSliceExpression: function() {&#13;
            var parts = [null, null, null];&#13;
            var index = 0;&#13;
            var currentToken = this._lookahead(0);&#13;
            while (currentToken !== TOK_RBRACKET &amp;&amp; index &lt; 3) {&#13;
                if (currentToken === TOK_COLON) {&#13;
                    index++;&#13;
                    this._advance();&#13;
                } else if (currentToken === TOK_NUMBER) {&#13;
                    parts[index] = this._lookaheadToken(0).value;&#13;
                    this._advance();&#13;
                } else {&#13;
                    var t = this._lookahead(0);&#13;
                    var error = new Error("Syntax error, unexpected token: " +&#13;
                                          t.value + "(" + t.type + ")");&#13;
                    error.name = "Parsererror";&#13;
                    throw error;&#13;
                }&#13;
                currentToken = this._lookahead(0);&#13;
            }&#13;
            this._match(TOK_RBRACKET);&#13;
            return {&#13;
                type: "Slice",&#13;
                children: parts&#13;
            };&#13;
        },&#13;
  &#13;
        _parseComparator: function(left, comparator) {&#13;
          var right = this.expression(bindingPower[comparator]);&#13;
          return {type: "Comparator", name: comparator, children: [left, right]};&#13;
        },&#13;
  &#13;
        _parseDotRHS: function(rbp) {&#13;
            var lookahead = this._lookahead(0);&#13;
            var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];&#13;
            if (exprTokens.indexOf(lookahead) &gt;= 0) {&#13;
                return this.expression(rbp);&#13;
            } else if (lookahead === TOK_LBRACKET) {&#13;
                this._match(TOK_LBRACKET);&#13;
                return this._parseMultiselectList();&#13;
            } else if (lookahead === TOK_LBRACE) {&#13;
                this._match(TOK_LBRACE);&#13;
                return this._parseMultiselectHash();&#13;
            }&#13;
        },&#13;
  &#13;
        _parseProjectionRHS: function(rbp) {&#13;
            var right;&#13;
            if (bindingPower[this._lookahead(0)] &lt; 10) {&#13;
                right = {type: "Identity"};&#13;
            } else if (this._lookahead(0) === TOK_LBRACKET) {&#13;
                right = this.expression(rbp);&#13;
            } else if (this._lookahead(0) === TOK_FILTER) {&#13;
                right = this.expression(rbp);&#13;
            } else if (this._lookahead(0) === TOK_DOT) {&#13;
                this._match(TOK_DOT);&#13;
                right = this._parseDotRHS(rbp);&#13;
            } else {&#13;
                var t = this._lookaheadToken(0);&#13;
                var error = new Error("Sytanx error, unexpected token: " +&#13;
                                      t.value + "(" + t.type + ")");&#13;
                error.name = "ParserError";&#13;
                throw error;&#13;
            }&#13;
            return right;&#13;
        },&#13;
  &#13;
        _parseMultiselectList: function() {&#13;
            var expressions = [];&#13;
            while (this._lookahead(0) !== TOK_RBRACKET) {&#13;
                var expression = this.expression(0);&#13;
                expressions.push(expression);&#13;
                if (this._lookahead(0) === TOK_COMMA) {&#13;
                    this._match(TOK_COMMA);&#13;
                    if (this._lookahead(0) === TOK_RBRACKET) {&#13;
                      throw new Error("Unexpected token Rbracket");&#13;
                    }&#13;
                }&#13;
            }&#13;
            this._match(TOK_RBRACKET);&#13;
            return {type: "MultiSelectList", children: expressions};&#13;
        },&#13;
  &#13;
        _parseMultiselectHash: function() {&#13;
          var pairs = [];&#13;
          var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];&#13;
          var keyToken, keyName, value, node;&#13;
          for (;;) {&#13;
            keyToken = this._lookaheadToken(0);&#13;
            if (identifierTypes.indexOf(keyToken.type) &lt; 0) {&#13;
              throw new Error("Expecting an identifier token, got: " +&#13;
                              keyToken.type);&#13;
            }&#13;
            keyName = keyToken.value;&#13;
            this._advance();&#13;
            this._match(TOK_COLON);&#13;
            value = this.expression(0);&#13;
            node = {type: "KeyValuePair", name: keyName, value: value};&#13;
            pairs.push(node);&#13;
            if (this._lookahead(0) === TOK_COMMA) {&#13;
              this._match(TOK_COMMA);&#13;
            } else if (this._lookahead(0) === TOK_RBRACE) {&#13;
              this._match(TOK_RBRACE);&#13;
              break;&#13;
            }&#13;
          }&#13;
          return {type: "MultiSelectHash", children: pairs};&#13;
        }&#13;
    };&#13;
  &#13;
  &#13;
    function TreeInterpreter(runtime) {&#13;
      this.runtime = runtime;&#13;
    }&#13;
  &#13;
    TreeInterpreter.prototype = {&#13;
        search: function(node, value) {&#13;
            return this.visit(node, value);&#13;
        },&#13;
  &#13;
        visit: function(node, value) {&#13;
            var matched, current, result, first, second, field, left, right, collected, i;&#13;
            switch (node.type) {&#13;
              case "Field":&#13;
                if (value === null ) {&#13;
                    return null;&#13;
                } else if (isObject(value)) {&#13;
                    field = value[node.name];&#13;
                    if (field === undefined) {&#13;
                        return null;&#13;
                    } else {&#13;
                        return field;&#13;
                    }&#13;
                } else {&#13;
                  return null;&#13;
                }&#13;
                break;&#13;
              case "Subexpression":&#13;
                result = this.visit(node.children[0], value);&#13;
                for (i = 1; i &lt; node.children.length; i++) {&#13;
                    result = this.visit(node.children[1], result);&#13;
                    if (result === null) {&#13;
                        return null;&#13;
                    }&#13;
                }&#13;
                return result;&#13;
              case "IndexExpression":&#13;
                left = this.visit(node.children[0], value);&#13;
                right = this.visit(node.children[1], left);&#13;
                return right;&#13;
              case "Index":&#13;
                if (!isArray(value)) {&#13;
                  return null;&#13;
                }&#13;
                var index = node.value;&#13;
                if (index &lt; 0) {&#13;
                  index = value.length + index;&#13;
                }&#13;
                result = value[index];&#13;
                if (result === undefined) {&#13;
                  result = null;&#13;
                }&#13;
                return result;&#13;
              case "Slice":&#13;
                if (!isArray(value)) {&#13;
                  return null;&#13;
                }&#13;
                var sliceParams = node.children.slice(0);&#13;
                var computed = this.computeSliceParams(value.length, sliceParams);&#13;
                var start = computed[0];&#13;
                var stop = computed[1];&#13;
                var step = computed[2];&#13;
                result = [];&#13;
                if (step &gt; 0) {&#13;
                    for (i = start; i &lt; stop; i += step) {&#13;
                        result.push(value[i]);&#13;
                    }&#13;
                } else {&#13;
                    for (i = start; i &gt; stop; i += step) {&#13;
                        result.push(value[i]);&#13;
                    }&#13;
                }&#13;
                return result;&#13;
              case "Projection":&#13;
                var base = this.visit(node.children[0], value);&#13;
                if (!isArray(base)) {&#13;
                  return null;&#13;
                }&#13;
                collected = [];&#13;
                for (i = 0; i &lt; base.length; i++) {&#13;
                  current = this.visit(node.children[1], base[i]);&#13;
                  if (current !== null) {&#13;
                    collected.push(current);&#13;
                  }&#13;
                }&#13;
                return collected;&#13;
              case "ValueProjection":&#13;
                base = this.visit(node.children[0], value);&#13;
                if (!isObject(base)) {&#13;
                  return null;&#13;
                }&#13;
                collected = [];&#13;
                var values = objValues(base);&#13;
                for (i = 0; i &lt; values.length; i++) {&#13;
                  current = this.visit(node.children[1], values[i]);&#13;
                  if (current !== null) {&#13;
                    collected.push(current);&#13;
                  }&#13;
                }&#13;
                return collected;&#13;
              case "FilterProjection":&#13;
                base = this.visit(node.children[0], value);&#13;
                if (!isArray(base)) {&#13;
                  return null;&#13;
                }&#13;
                var filtered = [];&#13;
                var finalResults = [];&#13;
                for (i = 0; i &lt; base.length; i++) {&#13;
                  matched = this.visit(node.children[2], base[i]);&#13;
                  if (!isFalse(matched)) {&#13;
                    filtered.push(base[i]);&#13;
                  }&#13;
                }&#13;
                for (var j = 0; j &lt; filtered.length; j++) {&#13;
                  current = this.visit(node.children[1], filtered[j]);&#13;
                  if (current !== null) {&#13;
                    finalResults.push(current);&#13;
                  }&#13;
                }&#13;
                return finalResults;&#13;
              case "Comparator":&#13;
                first = this.visit(node.children[0], value);&#13;
                second = this.visit(node.children[1], value);&#13;
                switch(node.name) {&#13;
                  case TOK_EQ:&#13;
                    result = strictDeepEqual(first, second);&#13;
                    break;&#13;
                  case TOK_NE:&#13;
                    result = !strictDeepEqual(first, second);&#13;
                    break;&#13;
                  case TOK_GT:&#13;
                    result = first &gt; second;&#13;
                    break;&#13;
                  case TOK_GTE:&#13;
                    result = first &gt;= second;&#13;
                    break;&#13;
                  case TOK_LT:&#13;
                    result = first &lt; second;&#13;
                    break;&#13;
                  case TOK_LTE:&#13;
                    result = first &lt;= second;&#13;
                    break;&#13;
                  default:&#13;
                    throw new Error("Unknown comparator: " + node.name);&#13;
                }&#13;
                return result;&#13;
              case TOK_FLATTEN:&#13;
                var original = this.visit(node.children[0], value);&#13;
                if (!isArray(original)) {&#13;
                  return null;&#13;
                }&#13;
                var merged = [];&#13;
                for (i = 0; i &lt; original.length; i++) {&#13;
                  current = original[i];&#13;
                  if (isArray(current)) {&#13;
                    merged.push.apply(merged, current);&#13;
                  } else {&#13;
                    merged.push(current);&#13;
                  }&#13;
                }&#13;
                return merged;&#13;
              case "Identity":&#13;
                return value;&#13;
              case "MultiSelectList":&#13;
                if (value === null) {&#13;
                  return null;&#13;
                }&#13;
                collected = [];&#13;
                for (i = 0; i &lt; node.children.length; i++) {&#13;
                    collected.push(this.visit(node.children[i], value));&#13;
                }&#13;
                return collected;&#13;
              case "MultiSelectHash":&#13;
                if (value === null) {&#13;
                  return null;&#13;
                }&#13;
                collected = {};&#13;
                var child;&#13;
                for (i = 0; i &lt; node.children.length; i++) {&#13;
                  child = node.children[i];&#13;
                  collected[child.name] = this.visit(child.value, value);&#13;
                }&#13;
                return collected;&#13;
              case "OrExpression":&#13;
                matched = this.visit(node.children[0], value);&#13;
                if (isFalse(matched)) {&#13;
                    matched = this.visit(node.children[1], value);&#13;
                }&#13;
                return matched;&#13;
              case "AndExpression":&#13;
                first = this.visit(node.children[0], value);&#13;
  &#13;
                if (isFalse(first) === true) {&#13;
                  return first;&#13;
                }&#13;
                return this.visit(node.children[1], value);&#13;
              case "NotExpression":&#13;
                first = this.visit(node.children[0], value);&#13;
                return isFalse(first);&#13;
              case "Literal":&#13;
                return node.value;&#13;
              case TOK_PIPE:&#13;
                left = this.visit(node.children[0], value);&#13;
                return this.visit(node.children[1], left);&#13;
              case TOK_CURRENT:&#13;
                return value;&#13;
              case "Function":&#13;
                var resolvedArgs = [];&#13;
                for (i = 0; i &lt; node.children.length; i++) {&#13;
                    resolvedArgs.push(this.visit(node.children[i], value));&#13;
                }&#13;
                return this.runtime.callFunction(node.name, resolvedArgs);&#13;
              case "ExpressionReference":&#13;
                var refNode = node.children[0];&#13;
                refNode.jmespathType = TOK_EXPREF;&#13;
                return refNode;&#13;
              default:&#13;
                throw new Error("Unknown node type: " + node.type);&#13;
            }&#13;
        },&#13;
  &#13;
        computeSliceParams: function(arrayLength, sliceParams) {&#13;
          var start = sliceParams[0];&#13;
          var stop = sliceParams[1];&#13;
          var step = sliceParams[2];&#13;
          var computed = [null, null, null];&#13;
          if (step === null) {&#13;
            step = 1;&#13;
          } else if (step === 0) {&#13;
            var error = new Error("Invalid slice, step cannot be 0");&#13;
            error.name = "RuntimeError";&#13;
            throw error;&#13;
          }&#13;
          var stepValueNegative = step &lt; 0 ? true : false;&#13;
  &#13;
          if (start === null) {&#13;
              start = stepValueNegative ? arrayLength - 1 : 0;&#13;
          } else {&#13;
              start = this.capSliceRange(arrayLength, start, step);&#13;
          }&#13;
  &#13;
          if (stop === null) {&#13;
              stop = stepValueNegative ? -1 : arrayLength;&#13;
          } else {&#13;
              stop = this.capSliceRange(arrayLength, stop, step);&#13;
          }&#13;
          computed[0] = start;&#13;
          computed[1] = stop;&#13;
          computed[2] = step;&#13;
          return computed;&#13;
        },&#13;
  &#13;
        capSliceRange: function(arrayLength, actualValue, step) {&#13;
            if (actualValue &lt; 0) {&#13;
                actualValue += arrayLength;&#13;
                if (actualValue &lt; 0) {&#13;
                    actualValue = step &lt; 0 ? -1 : 0;&#13;
                }&#13;
            } else if (actualValue &gt;= arrayLength) {&#13;
                actualValue = step &lt; 0 ? arrayLength - 1 : arrayLength;&#13;
            }&#13;
            return actualValue;&#13;
        }&#13;
  &#13;
    };&#13;
  &#13;
    function Runtime(interpreter) {&#13;
      this._interpreter = interpreter;&#13;
      this.functionTable = {&#13;
          abs: {_func: this._functionAbs, _signature: [{types: [TYPE_NUMBER]}]},&#13;
          avg: {_func: this._functionAvg, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},&#13;
          ceil: {_func: this._functionCeil, _signature: [{types: [TYPE_NUMBER]}]},&#13;
          contains: {&#13;
              _func: this._functionContains,&#13;
              _signature: [{types: [TYPE_STRING, TYPE_ARRAY]},&#13;
                          {types: [TYPE_ANY]}]},&#13;
          "ends_with": {&#13;
              _func: this._functionEndsWith,&#13;
              _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},&#13;
          floor: {_func: this._functionFloor, _signature: [{types: [TYPE_NUMBER]}]},&#13;
          length: {&#13;
              _func: this._functionLength,&#13;
              _signature: [{types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT]}]},&#13;
          map: {&#13;
              _func: this._functionMap,&#13;
              _signature: [{types: [TYPE_EXPREF]}, {types: [TYPE_ARRAY]}]},&#13;
          max: {&#13;
              _func: this._functionMax,&#13;
              _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},&#13;
          "merge": {&#13;
              _func: this._functionMerge,&#13;
              _signature: [{types: [TYPE_OBJECT], variadic: true}]&#13;
          },&#13;
          "max_by": {&#13;
            _func: this._functionMaxBy,&#13;
            _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]&#13;
          },&#13;
          sum: {_func: this._functionSum, _signature: [{types: [TYPE_ARRAY_NUMBER]}]},&#13;
          "starts_with": {&#13;
              _func: this._functionStartsWith,&#13;
              _signature: [{types: [TYPE_STRING]}, {types: [TYPE_STRING]}]},&#13;
          min: {&#13;
              _func: this._functionMin,&#13;
              _signature: [{types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING]}]},&#13;
          "min_by": {&#13;
            _func: this._functionMinBy,&#13;
            _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]&#13;
          },&#13;
          type: {_func: this._functionType, _signature: [{types: [TYPE_ANY]}]},&#13;
          keys: {_func: this._functionKeys, _signature: [{types: [TYPE_OBJECT]}]},&#13;
          values: {_func: this._functionValues, _signature: [{types: [TYPE_OBJECT]}]},&#13;
          sort: {_func: this._functionSort, _signature: [{types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER]}]},&#13;
          "sort_by": {&#13;
            _func: this._functionSortBy,&#13;
            _signature: [{types: [TYPE_ARRAY]}, {types: [TYPE_EXPREF]}]&#13;
          },&#13;
          join: {&#13;
              _func: this._functionJoin,&#13;
              _signature: [&#13;
                  {types: [TYPE_STRING]},&#13;
                  {types: [TYPE_ARRAY_STRING]}&#13;
              ]&#13;
          },&#13;
          reverse: {&#13;
              _func: this._functionReverse,&#13;
              _signature: [{types: [TYPE_STRING, TYPE_ARRAY]}]},&#13;
          "to_array": {_func: this._functionToArray, _signature: [{types: [TYPE_ANY]}]},&#13;
          "to_string": {_func: this._functionToString, _signature: [{types: [TYPE_ANY]}]},&#13;
          "to_number": {_func: this._functionToNumber, _signature: [{types: [TYPE_ANY]}]},&#13;
          "not_null": {&#13;
              _func: this._functionNotNull,&#13;
              _signature: [{types: [TYPE_ANY], variadic: true}]&#13;
          }&#13;
      };&#13;
    }&#13;
  &#13;
    Runtime.prototype = {&#13;
      callFunction: function(name, resolvedArgs) {&#13;
        var functionEntry = this.functionTable[name];&#13;
        if (functionEntry === undefined) {&#13;
            throw new Error("Unknown function: " + name + "()");&#13;
        }&#13;
        this._validateArgs(name, resolvedArgs, functionEntry._signature);&#13;
        return functionEntry._func.call(this, resolvedArgs);&#13;
      },&#13;
  &#13;
      _validateArgs: function(name, args, signature) {&#13;
          var pluralized;&#13;
          if (signature[signature.length - 1].variadic) {&#13;
              if (args.length &lt; signature.length) {&#13;
                  pluralized = signature.length === 1 ? " argument" : " arguments";&#13;
                  throw new Error("ArgumentError: " + name + "() " +&#13;
                                  "takes at least" + signature.length + pluralized +&#13;
                                  " but received " + args.length);&#13;
              }&#13;
          } else if (args.length !== signature.length) {&#13;
              pluralized = signature.length === 1 ? " argument" : " arguments";&#13;
              throw new Error("ArgumentError: " + name + "() " +&#13;
                              "takes " + signature.length + pluralized +&#13;
                              " but received " + args.length);&#13;
          }&#13;
          var currentSpec;&#13;
          var actualType;&#13;
          var typeMatched;&#13;
          for (var i = 0; i &lt; signature.length; i++) {&#13;
              typeMatched = false;&#13;
              currentSpec = signature[i].types;&#13;
              actualType = this._getTypeName(args[i]);&#13;
              for (var j = 0; j &lt; currentSpec.length; j++) {&#13;
                  if (this._typeMatches(actualType, currentSpec[j], args[i])) {&#13;
                      typeMatched = true;&#13;
                      break;&#13;
                  }&#13;
              }&#13;
              if (!typeMatched) {&#13;
                  throw new Error("TypeError: " + name + "() " +&#13;
                                  "expected argument " + (i + 1) +&#13;
                                  " to be type " + currentSpec +&#13;
                                  " but received type " + actualType +&#13;
                                  " instead.");&#13;
              }&#13;
          }&#13;
      },&#13;
  &#13;
      _typeMatches: function(actual, expected, argValue) {&#13;
          if (expected === TYPE_ANY) {&#13;
              return true;&#13;
          }&#13;
          if (expected === TYPE_ARRAY_STRING ||&#13;
              expected === TYPE_ARRAY_NUMBER ||&#13;
              expected === TYPE_ARRAY) {&#13;
              if (expected === TYPE_ARRAY) {&#13;
                  return actual === TYPE_ARRAY;&#13;
              } else if (actual === TYPE_ARRAY) {&#13;
                  var subtype;&#13;
                  if (expected === TYPE_ARRAY_NUMBER) {&#13;
                    subtype = TYPE_NUMBER;&#13;
                  } else if (expected === TYPE_ARRAY_STRING) {&#13;
                    subtype = TYPE_STRING;&#13;
                  }&#13;
                  for (var i = 0; i &lt; argValue.length; i++) {&#13;
                      if (!this._typeMatches(&#13;
                              this._getTypeName(argValue[i]), subtype,&#13;
                                               argValue[i])) {&#13;
                          return false;&#13;
                      }&#13;
                  }&#13;
                  return true;&#13;
              }&#13;
          } else {&#13;
              return actual === expected;&#13;
          }&#13;
      },&#13;
      _getTypeName: function(obj) {&#13;
          switch (Object.prototype.toString.call(obj)) {&#13;
              case "[object String]":&#13;
                return TYPE_STRING;&#13;
              case "[object Number]":&#13;
                return TYPE_NUMBER;&#13;
              case "[object Array]":&#13;
                return TYPE_ARRAY;&#13;
              case "[object Boolean]":&#13;
                return TYPE_BOOLEAN;&#13;
              case "[object Null]":&#13;
                return TYPE_NULL;&#13;
              case "[object Object]":&#13;
                if (obj.jmespathType === TOK_EXPREF) {&#13;
                  return TYPE_EXPREF;&#13;
                } else {&#13;
                  return TYPE_OBJECT;&#13;
                }&#13;
          }&#13;
      },&#13;
  &#13;
      _functionStartsWith: function(resolvedArgs) {&#13;
          return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;&#13;
      },&#13;
  &#13;
      _functionEndsWith: function(resolvedArgs) {&#13;
          var searchStr = resolvedArgs[0];&#13;
          var suffix = resolvedArgs[1];&#13;
          return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;&#13;
      },&#13;
  &#13;
      _functionReverse: function(resolvedArgs) {&#13;
          var typeName = this._getTypeName(resolvedArgs[0]);&#13;
          if (typeName === TYPE_STRING) {&#13;
            var originalStr = resolvedArgs[0];&#13;
            var reversedStr = "";&#13;
            for (var i = originalStr.length - 1; i &gt;= 0; i--) {&#13;
                reversedStr += originalStr[i];&#13;
            }&#13;
            return reversedStr;&#13;
          } else {&#13;
            var reversedArray = resolvedArgs[0].slice(0);&#13;
            reversedArray.reverse();&#13;
            return reversedArray;&#13;
          }&#13;
      },&#13;
  &#13;
      _functionAbs: function(resolvedArgs) {&#13;
        return Math.abs(resolvedArgs[0]);&#13;
      },&#13;
  &#13;
      _functionCeil: function(resolvedArgs) {&#13;
          return Math.ceil(resolvedArgs[0]);&#13;
      },&#13;
  &#13;
      _functionAvg: function(resolvedArgs) {&#13;
          var sum = 0;&#13;
          var inputArray = resolvedArgs[0];&#13;
          for (var i = 0; i &lt; inputArray.length; i++) {&#13;
              sum += inputArray[i];&#13;
          }&#13;
          return sum / inputArray.length;&#13;
      },&#13;
  &#13;
      _functionContains: function(resolvedArgs) {&#13;
          return resolvedArgs[0].indexOf(resolvedArgs[1]) &gt;= 0;&#13;
      },&#13;
  &#13;
      _functionFloor: function(resolvedArgs) {&#13;
          return Math.floor(resolvedArgs[0]);&#13;
      },&#13;
  &#13;
      _functionLength: function(resolvedArgs) {&#13;
         if (!isObject(resolvedArgs[0])) {&#13;
           return resolvedArgs[0].length;&#13;
         } else {&#13;
           return Object.keys(resolvedArgs[0]).length;&#13;
         }&#13;
      },&#13;
  &#13;
      _functionMap: function(resolvedArgs) {&#13;
        var mapped = [];&#13;
        var interpreter = this._interpreter;&#13;
        var exprefNode = resolvedArgs[0];&#13;
        var elements = resolvedArgs[1];&#13;
        for (var i = 0; i &lt; elements.length; i++) {&#13;
            mapped.push(interpreter.visit(exprefNode, elements[i]));&#13;
        }&#13;
        return mapped;&#13;
      },&#13;
  &#13;
      _functionMerge: function(resolvedArgs) {&#13;
        var merged = {};&#13;
        for (var i = 0; i &lt; resolvedArgs.length; i++) {&#13;
          var current = resolvedArgs[i];&#13;
          for (var key in current) {&#13;
            merged[key] = current[key];&#13;
          }&#13;
        }&#13;
        return merged;&#13;
      },&#13;
  &#13;
      _functionMax: function(resolvedArgs) {&#13;
        if (resolvedArgs[0].length &gt; 0) {&#13;
          var typeName = this._getTypeName(resolvedArgs[0][0]);&#13;
          if (typeName === TYPE_NUMBER) {&#13;
            return Math.max.apply(Math, resolvedArgs[0]);&#13;
          } else {&#13;
            var elements = resolvedArgs[0];&#13;
            var maxElement = elements[0];&#13;
            for (var i = 1; i &lt; elements.length; i++) {&#13;
                if (maxElement.localeCompare(elements[i]) &lt; 0) {&#13;
                    maxElement = elements[i];&#13;
                }&#13;
            }&#13;
            return maxElement;&#13;
          }&#13;
        } else {&#13;
            return null;&#13;
        }&#13;
      },&#13;
  &#13;
      _functionMin: function(resolvedArgs) {&#13;
        if (resolvedArgs[0].length &gt; 0) {&#13;
          var typeName = this._getTypeName(resolvedArgs[0][0]);&#13;
          if (typeName === TYPE_NUMBER) {&#13;
            return Math.min.apply(Math, resolvedArgs[0]);&#13;
          } else {&#13;
            var elements = resolvedArgs[0];&#13;
            var minElement = elements[0];&#13;
            for (var i = 1; i &lt; elements.length; i++) {&#13;
                if (elements[i].localeCompare(minElement) &lt; 0) {&#13;
                    minElement = elements[i];&#13;
                }&#13;
            }&#13;
            return minElement;&#13;
          }&#13;
        } else {&#13;
          return null;&#13;
        }&#13;
      },&#13;
  &#13;
      _functionSum: function(resolvedArgs) {&#13;
        var sum = 0;&#13;
        var listToSum = resolvedArgs[0];&#13;
        for (var i = 0; i &lt; listToSum.length; i++) {&#13;
          sum += listToSum[i];&#13;
        }&#13;
        return sum;&#13;
      },&#13;
  &#13;
      _functionType: function(resolvedArgs) {&#13;
          switch (this._getTypeName(resolvedArgs[0])) {&#13;
            case TYPE_NUMBER:&#13;
              return "number";&#13;
            case TYPE_STRING:&#13;
              return "string";&#13;
            case TYPE_ARRAY:&#13;
              return "array";&#13;
            case TYPE_OBJECT:&#13;
              return "object";&#13;
            case TYPE_BOOLEAN:&#13;
              return "boolean";&#13;
            case TYPE_EXPREF:&#13;
              return "expref";&#13;
            case TYPE_NULL:&#13;
              return "null";&#13;
          }&#13;
      },&#13;
  &#13;
      _functionKeys: function(resolvedArgs) {&#13;
          return Object.keys(resolvedArgs[0]);&#13;
      },&#13;
  &#13;
      _functionValues: function(resolvedArgs) {&#13;
          var obj = resolvedArgs[0];&#13;
          var keys = Object.keys(obj);&#13;
          var values = [];&#13;
          for (var i = 0; i &lt; keys.length; i++) {&#13;
              values.push(obj[keys[i]]);&#13;
          }&#13;
          return values;&#13;
      },&#13;
  &#13;
      _functionJoin: function(resolvedArgs) {&#13;
          var joinChar = resolvedArgs[0];&#13;
          var listJoin = resolvedArgs[1];&#13;
          return listJoin.join(joinChar);&#13;
      },&#13;
  &#13;
      _functionToArray: function(resolvedArgs) {&#13;
          if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {&#13;
              return resolvedArgs[0];&#13;
          } else {&#13;
              return [resolvedArgs[0]];&#13;
          }&#13;
      },&#13;
  &#13;
      _functionToString: function(resolvedArgs) {&#13;
          if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {&#13;
              return resolvedArgs[0];&#13;
          } else {&#13;
              return JSON.stringify(resolvedArgs[0]);&#13;
          }&#13;
      },&#13;
  &#13;
      _functionToNumber: function(resolvedArgs) {&#13;
          var typeName = this._getTypeName(resolvedArgs[0]);&#13;
          var convertedValue;&#13;
          if (typeName === TYPE_NUMBER) {&#13;
              return resolvedArgs[0];&#13;
          } else if (typeName === TYPE_STRING) {&#13;
              convertedValue = +resolvedArgs[0];&#13;
              if (!isNaN(convertedValue)) {&#13;
                  return convertedValue;&#13;
              }&#13;
          }&#13;
          return null;&#13;
      },&#13;
  &#13;
      _functionNotNull: function(resolvedArgs) {&#13;
          for (var i = 0; i &lt; resolvedArgs.length; i++) {&#13;
              if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {&#13;
                  return resolvedArgs[i];&#13;
              }&#13;
          }&#13;
          return null;&#13;
      },&#13;
  &#13;
      _functionSort: function(resolvedArgs) {&#13;
          var sortedArray = resolvedArgs[0].slice(0);&#13;
          sortedArray.sort();&#13;
          return sortedArray;&#13;
      },&#13;
  &#13;
      _functionSortBy: function(resolvedArgs) {&#13;
          var sortedArray = resolvedArgs[0].slice(0);&#13;
          if (sortedArray.length === 0) {&#13;
              return sortedArray;&#13;
          }&#13;
          var interpreter = this._interpreter;&#13;
          var exprefNode = resolvedArgs[1];&#13;
          var requiredType = this._getTypeName(&#13;
              interpreter.visit(exprefNode, sortedArray[0]));&#13;
          if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) &lt; 0) {&#13;
              throw new Error("TypeError");&#13;
          }&#13;
          var that = this;&#13;
          var decorated = [];&#13;
          for (var i = 0; i &lt; sortedArray.length; i++) {&#13;
            decorated.push([i, sortedArray[i]]);&#13;
          }&#13;
          decorated.sort(function(a, b) {&#13;
            var exprA = interpreter.visit(exprefNode, a[1]);&#13;
            var exprB = interpreter.visit(exprefNode, b[1]);&#13;
            if (that._getTypeName(exprA) !== requiredType) {&#13;
                throw new Error(&#13;
                    "TypeError: expected " + requiredType + ", received " +&#13;
                    that._getTypeName(exprA));&#13;
            } else if (that._getTypeName(exprB) !== requiredType) {&#13;
                throw new Error(&#13;
                    "TypeError: expected " + requiredType + ", received " +&#13;
                    that._getTypeName(exprB));&#13;
            }&#13;
            if (exprA &gt; exprB) {&#13;
              return 1;&#13;
            } else if (exprA &lt; exprB) {&#13;
              return -1;&#13;
            } else {&#13;
              return a[0] - b[0];&#13;
            }&#13;
          });&#13;
          for (var j = 0; j &lt; decorated.length; j++) {&#13;
            sortedArray[j] = decorated[j][1];&#13;
          }&#13;
          return sortedArray;&#13;
      },&#13;
  &#13;
      _functionMaxBy: function(resolvedArgs) {&#13;
        var exprefNode = resolvedArgs[1];&#13;
        var resolvedArray = resolvedArgs[0];&#13;
        var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);&#13;
        var maxNumber = -Infinity;&#13;
        var maxRecord;&#13;
        var current;&#13;
        for (var i = 0; i &lt; resolvedArray.length; i++) {&#13;
          current = keyFunction(resolvedArray[i]);&#13;
          if (current &gt; maxNumber) {&#13;
            maxNumber = current;&#13;
            maxRecord = resolvedArray[i];&#13;
          }&#13;
        }&#13;
        return maxRecord;&#13;
      },&#13;
  &#13;
      _functionMinBy: function(resolvedArgs) {&#13;
        var exprefNode = resolvedArgs[1];&#13;
        var resolvedArray = resolvedArgs[0];&#13;
        var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);&#13;
        var minNumber = Infinity;&#13;
        var minRecord;&#13;
        var current;&#13;
        for (var i = 0; i &lt; resolvedArray.length; i++) {&#13;
          current = keyFunction(resolvedArray[i]);&#13;
          if (current &lt; minNumber) {&#13;
            minNumber = current;&#13;
            minRecord = resolvedArray[i];&#13;
          }&#13;
        }&#13;
        return minRecord;&#13;
      },&#13;
  &#13;
      createKeyFunction: function(exprefNode, allowedTypes) {&#13;
        var that = this;&#13;
        var interpreter = this._interpreter;&#13;
        var keyFunc = function(x) {&#13;
          var current = interpreter.visit(exprefNode, x);&#13;
          if (allowedTypes.indexOf(that._getTypeName(current)) &lt; 0) {&#13;
            var msg = "TypeError: expected one of " + allowedTypes +&#13;
                      ", received " + that._getTypeName(current);&#13;
            throw new Error(msg);&#13;
          }&#13;
          return current;&#13;
        };&#13;
        return keyFunc;&#13;
      }&#13;
  &#13;
    };&#13;
  &#13;
    function compile(stream) {&#13;
      var parser = new Parser();&#13;
      var ast = parser.parse(stream);&#13;
      return ast;&#13;
    }&#13;
  &#13;
    function tokenize(stream) {&#13;
        var lexer = new Lexer();&#13;
        return lexer.tokenize(stream);&#13;
    }&#13;
  &#13;
    function search(data, expression) {&#13;
        var parser = new Parser();&#13;
        var runtime = new Runtime();&#13;
        var interpreter = new TreeInterpreter(runtime);&#13;
        runtime._interpreter = interpreter;&#13;
        var node = parser.parse(expression);&#13;
        return interpreter.search(node, data);&#13;
    }&#13;
  &#13;
    exports.tokenize = tokenize;&#13;
    exports.compile = compile;&#13;
    exports.search = search;&#13;
    exports.strictDeepEqual = strictDeepEqual;&#13;
  })(typeof exports === "undefined" ? this.jmespath = {} : exports);&#13;
  &#13;
  },{}],69:[function(require,module,exports){&#13;
  var arrayEvery = require('../internal/arrayEvery'),&#13;
      baseCallback = require('../internal/baseCallback'),&#13;
      baseEvery = require('../internal/baseEvery'),&#13;
      isArray = require('../lang/isArray');&#13;
  &#13;
  &#13;
  function every(collection, predicate, thisArg) {&#13;
    var func = isArray(collection) ? arrayEvery : baseEvery;&#13;
    if (typeof predicate != 'function' || typeof thisArg != 'undefined') {&#13;
      predicate = baseCallback(predicate, thisArg, 3);&#13;
    }&#13;
    return func(collection, predicate);&#13;
  }&#13;
  &#13;
  module.exports = every;&#13;
  &#13;
  },{"../internal/arrayEvery":70,"../internal/baseCallback":72,"../internal/baseEvery":76,"../lang/isArray":103}],70:[function(require,module,exports){&#13;
  &#13;
  function arrayEvery(array, predicate) {&#13;
    var index = -1,&#13;
        length = array.length;&#13;
  &#13;
    while (++index &lt; length) {&#13;
      if (!predicate(array[index], index, array)) {&#13;
        return false;&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
  &#13;
  module.exports = arrayEvery;&#13;
  &#13;
  },{}],71:[function(require,module,exports){&#13;
  var baseCopy = require('./baseCopy'),&#13;
      keys = require('../object/keys');&#13;
  &#13;
  &#13;
  function baseAssign(object, source, customizer) {&#13;
    var props = keys(source);&#13;
    if (!customizer) {&#13;
      return baseCopy(source, object, props);&#13;
    }&#13;
    var index = -1,&#13;
        length = props.length;&#13;
  &#13;
    while (++index &lt; length) {&#13;
      var key = props[index],&#13;
          value = object[key],&#13;
          result = customizer(value, source[key], key, object, source);&#13;
  &#13;
      if ((result === result ? (result !== value) : (value === value)) ||&#13;
          (typeof value == 'undefined' &amp;&amp; !(key in object))) {&#13;
        object[key] = result;&#13;
      }&#13;
    }&#13;
    return object;&#13;
  }&#13;
  &#13;
  module.exports = baseAssign;&#13;
  &#13;
  },{"../object/keys":112,"./baseCopy":73}],72:[function(require,module,exports){&#13;
  var baseMatches = require('./baseMatches'),&#13;
      baseMatchesProperty = require('./baseMatchesProperty'),&#13;
      baseProperty = require('./baseProperty'),&#13;
      bindCallback = require('./bindCallback'),&#13;
      identity = require('../utility/identity'),&#13;
      isBindable = require('./isBindable');&#13;
  &#13;
  &#13;
  function baseCallback(func, thisArg, argCount) {&#13;
    var type = typeof func;&#13;
    if (type == 'function') {&#13;
      return (typeof thisArg != 'undefined' &amp;&amp; isBindable(func))&#13;
        ? bindCallback(func, thisArg, argCount)&#13;
        : func;&#13;
    }&#13;
    if (func == null) {&#13;
      return identity;&#13;
    }&#13;
    if (type == 'object') {&#13;
      return baseMatches(func);&#13;
    }&#13;
    return typeof thisArg == 'undefined'&#13;
      ? baseProperty(func + '')&#13;
      : baseMatchesProperty(func + '', thisArg);&#13;
  }&#13;
  &#13;
  module.exports = baseCallback;&#13;
  &#13;
  },{"../utility/identity":116,"./baseMatches":83,"./baseMatchesProperty":84,"./baseProperty":85,"./bindCallback":88,"./isBindable":93}],73:[function(require,module,exports){&#13;
  &#13;
  function baseCopy(source, object, props) {&#13;
    if (!props) {&#13;
      props = object;&#13;
      object = {};&#13;
    }&#13;
    var index = -1,&#13;
        length = props.length;&#13;
  &#13;
    while (++index &lt; length) {&#13;
      var key = props[index];&#13;
      object[key] = source[key];&#13;
    }&#13;
    return object;&#13;
  }&#13;
  &#13;
  module.exports = baseCopy;&#13;
  &#13;
  },{}],74:[function(require,module,exports){&#13;
  (function (global){&#13;
  var isObject = require('../lang/isObject');&#13;
  &#13;
  &#13;
  var baseCreate = (function() {&#13;
    function Object() {}&#13;
    return function(prototype) {&#13;
      if (isObject(prototype)) {&#13;
        Object.prototype = prototype;&#13;
        var result = new Object;&#13;
        Object.prototype = null;&#13;
      }&#13;
      return result || global.Object();&#13;
    };&#13;
  }());&#13;
  &#13;
  module.exports = baseCreate;&#13;
  &#13;
  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})&#13;
  },{"../lang/isObject":107}],75:[function(require,module,exports){&#13;
  var baseForOwn = require('./baseForOwn'),&#13;
      isLength = require('./isLength'),&#13;
      toObject = require('./toObject');&#13;
  &#13;
  &#13;
  function baseEach(collection, iteratee) {&#13;
    var length = collection ? collection.length : 0;&#13;
    if (!isLength(length)) {&#13;
      return baseForOwn(collection, iteratee);&#13;
    }&#13;
    var index = -1,&#13;
        iterable = toObject(collection);&#13;
  &#13;
    while (++index &lt; length) {&#13;
      if (iteratee(iterable[index], index, iterable) === false) {&#13;
        break;&#13;
      }&#13;
    }&#13;
    return collection;&#13;
  }&#13;
  &#13;
  module.exports = baseEach;&#13;
  &#13;
  },{"./baseForOwn":78,"./isLength":96,"./toObject":101}],76:[function(require,module,exports){&#13;
  var baseEach = require('./baseEach');&#13;
  &#13;
  &#13;
  function baseEvery(collection, predicate) {&#13;
    var result = true;&#13;
    baseEach(collection, function(value, index, collection) {&#13;
      result = !!predicate(value, index, collection);&#13;
      return result;&#13;
    });&#13;
    return result;&#13;
  }&#13;
  &#13;
  module.exports = baseEvery;&#13;
  &#13;
  },{"./baseEach":75}],77:[function(require,module,exports){&#13;
  var toObject = require('./toObject');&#13;
  &#13;
  &#13;
  function baseFor(object, iteratee, keysFunc) {&#13;
    var index = -1,&#13;
        iterable = toObject(object),&#13;
        props = keysFunc(object),&#13;
        length = props.length;&#13;
  &#13;
    while (++index &lt; length) {&#13;
      var key = props[index];&#13;
      if (iteratee(iterable[key], key, iterable) === false) {&#13;
        break;&#13;
      }&#13;
    }&#13;
    return object;&#13;
  }&#13;
  &#13;
  module.exports = baseFor;&#13;
  &#13;
  },{"./toObject":101}],78:[function(require,module,exports){&#13;
  var baseFor = require('./baseFor'),&#13;
      keys = require('../object/keys');&#13;
  &#13;
  &#13;
  function baseForOwn(object, iteratee) {&#13;
    return baseFor(object, iteratee, keys);&#13;
  }&#13;
  &#13;
  module.exports = baseForOwn;&#13;
  &#13;
  },{"../object/keys":112,"./baseFor":77}],79:[function(require,module,exports){&#13;
  var baseIsEqualDeep = require('./baseIsEqualDeep');&#13;
  &#13;
  &#13;
  function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {&#13;
    if (value === other) {&#13;
      return value !== 0 || (1 / value == 1 / other);&#13;
    }&#13;
    var valType = typeof value,&#13;
        othType = typeof other;&#13;
  &#13;
    if ((valType != 'function' &amp;&amp; valType != 'object' &amp;&amp; othType != 'function' &amp;&amp; othType != 'object') ||&#13;
        value == null || other == null) {&#13;
      return value !== value &amp;&amp; other !== other;&#13;
    }&#13;
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);&#13;
  }&#13;
  &#13;
  module.exports = baseIsEqual;&#13;
  &#13;
  },{"./baseIsEqualDeep":80}],80:[function(require,module,exports){&#13;
  var equalArrays = require('./equalArrays'),&#13;
      equalByTag = require('./equalByTag'),&#13;
      equalObjects = require('./equalObjects'),&#13;
      isArray = require('../lang/isArray'),&#13;
      isTypedArray = require('../lang/isTypedArray');&#13;
  &#13;
  &#13;
  var argsTag = '[object Arguments]',&#13;
      arrayTag = '[object Array]',&#13;
      objectTag = '[object Object]';&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var hasOwnProperty = objectProto.hasOwnProperty;&#13;
  &#13;
  &#13;
  var objToString = objectProto.toString;&#13;
  &#13;
  &#13;
  function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {&#13;
    var objIsArr = isArray(object),&#13;
        othIsArr = isArray(other),&#13;
        objTag = arrayTag,&#13;
        othTag = arrayTag;&#13;
  &#13;
    if (!objIsArr) {&#13;
      objTag = objToString.call(object);&#13;
      if (objTag == argsTag) {&#13;
        objTag = objectTag;&#13;
      } else if (objTag != objectTag) {&#13;
        objIsArr = isTypedArray(object);&#13;
      }&#13;
    }&#13;
    if (!othIsArr) {&#13;
      othTag = objToString.call(other);&#13;
      if (othTag == argsTag) {&#13;
        othTag = objectTag;&#13;
      } else if (othTag != objectTag) {&#13;
        othIsArr = isTypedArray(other);&#13;
      }&#13;
    }&#13;
    var objIsObj = objTag == objectTag,&#13;
        othIsObj = othTag == objectTag,&#13;
        isSameTag = objTag == othTag;&#13;
  &#13;
    if (isSameTag &amp;&amp; !(objIsArr || objIsObj)) {&#13;
      return equalByTag(object, other, objTag);&#13;
    }&#13;
    var valWrapped = objIsObj &amp;&amp; hasOwnProperty.call(object, '__wrapped__'),&#13;
        othWrapped = othIsObj &amp;&amp; hasOwnProperty.call(other, '__wrapped__');&#13;
  &#13;
    if (valWrapped || othWrapped) {&#13;
      return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);&#13;
    }&#13;
    if (!isSameTag) {&#13;
      return false;&#13;
    }&#13;
    stackA || (stackA = []);&#13;
    stackB || (stackB = []);&#13;
  &#13;
    var length = stackA.length;&#13;
    while (length--) {&#13;
      if (stackA[length] == object) {&#13;
        return stackB[length] == other;&#13;
      }&#13;
    }&#13;
    stackA.push(object);&#13;
    stackB.push(other);&#13;
  &#13;
    var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);&#13;
  &#13;
    stackA.pop();&#13;
    stackB.pop();&#13;
  &#13;
    return result;&#13;
  }&#13;
  &#13;
  module.exports = baseIsEqualDeep;&#13;
  &#13;
  },{"../lang/isArray":103,"../lang/isTypedArray":109,"./equalArrays":90,"./equalByTag":91,"./equalObjects":92}],81:[function(require,module,exports){&#13;
  &#13;
  function baseIsFunction(value) {&#13;
    return typeof value == 'function' || false;&#13;
  }&#13;
  &#13;
  module.exports = baseIsFunction;&#13;
  &#13;
  },{}],82:[function(require,module,exports){&#13;
  var baseIsEqual = require('./baseIsEqual');&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var hasOwnProperty = objectProto.hasOwnProperty;&#13;
  &#13;
  &#13;
  function baseIsMatch(object, props, values, strictCompareFlags, customizer) {&#13;
    var length = props.length;&#13;
    if (object == null) {&#13;
      return !length;&#13;
    }&#13;
    var index = -1,&#13;
        noCustomizer = !customizer;&#13;
  &#13;
    while (++index &lt; length) {&#13;
      if ((noCustomizer &amp;&amp; strictCompareFlags[index])&#13;
            ? values[index] !== object[props[index]]&#13;
            : !hasOwnProperty.call(object, props[index])&#13;
          ) {&#13;
        return false;&#13;
      }&#13;
    }&#13;
    index = -1;&#13;
    while (++index &lt; length) {&#13;
      var key = props[index];&#13;
      if (noCustomizer &amp;&amp; strictCompareFlags[index]) {&#13;
        var result = hasOwnProperty.call(object, key);&#13;
      } else {&#13;
        var objValue = object[key],&#13;
            srcValue = values[index];&#13;
  &#13;
        result = customizer ? customizer(objValue, srcValue, key) : undefined;&#13;
        if (typeof result == 'undefined') {&#13;
          result = baseIsEqual(srcValue, objValue, customizer, true);&#13;
        }&#13;
      }&#13;
      if (!result) {&#13;
        return false;&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
  &#13;
  module.exports = baseIsMatch;&#13;
  &#13;
  },{"./baseIsEqual":79}],83:[function(require,module,exports){&#13;
  var baseIsMatch = require('./baseIsMatch'),&#13;
      isStrictComparable = require('./isStrictComparable'),&#13;
      keys = require('../object/keys');&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var hasOwnProperty = objectProto.hasOwnProperty;&#13;
  &#13;
  &#13;
  function baseMatches(source) {&#13;
    var props = keys(source),&#13;
        length = props.length;&#13;
  &#13;
    if (length == 1) {&#13;
      var key = props[0],&#13;
          value = source[key];&#13;
  &#13;
      if (isStrictComparable(value)) {&#13;
        return function(object) {&#13;
          return object != null &amp;&amp; object[key] === value &amp;&amp; hasOwnProperty.call(object, key);&#13;
        };&#13;
      }&#13;
    }&#13;
    var values = Array(length),&#13;
        strictCompareFlags = Array(length);&#13;
  &#13;
    while (length--) {&#13;
      value = source[props[length]];&#13;
      values[length] = value;&#13;
      strictCompareFlags[length] = isStrictComparable(value);&#13;
    }&#13;
    return function(object) {&#13;
      return baseIsMatch(object, props, values, strictCompareFlags);&#13;
    };&#13;
  }&#13;
  &#13;
  module.exports = baseMatches;&#13;
  &#13;
  },{"../object/keys":112,"./baseIsMatch":82,"./isStrictComparable":98}],84:[function(require,module,exports){&#13;
  var baseIsEqual = require('./baseIsEqual'),&#13;
      isStrictComparable = require('./isStrictComparable');&#13;
  &#13;
  &#13;
  function baseMatchesProperty(key, value) {&#13;
    if (isStrictComparable(value)) {&#13;
      return function(object) {&#13;
        return object != null &amp;&amp; object[key] === value;&#13;
      };&#13;
    }&#13;
    return function(object) {&#13;
      return object != null &amp;&amp; baseIsEqual(value, object[key], null, true);&#13;
    };&#13;
  }&#13;
  &#13;
  module.exports = baseMatchesProperty;&#13;
  &#13;
  },{"./baseIsEqual":79,"./isStrictComparable":98}],85:[function(require,module,exports){&#13;
  &#13;
  function baseProperty(key) {&#13;
    return function(object) {&#13;
      return object == null ? undefined : object[key];&#13;
    };&#13;
  }&#13;
  &#13;
  module.exports = baseProperty;&#13;
  &#13;
  },{}],86:[function(require,module,exports){&#13;
  var identity = require('../utility/identity'),&#13;
      metaMap = require('./metaMap');&#13;
  &#13;
  &#13;
  var baseSetData = !metaMap ? identity : function(func, data) {&#13;
    metaMap.set(func, data);&#13;
    return func;&#13;
  };&#13;
  &#13;
  module.exports = baseSetData;&#13;
  &#13;
  },{"../utility/identity":116,"./metaMap":99}],87:[function(require,module,exports){&#13;
  &#13;
  function baseToString(value) {&#13;
    if (typeof value == 'string') {&#13;
      return value;&#13;
    }&#13;
    return value == null ? '' : (value + '');&#13;
  }&#13;
  &#13;
  module.exports = baseToString;&#13;
  &#13;
  },{}],88:[function(require,module,exports){&#13;
  var identity = require('../utility/identity');&#13;
  &#13;
  &#13;
  function bindCallback(func, thisArg, argCount) {&#13;
    if (typeof func != 'function') {&#13;
      return identity;&#13;
    }&#13;
    if (typeof thisArg == 'undefined') {&#13;
      return func;&#13;
    }&#13;
    switch (argCount) {&#13;
      case 1: return function(value) {&#13;
        return func.call(thisArg, value);&#13;
      };&#13;
      case 3: return function(value, index, collection) {&#13;
        return func.call(thisArg, value, index, collection);&#13;
      };&#13;
      case 4: return function(accumulator, value, index, collection) {&#13;
        return func.call(thisArg, accumulator, value, index, collection);&#13;
      };&#13;
      case 5: return function(value, other, key, object, source) {&#13;
        return func.call(thisArg, value, other, key, object, source);&#13;
      };&#13;
    }&#13;
    return function() {&#13;
      return func.apply(thisArg, arguments);&#13;
    };&#13;
  }&#13;
  &#13;
  module.exports = bindCallback;&#13;
  &#13;
  },{"../utility/identity":116}],89:[function(require,module,exports){&#13;
  var bindCallback = require('./bindCallback'),&#13;
      isIterateeCall = require('./isIterateeCall');&#13;
  &#13;
  &#13;
  function createAssigner(assigner) {&#13;
    return function() {&#13;
      var args = arguments,&#13;
          length = args.length,&#13;
          object = args[0];&#13;
  &#13;
      if (length &lt; 2 || object == null) {&#13;
        return object;&#13;
      }&#13;
      var customizer = args[length - 2],&#13;
          thisArg = args[length - 1],&#13;
          guard = args[3];&#13;
  &#13;
      if (length &gt; 3 &amp;&amp; typeof customizer == 'function') {&#13;
        customizer = bindCallback(customizer, thisArg, 5);&#13;
        length -= 2;&#13;
      } else {&#13;
        customizer = (length &gt; 2 &amp;&amp; typeof thisArg == 'function') ? thisArg : null;&#13;
        length -= (customizer ? 1 : 0);&#13;
      }&#13;
      if (guard &amp;&amp; isIterateeCall(args[1], args[2], guard)) {&#13;
        customizer = length == 3 ? null : customizer;&#13;
        length = 2;&#13;
      }&#13;
      var index = 0;&#13;
      while (++index &lt; length) {&#13;
        var source = args[index];&#13;
        if (source) {&#13;
          assigner(object, source, customizer);&#13;
        }&#13;
      }&#13;
      return object;&#13;
    };&#13;
  }&#13;
  &#13;
  module.exports = createAssigner;&#13;
  &#13;
  },{"./bindCallback":88,"./isIterateeCall":95}],90:[function(require,module,exports){&#13;
  &#13;
  function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {&#13;
    var index = -1,&#13;
        arrLength = array.length,&#13;
        othLength = other.length,&#13;
        result = true;&#13;
  &#13;
    if (arrLength != othLength &amp;&amp; !(isWhere &amp;&amp; othLength &gt; arrLength)) {&#13;
      return false;&#13;
    }&#13;
    while (result &amp;&amp; ++index &lt; arrLength) {&#13;
      var arrValue = array[index],&#13;
          othValue = other[index];&#13;
  &#13;
      result = undefined;&#13;
      if (customizer) {&#13;
        result = isWhere&#13;
          ? customizer(othValue, arrValue, index)&#13;
          : customizer(arrValue, othValue, index);&#13;
      }&#13;
      if (typeof result == 'undefined') {&#13;
        if (isWhere) {&#13;
          var othIndex = othLength;&#13;
          while (othIndex--) {&#13;
            othValue = other[othIndex];&#13;
            result = (arrValue &amp;&amp; arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);&#13;
            if (result) {&#13;
              break;&#13;
            }&#13;
          }&#13;
        } else {&#13;
          result = (arrValue &amp;&amp; arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);&#13;
        }&#13;
      }&#13;
    }&#13;
    return !!result;&#13;
  }&#13;
  &#13;
  module.exports = equalArrays;&#13;
  &#13;
  },{}],91:[function(require,module,exports){&#13;
  &#13;
  var boolTag = '[object Boolean]',&#13;
      dateTag = '[object Date]',&#13;
      errorTag = '[object Error]',&#13;
      numberTag = '[object Number]',&#13;
      regexpTag = '[object RegExp]',&#13;
      stringTag = '[object String]';&#13;
  &#13;
  &#13;
  function equalByTag(object, other, tag) {&#13;
    switch (tag) {&#13;
      case boolTag:&#13;
      case dateTag:&#13;
        return +object == +other;&#13;
  &#13;
      case errorTag:&#13;
        return object.name == other.name &amp;&amp; object.message == other.message;&#13;
  &#13;
      case numberTag:&#13;
        return (object != +object)&#13;
          ? other != +other&#13;
          : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);&#13;
  &#13;
      case regexpTag:&#13;
      case stringTag:&#13;
        return object == (other + '');&#13;
    }&#13;
    return false;&#13;
  }&#13;
  &#13;
  module.exports = equalByTag;&#13;
  &#13;
  },{}],92:[function(require,module,exports){&#13;
  var keys = require('../object/keys');&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var hasOwnProperty = objectProto.hasOwnProperty;&#13;
  &#13;
  &#13;
  function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {&#13;
    var objProps = keys(object),&#13;
        objLength = objProps.length,&#13;
        othProps = keys(other),&#13;
        othLength = othProps.length;&#13;
  &#13;
    if (objLength != othLength &amp;&amp; !isWhere) {&#13;
      return false;&#13;
    }&#13;
    var hasCtor,&#13;
        index = -1;&#13;
  &#13;
    while (++index &lt; objLength) {&#13;
      var key = objProps[index],&#13;
          result = hasOwnProperty.call(other, key);&#13;
  &#13;
      if (result) {&#13;
        var objValue = object[key],&#13;
            othValue = other[key];&#13;
  &#13;
        result = undefined;&#13;
        if (customizer) {&#13;
          result = isWhere&#13;
            ? customizer(othValue, objValue, key)&#13;
            : customizer(objValue, othValue, key);&#13;
        }&#13;
        if (typeof result == 'undefined') {&#13;
          result = (objValue &amp;&amp; objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);&#13;
        }&#13;
      }&#13;
      if (!result) {&#13;
        return false;&#13;
      }&#13;
      hasCtor || (hasCtor = key == 'constructor');&#13;
    }&#13;
    if (!hasCtor) {&#13;
      var objCtor = object.constructor,&#13;
          othCtor = other.constructor;&#13;
  &#13;
      if (objCtor != othCtor &amp;&amp;&#13;
          ('constructor' in object &amp;&amp; 'constructor' in other) &amp;&amp;&#13;
          !(typeof objCtor == 'function' &amp;&amp; objCtor instanceof objCtor &amp;&amp;&#13;
            typeof othCtor == 'function' &amp;&amp; othCtor instanceof othCtor)) {&#13;
        return false;&#13;
      }&#13;
    }&#13;
    return true;&#13;
  }&#13;
  &#13;
  module.exports = equalObjects;&#13;
  &#13;
  },{"../object/keys":112}],93:[function(require,module,exports){&#13;
  var baseSetData = require('./baseSetData'),&#13;
      isNative = require('../lang/isNative'),&#13;
      support = require('../support');&#13;
  &#13;
  &#13;
  var reFuncName = /^\s*function[ \n\r\t]+\w/;&#13;
  &#13;
  &#13;
  var reThis = /\bthis\b/;&#13;
  &#13;
  &#13;
  var fnToString = Function.prototype.toString;&#13;
  &#13;
  &#13;
  function isBindable(func) {&#13;
    var result = !(support.funcNames ? func.name : support.funcDecomp);&#13;
  &#13;
    if (!result) {&#13;
      var source = fnToString.call(func);&#13;
      if (!support.funcNames) {&#13;
        result = !reFuncName.test(source);&#13;
      }&#13;
      if (!result) {&#13;
        result = reThis.test(source) || isNative(func);&#13;
        baseSetData(func, result);&#13;
      }&#13;
    }&#13;
    return result;&#13;
  }&#13;
  &#13;
  module.exports = isBindable;&#13;
  &#13;
  },{"../lang/isNative":106,"../support":115,"./baseSetData":86}],94:[function(require,module,exports){&#13;
  &#13;
  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;&#13;
  &#13;
  &#13;
  function isIndex(value, length) {&#13;
    value = +value;&#13;
    length = length == null ? MAX_SAFE_INTEGER : length;&#13;
    return value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt; length;&#13;
  }&#13;
  &#13;
  module.exports = isIndex;&#13;
  &#13;
  },{}],95:[function(require,module,exports){&#13;
  var isIndex = require('./isIndex'),&#13;
      isLength = require('./isLength'),&#13;
      isObject = require('../lang/isObject');&#13;
  &#13;
  &#13;
  function isIterateeCall(value, index, object) {&#13;
    if (!isObject(object)) {&#13;
      return false;&#13;
    }&#13;
    var type = typeof index;&#13;
    if (type == 'number') {&#13;
      var length = object.length,&#13;
          prereq = isLength(length) &amp;&amp; isIndex(index, length);&#13;
    } else {&#13;
      prereq = type == 'string' &amp;&amp; index in object;&#13;
    }&#13;
    if (prereq) {&#13;
      var other = object[index];&#13;
      return value === value ? (value === other) : (other !== other);&#13;
    }&#13;
    return false;&#13;
  }&#13;
  &#13;
  module.exports = isIterateeCall;&#13;
  &#13;
  },{"../lang/isObject":107,"./isIndex":94,"./isLength":96}],96:[function(require,module,exports){&#13;
  &#13;
  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;&#13;
  &#13;
  &#13;
  function isLength(value) {&#13;
    return typeof value == 'number' &amp;&amp; value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= MAX_SAFE_INTEGER;&#13;
  }&#13;
  &#13;
  module.exports = isLength;&#13;
  &#13;
  },{}],97:[function(require,module,exports){&#13;
  &#13;
  function isObjectLike(value) {&#13;
    return (value &amp;&amp; typeof value == 'object') || false;&#13;
  }&#13;
  &#13;
  module.exports = isObjectLike;&#13;
  &#13;
  },{}],98:[function(require,module,exports){&#13;
  var isObject = require('../lang/isObject');&#13;
  &#13;
  &#13;
  function isStrictComparable(value) {&#13;
    return value === value &amp;&amp; (value === 0 ? ((1 / value) &gt; 0) : !isObject(value));&#13;
  }&#13;
  &#13;
  module.exports = isStrictComparable;&#13;
  &#13;
  },{"../lang/isObject":107}],99:[function(require,module,exports){&#13;
  (function (global){&#13;
  var isNative = require('../lang/isNative');&#13;
  &#13;
  &#13;
  var WeakMap = isNative(WeakMap = global.WeakMap) &amp;&amp; WeakMap;&#13;
  &#13;
  &#13;
  var metaMap = WeakMap &amp;&amp; new WeakMap;&#13;
  &#13;
  module.exports = metaMap;&#13;
  &#13;
  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})&#13;
  },{"../lang/isNative":106}],100:[function(require,module,exports){&#13;
  var isArguments = require('../lang/isArguments'),&#13;
      isArray = require('../lang/isArray'),&#13;
      isIndex = require('./isIndex'),&#13;
      isLength = require('./isLength'),&#13;
      keysIn = require('../object/keysIn'),&#13;
      support = require('../support');&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var hasOwnProperty = objectProto.hasOwnProperty;&#13;
  &#13;
  &#13;
  function shimKeys(object) {&#13;
    var props = keysIn(object),&#13;
        propsLength = props.length,&#13;
        length = propsLength &amp;&amp; object.length;&#13;
  &#13;
    var allowIndexes = length &amp;&amp; isLength(length) &amp;&amp;&#13;
      (isArray(object) || (support.nonEnumArgs &amp;&amp; isArguments(object)));&#13;
  &#13;
    var index = -1,&#13;
        result = [];&#13;
  &#13;
    while (++index &lt; propsLength) {&#13;
      var key = props[index];&#13;
      if ((allowIndexes &amp;&amp; isIndex(key, length)) || hasOwnProperty.call(object, key)) {&#13;
        result.push(key);&#13;
      }&#13;
    }&#13;
    return result;&#13;
  }&#13;
  &#13;
  module.exports = shimKeys;&#13;
  &#13;
  },{"../lang/isArguments":102,"../lang/isArray":103,"../object/keysIn":113,"../support":115,"./isIndex":94,"./isLength":96}],101:[function(require,module,exports){&#13;
  var isObject = require('../lang/isObject');&#13;
  &#13;
  &#13;
  function toObject(value) {&#13;
    return isObject(value) ? value : Object(value);&#13;
  }&#13;
  &#13;
  module.exports = toObject;&#13;
  &#13;
  },{"../lang/isObject":107}],102:[function(require,module,exports){&#13;
  var isLength = require('../internal/isLength'),&#13;
      isObjectLike = require('../internal/isObjectLike');&#13;
  &#13;
  &#13;
  var argsTag = '[object Arguments]';&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var objToString = objectProto.toString;&#13;
  &#13;
  &#13;
  function isArguments(value) {&#13;
    var length = isObjectLike(value) ? value.length : undefined;&#13;
    return (isLength(length) &amp;&amp; objToString.call(value) == argsTag) || false;&#13;
  }&#13;
  &#13;
  module.exports = isArguments;&#13;
  &#13;
  },{"../internal/isLength":96,"../internal/isObjectLike":97}],103:[function(require,module,exports){&#13;
  var isLength = require('../internal/isLength'),&#13;
      isNative = require('./isNative'),&#13;
      isObjectLike = require('../internal/isObjectLike');&#13;
  &#13;
  &#13;
  var arrayTag = '[object Array]';&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var objToString = objectProto.toString;&#13;
  &#13;
  &#13;
  var nativeIsArray = isNative(nativeIsArray = Array.isArray) &amp;&amp; nativeIsArray;&#13;
  &#13;
  &#13;
  var isArray = nativeIsArray || function(value) {&#13;
    return (isObjectLike(value) &amp;&amp; isLength(value.length) &amp;&amp; objToString.call(value) == arrayTag) || false;&#13;
  };&#13;
  &#13;
  module.exports = isArray;&#13;
  &#13;
  },{"../internal/isLength":96,"../internal/isObjectLike":97,"./isNative":106}],104:[function(require,module,exports){&#13;
  var isArguments = require('./isArguments'),&#13;
      isArray = require('./isArray'),&#13;
      isFunction = require('./isFunction'),&#13;
      isLength = require('../internal/isLength'),&#13;
      isObjectLike = require('../internal/isObjectLike'),&#13;
      isString = require('./isString'),&#13;
      keys = require('../object/keys');&#13;
  &#13;
  &#13;
  function isEmpty(value) {&#13;
    if (value == null) {&#13;
      return true;&#13;
    }&#13;
    var length = value.length;&#13;
    if (isLength(length) &amp;&amp; (isArray(value) || isString(value) || isArguments(value) ||&#13;
        (isObjectLike(value) &amp;&amp; isFunction(value.splice)))) {&#13;
      return !length;&#13;
    }&#13;
    return !keys(value).length;&#13;
  }&#13;
  &#13;
  module.exports = isEmpty;&#13;
  &#13;
  },{"../internal/isLength":96,"../internal/isObjectLike":97,"../object/keys":112,"./isArguments":102,"./isArray":103,"./isFunction":105,"./isString":108}],105:[function(require,module,exports){&#13;
  (function (global){&#13;
  var baseIsFunction = require('../internal/baseIsFunction'),&#13;
      isNative = require('./isNative');&#13;
  &#13;
  &#13;
  var funcTag = '[object Function]';&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var objToString = objectProto.toString;&#13;
  &#13;
  &#13;
  var Uint8Array = isNative(Uint8Array = global.Uint8Array) &amp;&amp; Uint8Array;&#13;
  &#13;
  &#13;
  var isFunction = !(baseIsFunction(/x/) || (Uint8Array &amp;&amp; !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {&#13;
    return objToString.call(value) == funcTag;&#13;
  };&#13;
  &#13;
  module.exports = isFunction;&#13;
  &#13;
  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})&#13;
  },{"../internal/baseIsFunction":81,"./isNative":106}],106:[function(require,module,exports){&#13;
  var escapeRegExp = require('../string/escapeRegExp'),&#13;
      isObjectLike = require('../internal/isObjectLike');&#13;
  &#13;
  &#13;
  var funcTag = '[object Function]';&#13;
  &#13;
  &#13;
  var reHostCtor = /^\[object .+?Constructor\]$/;&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var fnToString = Function.prototype.toString;&#13;
  &#13;
  &#13;
  var objToString = objectProto.toString;&#13;
  &#13;
  &#13;
  var reNative = RegExp('^' +&#13;
    escapeRegExp(objToString)&#13;
    .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'&#13;
  );&#13;
  &#13;
  &#13;
  function isNative(value) {&#13;
    if (value == null) {&#13;
      return false;&#13;
    }&#13;
    if (objToString.call(value) == funcTag) {&#13;
      return reNative.test(fnToString.call(value));&#13;
    }&#13;
    return (isObjectLike(value) &amp;&amp; reHostCtor.test(value)) || false;&#13;
  }&#13;
  &#13;
  module.exports = isNative;&#13;
  &#13;
  },{"../internal/isObjectLike":97,"../string/escapeRegExp":114}],107:[function(require,module,exports){&#13;
  &#13;
  function isObject(value) {&#13;
    var type = typeof value;&#13;
    return type == 'function' || (value &amp;&amp; type == 'object') || false;&#13;
  }&#13;
  &#13;
  module.exports = isObject;&#13;
  &#13;
  },{}],108:[function(require,module,exports){&#13;
  var isObjectLike = require('../internal/isObjectLike');&#13;
  &#13;
  &#13;
  var stringTag = '[object String]';&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var objToString = objectProto.toString;&#13;
  &#13;
  &#13;
  function isString(value) {&#13;
    return typeof value == 'string' || (isObjectLike(value) &amp;&amp; objToString.call(value) == stringTag) || false;&#13;
  }&#13;
  &#13;
  module.exports = isString;&#13;
  &#13;
  },{"../internal/isObjectLike":97}],109:[function(require,module,exports){&#13;
  var isLength = require('../internal/isLength'),&#13;
      isObjectLike = require('../internal/isObjectLike');&#13;
  &#13;
  &#13;
  var argsTag = '[object Arguments]',&#13;
      arrayTag = '[object Array]',&#13;
      boolTag = '[object Boolean]',&#13;
      dateTag = '[object Date]',&#13;
      errorTag = '[object Error]',&#13;
      funcTag = '[object Function]',&#13;
      mapTag = '[object Map]',&#13;
      numberTag = '[object Number]',&#13;
      objectTag = '[object Object]',&#13;
      regexpTag = '[object RegExp]',&#13;
      setTag = '[object Set]',&#13;
      stringTag = '[object String]',&#13;
      weakMapTag = '[object WeakMap]';&#13;
  &#13;
  var arrayBufferTag = '[object ArrayBuffer]',&#13;
      float32Tag = '[object Float32Array]',&#13;
      float64Tag = '[object Float64Array]',&#13;
      int8Tag = '[object Int8Array]',&#13;
      int16Tag = '[object Int16Array]',&#13;
      int32Tag = '[object Int32Array]',&#13;
      uint8Tag = '[object Uint8Array]',&#13;
      uint8ClampedTag = '[object Uint8ClampedArray]',&#13;
      uint16Tag = '[object Uint16Array]',&#13;
      uint32Tag = '[object Uint32Array]';&#13;
  &#13;
  &#13;
  var typedArrayTags = {};&#13;
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =&#13;
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =&#13;
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =&#13;
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =&#13;
  typedArrayTags[uint32Tag] = true;&#13;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =&#13;
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =&#13;
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =&#13;
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =&#13;
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =&#13;
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =&#13;
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var objToString = objectProto.toString;&#13;
  &#13;
  &#13;
  function isTypedArray(value) {&#13;
    return (isObjectLike(value) &amp;&amp; isLength(value.length) &amp;&amp; typedArrayTags[objToString.call(value)]) || false;&#13;
  }&#13;
  &#13;
  module.exports = isTypedArray;&#13;
  &#13;
  },{"../internal/isLength":96,"../internal/isObjectLike":97}],110:[function(require,module,exports){&#13;
  var baseAssign = require('../internal/baseAssign'),&#13;
      createAssigner = require('../internal/createAssigner');&#13;
  &#13;
  &#13;
  var assign = createAssigner(baseAssign);&#13;
  &#13;
  module.exports = assign;&#13;
  &#13;
  },{"../internal/baseAssign":71,"../internal/createAssigner":89}],111:[function(require,module,exports){&#13;
  var baseCopy = require('../internal/baseCopy'),&#13;
      baseCreate = require('../internal/baseCreate'),&#13;
      isIterateeCall = require('../internal/isIterateeCall'),&#13;
      keys = require('./keys');&#13;
  &#13;
  &#13;
  function create(prototype, properties, guard) {&#13;
    var result = baseCreate(prototype);&#13;
    if (guard &amp;&amp; isIterateeCall(prototype, properties, guard)) {&#13;
      properties = null;&#13;
    }&#13;
    return properties ? baseCopy(properties, result, keys(properties)) : result;&#13;
  }&#13;
  &#13;
  module.exports = create;&#13;
  &#13;
  },{"../internal/baseCopy":73,"../internal/baseCreate":74,"../internal/isIterateeCall":95,"./keys":112}],112:[function(require,module,exports){&#13;
  var isLength = require('../internal/isLength'),&#13;
      isNative = require('../lang/isNative'),&#13;
      isObject = require('../lang/isObject'),&#13;
      shimKeys = require('../internal/shimKeys');&#13;
  &#13;
  &#13;
  var nativeKeys = isNative(nativeKeys = Object.keys) &amp;&amp; nativeKeys;&#13;
  &#13;
  &#13;
  var keys = !nativeKeys ? shimKeys : function(object) {&#13;
    if (object) {&#13;
      var Ctor = object.constructor,&#13;
          length = object.length;&#13;
    }&#13;
    if ((typeof Ctor == 'function' &amp;&amp; Ctor.prototype === object) ||&#13;
        (typeof object != 'function' &amp;&amp; (length &amp;&amp; isLength(length)))) {&#13;
      return shimKeys(object);&#13;
    }&#13;
    return isObject(object) ? nativeKeys(object) : [];&#13;
  };&#13;
  &#13;
  module.exports = keys;&#13;
  &#13;
  },{"../internal/isLength":96,"../internal/shimKeys":100,"../lang/isNative":106,"../lang/isObject":107}],113:[function(require,module,exports){&#13;
  var isArguments = require('../lang/isArguments'),&#13;
      isArray = require('../lang/isArray'),&#13;
      isIndex = require('../internal/isIndex'),&#13;
      isLength = require('../internal/isLength'),&#13;
      isObject = require('../lang/isObject'),&#13;
      support = require('../support');&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var hasOwnProperty = objectProto.hasOwnProperty;&#13;
  &#13;
  &#13;
  function keysIn(object) {&#13;
    if (object == null) {&#13;
      return [];&#13;
    }&#13;
    if (!isObject(object)) {&#13;
      object = Object(object);&#13;
    }&#13;
    var length = object.length;&#13;
    length = (length &amp;&amp; isLength(length) &amp;&amp;&#13;
      (isArray(object) || (support.nonEnumArgs &amp;&amp; isArguments(object))) &amp;&amp; length) || 0;&#13;
  &#13;
    var Ctor = object.constructor,&#13;
        index = -1,&#13;
        isProto = typeof Ctor == 'function' &amp;&amp; Ctor.prototype === object,&#13;
        result = Array(length),&#13;
        skipIndexes = length &gt; 0;&#13;
  &#13;
    while (++index &lt; length) {&#13;
      result[index] = (index + '');&#13;
    }&#13;
    for (var key in object) {&#13;
      if (!(skipIndexes &amp;&amp; isIndex(key, length)) &amp;&amp;&#13;
          !(key == 'constructor' &amp;&amp; (isProto || !hasOwnProperty.call(object, key)))) {&#13;
        result.push(key);&#13;
      }&#13;
    }&#13;
    return result;&#13;
  }&#13;
  &#13;
  module.exports = keysIn;&#13;
  &#13;
  },{"../internal/isIndex":94,"../internal/isLength":96,"../lang/isArguments":102,"../lang/isArray":103,"../lang/isObject":107,"../support":115}],114:[function(require,module,exports){&#13;
  var baseToString = require('../internal/baseToString');&#13;
  &#13;
  &#13;
  var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,&#13;
      reHasRegExpChars = RegExp(reRegExpChars.source);&#13;
  &#13;
  &#13;
  function escapeRegExp(string) {&#13;
    string = baseToString(string);&#13;
    return (string &amp;&amp; reHasRegExpChars.test(string))&#13;
      ? string.replace(reRegExpChars, '\\$&amp;')&#13;
      : string;&#13;
  }&#13;
  &#13;
  module.exports = escapeRegExp;&#13;
  &#13;
  },{"../internal/baseToString":87}],115:[function(require,module,exports){&#13;
  (function (global){&#13;
  var isNative = require('./lang/isNative');&#13;
  &#13;
  &#13;
  var reThis = /\bthis\b/;&#13;
  &#13;
  &#13;
  var objectProto = Object.prototype;&#13;
  &#13;
  &#13;
  var document = (document = global.window) &amp;&amp; document.document;&#13;
  &#13;
  &#13;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;&#13;
  &#13;
  &#13;
  var support = {};&#13;
  &#13;
  (function(x) {&#13;
  &#13;
  &#13;
    support.funcDecomp = !isNative(global.WinRTError) &amp;&amp; reThis.test(function() { return this; });&#13;
  &#13;
  &#13;
    support.funcNames = typeof Function.name == 'string';&#13;
  &#13;
  &#13;
    try {&#13;
      support.dom = document.createDocumentFragment().nodeType === 11;&#13;
    } catch(e) {&#13;
      support.dom = false;&#13;
    }&#13;
  &#13;
  &#13;
    try {&#13;
      support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);&#13;
    } catch(e) {&#13;
      support.nonEnumArgs = true;&#13;
    }&#13;
  }(0, 0));&#13;
  &#13;
  module.exports = support;&#13;
  &#13;
  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})&#13;
  },{"./lang/isNative":106}],116:[function(require,module,exports){&#13;
  &#13;
  function identity(value) {&#13;
    return value;&#13;
  }&#13;
  &#13;
  module.exports = identity;&#13;
  &#13;
  },{}],117:[function(require,module,exports){&#13;
  var process = module.exports = {};&#13;
  &#13;
  &#13;
  var cachedSetTimeout;&#13;
  var cachedClearTimeout;&#13;
  &#13;
  function defaultSetTimout() {&#13;
      throw new Error('setTimeout has not been defined');&#13;
  }&#13;
  function defaultClearTimeout () {&#13;
      throw new Error('clearTimeout has not been defined');&#13;
  }&#13;
  (function () {&#13;
      try {&#13;
          if (typeof setTimeout === 'function') {&#13;
              cachedSetTimeout = setTimeout;&#13;
          } else {&#13;
              cachedSetTimeout = defaultSetTimout;&#13;
          }&#13;
      } catch (e) {&#13;
          cachedSetTimeout = defaultSetTimout;&#13;
      }&#13;
      try {&#13;
          if (typeof clearTimeout === 'function') {&#13;
              cachedClearTimeout = clearTimeout;&#13;
          } else {&#13;
              cachedClearTimeout = defaultClearTimeout;&#13;
          }&#13;
      } catch (e) {&#13;
          cachedClearTimeout = defaultClearTimeout;&#13;
      }&#13;
  } ())&#13;
  function runTimeout(fun) {&#13;
      if (cachedSetTimeout === setTimeout) {&#13;
          return setTimeout(fun, 0);&#13;
      }&#13;
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &amp;&amp; setTimeout) {&#13;
          cachedSetTimeout = setTimeout;&#13;
          return setTimeout(fun, 0);&#13;
      }&#13;
      try {&#13;
          return cachedSetTimeout(fun, 0);&#13;
      } catch(e){&#13;
          try {&#13;
              return cachedSetTimeout.call(null, fun, 0);&#13;
          } catch(e){&#13;
              return cachedSetTimeout.call(this, fun, 0);&#13;
          }&#13;
      }&#13;
  &#13;
  &#13;
  }&#13;
  function runClearTimeout(marker) {&#13;
      if (cachedClearTimeout === clearTimeout) {&#13;
          return clearTimeout(marker);&#13;
      }&#13;
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &amp;&amp; clearTimeout) {&#13;
          cachedClearTimeout = clearTimeout;&#13;
          return clearTimeout(marker);&#13;
      }&#13;
      try {&#13;
          return cachedClearTimeout(marker);&#13;
      } catch (e){&#13;
          try {&#13;
              return cachedClearTimeout.call(null, marker);&#13;
          } catch (e){&#13;
              return cachedClearTimeout.call(this, marker);&#13;
          }&#13;
      }&#13;
  &#13;
  &#13;
  &#13;
  }&#13;
  var queue = [];&#13;
  var draining = false;&#13;
  var currentQueue;&#13;
  var queueIndex = -1;&#13;
  &#13;
  function cleanUpNextTick() {&#13;
      if (!draining || !currentQueue) {&#13;
          return;&#13;
      }&#13;
      draining = false;&#13;
      if (currentQueue.length) {&#13;
          queue = currentQueue.concat(queue);&#13;
      } else {&#13;
          queueIndex = -1;&#13;
      }&#13;
      if (queue.length) {&#13;
          drainQueue();&#13;
      }&#13;
  }&#13;
  &#13;
  function drainQueue() {&#13;
      if (draining) {&#13;
          return;&#13;
      }&#13;
      var timeout = runTimeout(cleanUpNextTick);&#13;
      draining = true;&#13;
  &#13;
      var len = queue.length;&#13;
      while(len) {&#13;
          currentQueue = queue;&#13;
          queue = [];&#13;
          while (++queueIndex &lt; len) {&#13;
              if (currentQueue) {&#13;
                  currentQueue[queueIndex].run();&#13;
              }&#13;
          }&#13;
          queueIndex = -1;&#13;
          len = queue.length;&#13;
      }&#13;
      currentQueue = null;&#13;
      draining = false;&#13;
      runClearTimeout(timeout);&#13;
  }&#13;
  &#13;
  process.nextTick = function (fun) {&#13;
      var args = new Array(arguments.length - 1);&#13;
      if (arguments.length &gt; 1) {&#13;
          for (var i = 1; i &lt; arguments.length; i++) {&#13;
              args[i - 1] = arguments[i];&#13;
          }&#13;
      }&#13;
      queue.push(new Item(fun, args));&#13;
      if (queue.length === 1 &amp;&amp; !draining) {&#13;
          runTimeout(drainQueue);&#13;
      }&#13;
  };&#13;
  &#13;
  function Item(fun, array) {&#13;
      this.fun = fun;&#13;
      this.array = array;&#13;
  }&#13;
  Item.prototype.run = function () {&#13;
      this.fun.apply(null, this.array);&#13;
  };&#13;
  process.title = 'browser';&#13;
  process.browser = true;&#13;
  process.env = {};&#13;
  process.argv = [];&#13;
  process.version = ''; // empty string to avoid regexp issues&#13;
  process.versions = {};&#13;
  &#13;
  function noop() {}&#13;
  &#13;
  process.on = noop;&#13;
  process.addListener = noop;&#13;
  process.once = noop;&#13;
  process.off = noop;&#13;
  process.removeListener = noop;&#13;
  process.removeAllListeners = noop;&#13;
  process.emit = noop;&#13;
  &#13;
  process.binding = function (name) {&#13;
      throw new Error('process.binding is not supported');&#13;
  };&#13;
  &#13;
  process.cwd = function () { return '/' };&#13;
  process.chdir = function (dir) {&#13;
      throw new Error('process.chdir is not supported');&#13;
  };&#13;
  process.umask = function() { return 0; };&#13;
  &#13;
  },{}],118:[function(require,module,exports){&#13;
  (function (global){&#13;
  &#13;
  ;(function(root) {&#13;
  &#13;
  &#13;
    var freeExports = typeof exports == 'object' &amp;&amp; exports &amp;&amp;&#13;
      !exports.nodeType &amp;&amp; exports;&#13;
    var freeModule = typeof module == 'object' &amp;&amp; module &amp;&amp;&#13;
      !module.nodeType &amp;&amp; module;&#13;
    var freeGlobal = typeof global == 'object' &amp;&amp; global;&#13;
    if (&#13;
      freeGlobal.global === freeGlobal ||&#13;
      freeGlobal.window === freeGlobal ||&#13;
      freeGlobal.self === freeGlobal&#13;
    ) {&#13;
      root = freeGlobal;&#13;
    }&#13;
  &#13;
  &#13;
    var punycode,&#13;
  &#13;
  &#13;
    maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1&#13;
  &#13;
  &#13;
    base = 36,&#13;
    tMin = 1,&#13;
    tMax = 26,&#13;
    skew = 38,&#13;
    damp = 700,&#13;
    initialBias = 72,&#13;
    initialN = 128, // 0x80&#13;
    delimiter = '-', // '\x2D'&#13;
  &#13;
  &#13;
    regexPunycode = /^xn--/,&#13;
    regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars&#13;
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators&#13;
  &#13;
  &#13;
    errors = {&#13;
      'overflow': 'Overflow: input needs wider integers to process',&#13;
      'not-basic': 'Illegal input &gt;= 0x80 (not a basic code point)',&#13;
      'invalid-input': 'Invalid input'&#13;
    },&#13;
  &#13;
  &#13;
    baseMinusTMin = base - tMin,&#13;
    floor = Math.floor,&#13;
    stringFromCharCode = String.fromCharCode,&#13;
  &#13;
  &#13;
    key;&#13;
  &#13;
  &#13;
  &#13;
  &#13;
    function error(type) {&#13;
      throw new RangeError(errors[type]);&#13;
    }&#13;
  &#13;
  &#13;
    function map(array, fn) {&#13;
      var length = array.length;&#13;
      var result = [];&#13;
      while (length--) {&#13;
        result[length] = fn(array[length]);&#13;
      }&#13;
      return result;&#13;
    }&#13;
  &#13;
  &#13;
    function mapDomain(string, fn) {&#13;
      var parts = string.split('@');&#13;
      var result = '';&#13;
      if (parts.length &gt; 1) {&#13;
        result = parts[0] + '@';&#13;
        string = parts[1];&#13;
      }&#13;
      string = string.replace(regexSeparators, '\x2E');&#13;
      var labels = string.split('.');&#13;
      var encoded = map(labels, fn).join('.');&#13;
      return result + encoded;&#13;
    }&#13;
  &#13;
  &#13;
    function ucs2decode(string) {&#13;
      var output = [],&#13;
          counter = 0,&#13;
          length = string.length,&#13;
          value,&#13;
          extra;&#13;
      while (counter &lt; length) {&#13;
        value = string.charCodeAt(counter++);&#13;
        if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {&#13;
          extra = string.charCodeAt(counter++);&#13;
          if ((extra &amp; 0xFC00) == 0xDC00) { // low surrogate&#13;
            output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);&#13;
          } else {&#13;
            output.push(value);&#13;
            counter--;&#13;
          }&#13;
        } else {&#13;
          output.push(value);&#13;
        }&#13;
      }&#13;
      return output;&#13;
    }&#13;
  &#13;
  &#13;
    function ucs2encode(array) {&#13;
      return map(array, function(value) {&#13;
        var output = '';&#13;
        if (value &gt; 0xFFFF) {&#13;
          value -= 0x10000;&#13;
          output += stringFromCharCode(value &gt;&gt;&gt; 10 &amp; 0x3FF | 0xD800);&#13;
          value = 0xDC00 | value &amp; 0x3FF;&#13;
        }&#13;
        output += stringFromCharCode(value);&#13;
        return output;&#13;
      }).join('');&#13;
    }&#13;
  &#13;
  &#13;
    function basicToDigit(codePoint) {&#13;
      if (codePoint - 48 &lt; 10) {&#13;
        return codePoint - 22;&#13;
      }&#13;
      if (codePoint - 65 &lt; 26) {&#13;
        return codePoint - 65;&#13;
      }&#13;
      if (codePoint - 97 &lt; 26) {&#13;
        return codePoint - 97;&#13;
      }&#13;
      return base;&#13;
    }&#13;
  &#13;
  &#13;
    function digitToBasic(digit, flag) {&#13;
      return digit + 22 + 75 * (digit &lt; 26) - ((flag != 0) &lt;&lt; 5);&#13;
    }&#13;
  &#13;
  &#13;
    function adapt(delta, numPoints, firstTime) {&#13;
      var k = 0;&#13;
      delta = firstTime ? floor(delta / damp) : delta &gt;&gt; 1;&#13;
      delta += floor(delta / numPoints);&#13;
      for (/* no initialization */; delta &gt; baseMinusTMin * tMax &gt;&gt; 1; k += base) {&#13;
        delta = floor(delta / baseMinusTMin);&#13;
      }&#13;
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));&#13;
    }&#13;
  &#13;
  &#13;
    function decode(input) {&#13;
      var output = [],&#13;
          inputLength = input.length,&#13;
          out,&#13;
          i = 0,&#13;
          n = initialN,&#13;
          bias = initialBias,&#13;
          basic,&#13;
          j,&#13;
          index,&#13;
          oldi,&#13;
          w,&#13;
          k,&#13;
          digit,&#13;
          t,&#13;
  &#13;
          baseMinusT;&#13;
  &#13;
  &#13;
      basic = input.lastIndexOf(delimiter);&#13;
      if (basic &lt; 0) {&#13;
        basic = 0;&#13;
      }&#13;
  &#13;
      for (j = 0; j &lt; basic; ++j) {&#13;
        if (input.charCodeAt(j) &gt;= 0x80) {&#13;
          error('not-basic');&#13;
        }&#13;
        output.push(input.charCodeAt(j));&#13;
      }&#13;
  &#13;
  &#13;
      for (index = basic &gt; 0 ? basic + 1 : 0; index &lt; inputLength; /* no final expression */) {&#13;
  &#13;
        for (oldi = i, w = 1, k = base; /* no condition */; k += base) {&#13;
  &#13;
          if (index &gt;= inputLength) {&#13;
            error('invalid-input');&#13;
          }&#13;
  &#13;
          digit = basicToDigit(input.charCodeAt(index++));&#13;
  &#13;
          if (digit &gt;= base || digit &gt; floor((maxInt - i) / w)) {&#13;
            error('overflow');&#13;
          }&#13;
  &#13;
          i += digit * w;&#13;
          t = k &lt;= bias ? tMin : (k &gt;= bias + tMax ? tMax : k - bias);&#13;
  &#13;
          if (digit &lt; t) {&#13;
            break;&#13;
          }&#13;
  &#13;
          baseMinusT = base - t;&#13;
          if (w &gt; floor(maxInt / baseMinusT)) {&#13;
            error('overflow');&#13;
          }&#13;
  &#13;
          w *= baseMinusT;&#13;
  &#13;
        }&#13;
  &#13;
        out = output.length + 1;&#13;
        bias = adapt(i - oldi, out, oldi == 0);&#13;
  &#13;
        if (floor(i / out) &gt; maxInt - n) {&#13;
          error('overflow');&#13;
        }&#13;
  &#13;
        n += floor(i / out);&#13;
        i %= out;&#13;
  &#13;
        output.splice(i++, 0, n);&#13;
  &#13;
      }&#13;
  &#13;
      return ucs2encode(output);&#13;
    }&#13;
  &#13;
  &#13;
    function encode(input) {&#13;
      var n,&#13;
          delta,&#13;
          handledCPCount,&#13;
          basicLength,&#13;
          bias,&#13;
          j,&#13;
          m,&#13;
          q,&#13;
          k,&#13;
          t,&#13;
          currentValue,&#13;
          output = [],&#13;
  &#13;
          inputLength,&#13;
  &#13;
          handledCPCountPlusOne,&#13;
          baseMinusT,&#13;
          qMinusT;&#13;
  &#13;
      input = ucs2decode(input);&#13;
  &#13;
      inputLength = input.length;&#13;
  &#13;
      n = initialN;&#13;
      delta = 0;&#13;
      bias = initialBias;&#13;
  &#13;
      for (j = 0; j &lt; inputLength; ++j) {&#13;
        currentValue = input[j];&#13;
        if (currentValue &lt; 0x80) {&#13;
          output.push(stringFromCharCode(currentValue));&#13;
        }&#13;
      }&#13;
  &#13;
      handledCPCount = basicLength = output.length;&#13;
  &#13;
  &#13;
      if (basicLength) {&#13;
        output.push(delimiter);&#13;
      }&#13;
  &#13;
      while (handledCPCount &lt; inputLength) {&#13;
  &#13;
        for (m = maxInt, j = 0; j &lt; inputLength; ++j) {&#13;
          currentValue = input[j];&#13;
          if (currentValue &gt;= n &amp;&amp; currentValue &lt; m) {&#13;
            m = currentValue;&#13;
          }&#13;
        }&#13;
  &#13;
        handledCPCountPlusOne = handledCPCount + 1;&#13;
        if (m - n &gt; floor((maxInt - delta) / handledCPCountPlusOne)) {&#13;
          error('overflow');&#13;
        }&#13;
  &#13;
        delta += (m - n) * handledCPCountPlusOne;&#13;
        n = m;&#13;
  &#13;
        for (j = 0; j &lt; inputLength; ++j) {&#13;
          currentValue = input[j];&#13;
  &#13;
          if (currentValue &lt; n &amp;&amp; ++delta &gt; maxInt) {&#13;
            error('overflow');&#13;
          }&#13;
  &#13;
          if (currentValue == n) {&#13;
            for (q = delta, k = base; /* no condition */; k += base) {&#13;
              t = k &lt;= bias ? tMin : (k &gt;= bias + tMax ? tMax : k - bias);&#13;
              if (q &lt; t) {&#13;
                break;&#13;
              }&#13;
              qMinusT = q - t;&#13;
              baseMinusT = base - t;&#13;
              output.push(&#13;
                stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))&#13;
              );&#13;
              q = floor(qMinusT / baseMinusT);&#13;
            }&#13;
  &#13;
            output.push(stringFromCharCode(digitToBasic(q, 0)));&#13;
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);&#13;
            delta = 0;&#13;
            ++handledCPCount;&#13;
          }&#13;
        }&#13;
  &#13;
        ++delta;&#13;
        ++n;&#13;
  &#13;
      }&#13;
      return output.join('');&#13;
    }&#13;
  &#13;
  &#13;
    function toUnicode(input) {&#13;
      return mapDomain(input, function(string) {&#13;
        return regexPunycode.test(string)&#13;
          ? decode(string.slice(4).toLowerCase())&#13;
          : string;&#13;
      });&#13;
    }&#13;
  &#13;
  &#13;
    function toASCII(input) {&#13;
      return mapDomain(input, function(string) {&#13;
        return regexNonASCII.test(string)&#13;
          ? 'xn--' + encode(string)&#13;
          : string;&#13;
      });&#13;
    }&#13;
  &#13;
  &#13;
  &#13;
  &#13;
    punycode = {&#13;
  &#13;
      'version': '1.4.1',&#13;
  &#13;
      'ucs2': {&#13;
        'decode': ucs2decode,&#13;
        'encode': ucs2encode&#13;
      },&#13;
      'decode': decode,&#13;
      'encode': encode,&#13;
      'toASCII': toASCII,&#13;
      'toUnicode': toUnicode&#13;
    };&#13;
  &#13;
  &#13;
    if (&#13;
      typeof define == 'function' &amp;&amp;&#13;
      typeof define.amd == 'object' &amp;&amp;&#13;
      define.amd&#13;
    ) {&#13;
      define('punycode', function() {&#13;
        return punycode;&#13;
      });&#13;
    } else if (freeExports &amp;&amp; freeModule) {&#13;
      if (module.exports == freeExports) {&#13;
        freeModule.exports = punycode;&#13;
      } else {&#13;
        for (key in punycode) {&#13;
          punycode.hasOwnProperty(key) &amp;&amp; (freeExports[key] = punycode[key]);&#13;
        }&#13;
      }&#13;
    } else {&#13;
      root.punycode = punycode;&#13;
    }&#13;
  &#13;
  }(this));&#13;
  &#13;
  }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})&#13;
  },{}],119:[function(require,module,exports){&#13;
  &#13;
  'use strict';&#13;
  &#13;
  function hasOwnProperty(obj, prop) {&#13;
    return Object.prototype.hasOwnProperty.call(obj, prop);&#13;
  }&#13;
  &#13;
  module.exports = function(qs, sep, eq, options) {&#13;
    sep = sep || '&amp;';&#13;
    eq = eq || '=';&#13;
    var obj = {};&#13;
  &#13;
    if (typeof qs !== 'string' || qs.length === 0) {&#13;
      return obj;&#13;
    }&#13;
  &#13;
    var regexp = /\+/g;&#13;
    qs = qs.split(sep);&#13;
  &#13;
    var maxKeys = 1000;&#13;
    if (options &amp;&amp; typeof options.maxKeys === 'number') {&#13;
      maxKeys = options.maxKeys;&#13;
    }&#13;
  &#13;
    var len = qs.length;&#13;
    if (maxKeys &gt; 0 &amp;&amp; len &gt; maxKeys) {&#13;
      len = maxKeys;&#13;
    }&#13;
  &#13;
    for (var i = 0; i &lt; len; ++i) {&#13;
      var x = qs[i].replace(regexp, '%20'),&#13;
          idx = x.indexOf(eq),&#13;
          kstr, vstr, k, v;&#13;
  &#13;
      if (idx &gt;= 0) {&#13;
        kstr = x.substr(0, idx);&#13;
        vstr = x.substr(idx + 1);&#13;
      } else {&#13;
        kstr = x;&#13;
        vstr = '';&#13;
      }&#13;
  &#13;
      k = decodeURIComponent(kstr);&#13;
      v = decodeURIComponent(vstr);&#13;
  &#13;
      if (!hasOwnProperty(obj, k)) {&#13;
        obj[k] = v;&#13;
      } else if (isArray(obj[k])) {&#13;
        obj[k].push(v);&#13;
      } else {&#13;
        obj[k] = [obj[k], v];&#13;
      }&#13;
    }&#13;
  &#13;
    return obj;&#13;
  };&#13;
  &#13;
  var isArray = Array.isArray || function (xs) {&#13;
    return Object.prototype.toString.call(xs) === '[object Array]';&#13;
  };&#13;
  &#13;
  },{}],120:[function(require,module,exports){&#13;
  &#13;
  'use strict';&#13;
  &#13;
  var stringifyPrimitive = function(v) {&#13;
    switch (typeof v) {&#13;
      case 'string':&#13;
        return v;&#13;
  &#13;
      case 'boolean':&#13;
        return v ? 'true' : 'false';&#13;
  &#13;
      case 'number':&#13;
        return isFinite(v) ? v : '';&#13;
  &#13;
      default:&#13;
        return '';&#13;
    }&#13;
  };&#13;
  &#13;
  module.exports = function(obj, sep, eq, name) {&#13;
    sep = sep || '&amp;';&#13;
    eq = eq || '=';&#13;
    if (obj === null) {&#13;
      obj = undefined;&#13;
    }&#13;
  &#13;
    if (typeof obj === 'object') {&#13;
      return map(objectKeys(obj), function(k) {&#13;
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;&#13;
        if (isArray(obj[k])) {&#13;
          return map(obj[k], function(v) {&#13;
            return ks + encodeURIComponent(stringifyPrimitive(v));&#13;
          }).join(sep);&#13;
        } else {&#13;
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));&#13;
        }&#13;
      }).join(sep);&#13;
  &#13;
    }&#13;
  &#13;
    if (!name) return '';&#13;
    return encodeURIComponent(stringifyPrimitive(name)) + eq +&#13;
           encodeURIComponent(stringifyPrimitive(obj));&#13;
  };&#13;
  &#13;
  var isArray = Array.isArray || function (xs) {&#13;
    return Object.prototype.toString.call(xs) === '[object Array]';&#13;
  };&#13;
  &#13;
  function map (xs, f) {&#13;
    if (xs.map) return xs.map(f);&#13;
    var res = [];&#13;
    for (var i = 0; i &lt; xs.length; i++) {&#13;
      res.push(f(xs[i], i));&#13;
    }&#13;
    return res;&#13;
  }&#13;
  &#13;
  var objectKeys = Object.keys || function (obj) {&#13;
    var res = [];&#13;
    for (var key in obj) {&#13;
      if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);&#13;
    }&#13;
    return res;&#13;
  };&#13;
  &#13;
  },{}],121:[function(require,module,exports){&#13;
  'use strict';&#13;
  &#13;
  exports.decode = exports.parse = require('./decode');&#13;
  exports.encode = exports.stringify = require('./encode');&#13;
  &#13;
  },{"./decode":119,"./encode":120}],122:[function(require,module,exports){&#13;
  &#13;
  'use strict';&#13;
  &#13;
  function hasOwnProperty(obj, prop) {&#13;
    return Object.prototype.hasOwnProperty.call(obj, prop);&#13;
  }&#13;
  &#13;
  module.exports = function(qs, sep, eq, options) {&#13;
    sep = sep || '&amp;';&#13;
    eq = eq || '=';&#13;
    var obj = {};&#13;
  &#13;
    if (typeof qs !== 'string' || qs.length === 0) {&#13;
      return obj;&#13;
    }&#13;
  &#13;
    var regexp = /\+/g;&#13;
    qs = qs.split(sep);&#13;
  &#13;
    var maxKeys = 1000;&#13;
    if (options &amp;&amp; typeof options.maxKeys === 'number') {&#13;
      maxKeys = options.maxKeys;&#13;
    }&#13;
  &#13;
    var len = qs.length;&#13;
    if (maxKeys &gt; 0 &amp;&amp; len &gt; maxKeys) {&#13;
      len = maxKeys;&#13;
    }&#13;
  &#13;
    for (var i = 0; i &lt; len; ++i) {&#13;
      var x = qs[i].replace(regexp, '%20'),&#13;
          idx = x.indexOf(eq),&#13;
          kstr, vstr, k, v;&#13;
  &#13;
      if (idx &gt;= 0) {&#13;
        kstr = x.substr(0, idx);&#13;
        vstr = x.substr(idx + 1);&#13;
      } else {&#13;
        kstr = x;&#13;
        vstr = '';&#13;
      }&#13;
  &#13;
      k = decodeURIComponent(kstr);&#13;
      v = decodeURIComponent(vstr);&#13;
  &#13;
      if (!hasOwnProperty(obj, k)) {&#13;
        obj[k] = v;&#13;
      } else if (Array.isArray(obj[k])) {&#13;
        obj[k].push(v);&#13;
      } else {&#13;
        obj[k] = [obj[k], v];&#13;
      }&#13;
    }&#13;
  &#13;
    return obj;&#13;
  };&#13;
  &#13;
  },{}],123:[function(require,module,exports){&#13;
  &#13;
  'use strict';&#13;
  &#13;
  var stringifyPrimitive = function(v) {&#13;
    switch (typeof v) {&#13;
      case 'string':&#13;
        return v;&#13;
  &#13;
      case 'boolean':&#13;
        return v ? 'true' : 'false';&#13;
  &#13;
      case 'number':&#13;
        return isFinite(v) ? v : '';&#13;
  &#13;
      default:&#13;
        return '';&#13;
    }&#13;
  };&#13;
  &#13;
  module.exports = function(obj, sep, eq, name) {&#13;
    sep = sep || '&amp;';&#13;
    eq = eq || '=';&#13;
    if (obj === null) {&#13;
      obj = undefined;&#13;
    }&#13;
  &#13;
    if (typeof obj === 'object') {&#13;
      return Object.keys(obj).map(function(k) {&#13;
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;&#13;
        if (Array.isArray(obj[k])) {&#13;
          return obj[k].map(function(v) {&#13;
            return ks + encodeURIComponent(stringifyPrimitive(v));&#13;
          }).join(sep);&#13;
        } else {&#13;
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));&#13;
        }&#13;
      }).join(sep);&#13;
  &#13;
    }&#13;
  &#13;
    if (!name) return '';&#13;
    return encodeURIComponent(stringifyPrimitive(name)) + eq +&#13;
           encodeURIComponent(stringifyPrimitive(obj));&#13;
  };&#13;
  &#13;
  },{}],124:[function(require,module,exports){&#13;
  arguments[4][121][0].apply(exports,arguments)&#13;
  },{"./decode":122,"./encode":123,"dup":121}],125:[function(require,module,exports){&#13;
  &#13;
  var punycode = require('punycode');&#13;
  &#13;
  exports.parse = urlParse;&#13;
  exports.resolve = urlResolve;&#13;
  exports.resolveObject = urlResolveObject;&#13;
  exports.format = urlFormat;&#13;
  &#13;
  exports.Url = Url;&#13;
  &#13;
  function Url() {&#13;
    this.protocol = null;&#13;
    this.slashes = null;&#13;
    this.auth = null;&#13;
    this.host = null;&#13;
    this.port = null;&#13;
    this.hostname = null;&#13;
    this.hash = null;&#13;
    this.search = null;&#13;
    this.query = null;&#13;
    this.pathname = null;&#13;
    this.path = null;&#13;
    this.href = null;&#13;
  }&#13;
  &#13;
  &#13;
  var protocolPattern = /^([a-z0-9.+-]+:)/i,&#13;
      portPattern = /:[0-9]*$/,&#13;
  &#13;
      delims = ['&lt;', '&gt;', '"', '`', ' ', '\r', '\n', '\t'],&#13;
  &#13;
      unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),&#13;
  &#13;
      autoEscape = ['\''].concat(unwise),&#13;
      nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),&#13;
      hostEndingChars = ['/', '?', '#'],&#13;
      hostnameMaxLen = 255,&#13;
      hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,&#13;
      hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,&#13;
      unsafeProtocol = {&#13;
        'javascript': true,&#13;
        'javascript:': true&#13;
      },&#13;
      hostlessProtocol = {&#13;
        'javascript': true,&#13;
        'javascript:': true&#13;
      },&#13;
      slashedProtocol = {&#13;
        'http': true,&#13;
        'https': true,&#13;
        'ftp': true,&#13;
        'gopher': true,&#13;
        'file': true,&#13;
        'http:': true,&#13;
        'https:': true,&#13;
        'ftp:': true,&#13;
        'gopher:': true,&#13;
        'file:': true&#13;
      },&#13;
      querystring = require('querystring');&#13;
  &#13;
  function urlParse(url, parseQueryString, slashesDenoteHost) {&#13;
    if (url &amp;&amp; isObject(url) &amp;&amp; url instanceof Url) return url;&#13;
  &#13;
    var u = new Url;&#13;
    u.parse(url, parseQueryString, slashesDenoteHost);&#13;
    return u;&#13;
  }&#13;
  &#13;
  Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {&#13;
    if (!isString(url)) {&#13;
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);&#13;
    }&#13;
  &#13;
    var rest = url;&#13;
  &#13;
    rest = rest.trim();&#13;
  &#13;
    var proto = protocolPattern.exec(rest);&#13;
    if (proto) {&#13;
      proto = proto[0];&#13;
      var lowerProto = proto.toLowerCase();&#13;
      this.protocol = lowerProto;&#13;
      rest = rest.substr(proto.length);&#13;
    }&#13;
  &#13;
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {&#13;
      var slashes = rest.substr(0, 2) === '//';&#13;
      if (slashes &amp;&amp; !(proto &amp;&amp; hostlessProtocol[proto])) {&#13;
        rest = rest.substr(2);&#13;
        this.slashes = true;&#13;
      }&#13;
    }&#13;
  &#13;
    if (!hostlessProtocol[proto] &amp;&amp;&#13;
        (slashes || (proto &amp;&amp; !slashedProtocol[proto]))) {&#13;
  &#13;
  &#13;
  &#13;
      var hostEnd = -1;&#13;
      for (var i = 0; i &lt; hostEndingChars.length; i++) {&#13;
        var hec = rest.indexOf(hostEndingChars[i]);&#13;
        if (hec !== -1 &amp;&amp; (hostEnd === -1 || hec &lt; hostEnd))&#13;
          hostEnd = hec;&#13;
      }&#13;
  &#13;
      var auth, atSign;&#13;
      if (hostEnd === -1) {&#13;
        atSign = rest.lastIndexOf('@');&#13;
      } else {&#13;
        atSign = rest.lastIndexOf('@', hostEnd);&#13;
      }&#13;
  &#13;
      if (atSign !== -1) {&#13;
        auth = rest.slice(0, atSign);&#13;
        rest = rest.slice(atSign + 1);&#13;
        this.auth = decodeURIComponent(auth);&#13;
      }&#13;
  &#13;
      hostEnd = -1;&#13;
      for (var i = 0; i &lt; nonHostChars.length; i++) {&#13;
        var hec = rest.indexOf(nonHostChars[i]);&#13;
        if (hec !== -1 &amp;&amp; (hostEnd === -1 || hec &lt; hostEnd))&#13;
          hostEnd = hec;&#13;
      }&#13;
      if (hostEnd === -1)&#13;
        hostEnd = rest.length;&#13;
  &#13;
      this.host = rest.slice(0, hostEnd);&#13;
      rest = rest.slice(hostEnd);&#13;
  &#13;
      this.parseHost();&#13;
  &#13;
      this.hostname = this.hostname || '';&#13;
  &#13;
      var ipv6Hostname = this.hostname[0] === '[' &amp;&amp;&#13;
          this.hostname[this.hostname.length - 1] === ']';&#13;
  &#13;
      if (!ipv6Hostname) {&#13;
        var hostparts = this.hostname.split(/\./);&#13;
        for (var i = 0, l = hostparts.length; i &lt; l; i++) {&#13;
          var part = hostparts[i];&#13;
          if (!part) continue;&#13;
          if (!part.match(hostnamePartPattern)) {&#13;
            var newpart = '';&#13;
            for (var j = 0, k = part.length; j &lt; k; j++) {&#13;
              if (part.charCodeAt(j) &gt; 127) {&#13;
                newpart += 'x';&#13;
              } else {&#13;
                newpart += part[j];&#13;
              }&#13;
            }&#13;
            if (!newpart.match(hostnamePartPattern)) {&#13;
              var validParts = hostparts.slice(0, i);&#13;
              var notHost = hostparts.slice(i + 1);&#13;
              var bit = part.match(hostnamePartStart);&#13;
              if (bit) {&#13;
                validParts.push(bit[1]);&#13;
                notHost.unshift(bit[2]);&#13;
              }&#13;
              if (notHost.length) {&#13;
                rest = '/' + notHost.join('.') + rest;&#13;
              }&#13;
              this.hostname = validParts.join('.');&#13;
              break;&#13;
            }&#13;
          }&#13;
        }&#13;
      }&#13;
  &#13;
      if (this.hostname.length &gt; hostnameMaxLen) {&#13;
        this.hostname = '';&#13;
      } else {&#13;
        this.hostname = this.hostname.toLowerCase();&#13;
      }&#13;
  &#13;
      if (!ipv6Hostname) {&#13;
        var domainArray = this.hostname.split('.');&#13;
        var newOut = [];&#13;
        for (var i = 0; i &lt; domainArray.length; ++i) {&#13;
          var s = domainArray[i];&#13;
          newOut.push(s.match(/[^A-Za-z0-9_-]/) ?&#13;
              'xn--' + punycode.encode(s) : s);&#13;
        }&#13;
        this.hostname = newOut.join('.');&#13;
      }&#13;
  &#13;
      var p = this.port ? ':' + this.port : '';&#13;
      var h = this.hostname || '';&#13;
      this.host = h + p;&#13;
      this.href += this.host;&#13;
  &#13;
      if (ipv6Hostname) {&#13;
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);&#13;
        if (rest[0] !== '/') {&#13;
          rest = '/' + rest;&#13;
        }&#13;
      }&#13;
    }&#13;
  &#13;
    if (!unsafeProtocol[lowerProto]) {&#13;
  &#13;
      for (var i = 0, l = autoEscape.length; i &lt; l; i++) {&#13;
        var ae = autoEscape[i];&#13;
        var esc = encodeURIComponent(ae);&#13;
        if (esc === ae) {&#13;
          esc = escape(ae);&#13;
        }&#13;
        rest = rest.split(ae).join(esc);&#13;
      }&#13;
    }&#13;
  &#13;
  &#13;
    var hash = rest.indexOf('#');&#13;
    if (hash !== -1) {&#13;
      this.hash = rest.substr(hash);&#13;
      rest = rest.slice(0, hash);&#13;
    }&#13;
    var qm = rest.indexOf('?');&#13;
    if (qm !== -1) {&#13;
      this.search = rest.substr(qm);&#13;
      this.query = rest.substr(qm + 1);&#13;
      if (parseQueryString) {&#13;
        this.query = querystring.parse(this.query);&#13;
      }&#13;
      rest = rest.slice(0, qm);&#13;
    } else if (parseQueryString) {&#13;
      this.search = '';&#13;
      this.query = {};&#13;
    }&#13;
    if (rest) this.pathname = rest;&#13;
    if (slashedProtocol[lowerProto] &amp;&amp;&#13;
        this.hostname &amp;&amp; !this.pathname) {&#13;
      this.pathname = '/';&#13;
    }&#13;
  &#13;
    if (this.pathname || this.search) {&#13;
      var p = this.pathname || '';&#13;
      var s = this.search || '';&#13;
      this.path = p + s;&#13;
    }&#13;
  &#13;
    this.href = this.format();&#13;
    return this;&#13;
  };&#13;
  &#13;
  function urlFormat(obj) {&#13;
    if (isString(obj)) obj = urlParse(obj);&#13;
    if (!(obj instanceof Url)) return Url.prototype.format.call(obj);&#13;
    return obj.format();&#13;
  }&#13;
  &#13;
  Url.prototype.format = function() {&#13;
    var auth = this.auth || '';&#13;
    if (auth) {&#13;
      auth = encodeURIComponent(auth);&#13;
      auth = auth.replace(/%3A/i, ':');&#13;
      auth += '@';&#13;
    }&#13;
  &#13;
    var protocol = this.protocol || '',&#13;
        pathname = this.pathname || '',&#13;
        hash = this.hash || '',&#13;
        host = false,&#13;
        query = '';&#13;
  &#13;
    if (this.host) {&#13;
      host = auth + this.host;&#13;
    } else if (this.hostname) {&#13;
      host = auth + (this.hostname.indexOf(':') === -1 ?&#13;
          this.hostname :&#13;
          '[' + this.hostname + ']');&#13;
      if (this.port) {&#13;
        host += ':' + this.port;&#13;
      }&#13;
    }&#13;
  &#13;
    if (this.query &amp;&amp;&#13;
        isObject(this.query) &amp;&amp;&#13;
        Object.keys(this.query).length) {&#13;
      query = querystring.stringify(this.query);&#13;
    }&#13;
  &#13;
    var search = this.search || (query &amp;&amp; ('?' + query)) || '';&#13;
  &#13;
    if (protocol &amp;&amp; protocol.substr(-1) !== ':') protocol += ':';&#13;
  &#13;
    if (this.slashes ||&#13;
        (!protocol || slashedProtocol[protocol]) &amp;&amp; host !== false) {&#13;
      host = '//' + (host || '');&#13;
      if (pathname &amp;&amp; pathname.charAt(0) !== '/') pathname = '/' + pathname;&#13;
    } else if (!host) {&#13;
      host = '';&#13;
    }&#13;
  &#13;
    if (hash &amp;&amp; hash.charAt(0) !== '#') hash = '#' + hash;&#13;
    if (search &amp;&amp; search.charAt(0) !== '?') search = '?' + search;&#13;
  &#13;
    pathname = pathname.replace(/[?#]/g, function(match) {&#13;
      return encodeURIComponent(match);&#13;
    });&#13;
    search = search.replace('#', '%23');&#13;
  &#13;
    return protocol + host + pathname + search + hash;&#13;
  };&#13;
  &#13;
  function urlResolve(source, relative) {&#13;
    return urlParse(source, false, true).resolve(relative);&#13;
  }&#13;
  &#13;
  Url.prototype.resolve = function(relative) {&#13;
    return this.resolveObject(urlParse(relative, false, true)).format();&#13;
  };&#13;
  &#13;
  function urlResolveObject(source, relative) {&#13;
    if (!source) return relative;&#13;
    return urlParse(source, false, true).resolveObject(relative);&#13;
  }&#13;
  &#13;
  Url.prototype.resolveObject = function(relative) {&#13;
    if (isString(relative)) {&#13;
      var rel = new Url();&#13;
      rel.parse(relative, false, true);&#13;
      relative = rel;&#13;
    }&#13;
  &#13;
    var result = new Url();&#13;
    Object.keys(this).forEach(function(k) {&#13;
      result[k] = this[k];&#13;
    }, this);&#13;
  &#13;
    result.hash = relative.hash;&#13;
  &#13;
    if (relative.href === '') {&#13;
      result.href = result.format();&#13;
      return result;&#13;
    }&#13;
  &#13;
    if (relative.slashes &amp;&amp; !relative.protocol) {&#13;
      Object.keys(relative).forEach(function(k) {&#13;
        if (k !== 'protocol')&#13;
          result[k] = relative[k];&#13;
      });&#13;
  &#13;
      if (slashedProtocol[result.protocol] &amp;&amp;&#13;
          result.hostname &amp;&amp; !result.pathname) {&#13;
        result.path = result.pathname = '/';&#13;
      }&#13;
  &#13;
      result.href = result.format();&#13;
      return result;&#13;
    }&#13;
  &#13;
    if (relative.protocol &amp;&amp; relative.protocol !== result.protocol) {&#13;
      if (!slashedProtocol[relative.protocol]) {&#13;
        Object.keys(relative).forEach(function(k) {&#13;
          result[k] = relative[k];&#13;
        });&#13;
        result.href = result.format();&#13;
        return result;&#13;
      }&#13;
  &#13;
      result.protocol = relative.protocol;&#13;
      if (!relative.host &amp;&amp; !hostlessProtocol[relative.protocol]) {&#13;
        var relPath = (relative.pathname || '').split('/');&#13;
        while (relPath.length &amp;&amp; !(relative.host = relPath.shift()));&#13;
        if (!relative.host) relative.host = '';&#13;
        if (!relative.hostname) relative.hostname = '';&#13;
        if (relPath[0] !== '') relPath.unshift('');&#13;
        if (relPath.length &lt; 2) relPath.unshift('');&#13;
        result.pathname = relPath.join('/');&#13;
      } else {&#13;
        result.pathname = relative.pathname;&#13;
      }&#13;
      result.search = relative.search;&#13;
      result.query = relative.query;&#13;
      result.host = relative.host || '';&#13;
      result.auth = relative.auth;&#13;
      result.hostname = relative.hostname || relative.host;&#13;
      result.port = relative.port;&#13;
      if (result.pathname || result.search) {&#13;
        var p = result.pathname || '';&#13;
        var s = result.search || '';&#13;
        result.path = p + s;&#13;
      }&#13;
      result.slashes = result.slashes || relative.slashes;&#13;
      result.href = result.format();&#13;
      return result;&#13;
    }&#13;
  &#13;
    var isSourceAbs = (result.pathname &amp;&amp; result.pathname.charAt(0) === '/'),&#13;
        isRelAbs = (&#13;
            relative.host ||&#13;
            relative.pathname &amp;&amp; relative.pathname.charAt(0) === '/'&#13;
        ),&#13;
        mustEndAbs = (isRelAbs || isSourceAbs ||&#13;
                      (result.host &amp;&amp; relative.pathname)),&#13;
        removeAllDots = mustEndAbs,&#13;
        srcPath = result.pathname &amp;&amp; result.pathname.split('/') || [],&#13;
        relPath = relative.pathname &amp;&amp; relative.pathname.split('/') || [],&#13;
        psychotic = result.protocol &amp;&amp; !slashedProtocol[result.protocol];&#13;
  &#13;
    if (psychotic) {&#13;
      result.hostname = '';&#13;
      result.port = null;&#13;
      if (result.host) {&#13;
        if (srcPath[0] === '') srcPath[0] = result.host;&#13;
        else srcPath.unshift(result.host);&#13;
      }&#13;
      result.host = '';&#13;
      if (relative.protocol) {&#13;
        relative.hostname = null;&#13;
        relative.port = null;&#13;
        if (relative.host) {&#13;
          if (relPath[0] === '') relPath[0] = relative.host;&#13;
          else relPath.unshift(relative.host);&#13;
        }&#13;
        relative.host = null;&#13;
      }&#13;
      mustEndAbs = mustEndAbs &amp;&amp; (relPath[0] === '' || srcPath[0] === '');&#13;
    }&#13;
  &#13;
    if (isRelAbs) {&#13;
      result.host = (relative.host || relative.host === '') ?&#13;
                    relative.host : result.host;&#13;
      result.hostname = (relative.hostname || relative.hostname === '') ?&#13;
                        relative.hostname : result.hostname;&#13;
      result.search = relative.search;&#13;
      result.query = relative.query;&#13;
      srcPath = relPath;&#13;
    } else if (relPath.length) {&#13;
      if (!srcPath) srcPath = [];&#13;
      srcPath.pop();&#13;
      srcPath = srcPath.concat(relPath);&#13;
      result.search = relative.search;&#13;
      result.query = relative.query;&#13;
    } else if (!isNullOrUndefined(relative.search)) {&#13;
      if (psychotic) {&#13;
        result.hostname = result.host = srcPath.shift();&#13;
        var authInHost = result.host &amp;&amp; result.host.indexOf('@') &gt; 0 ?&#13;
                         result.host.split('@') : false;&#13;
        if (authInHost) {&#13;
          result.auth = authInHost.shift();&#13;
          result.host = result.hostname = authInHost.shift();&#13;
        }&#13;
      }&#13;
      result.search = relative.search;&#13;
      result.query = relative.query;&#13;
      if (!isNull(result.pathname) || !isNull(result.search)) {&#13;
        result.path = (result.pathname ? result.pathname : '') +&#13;
                      (result.search ? result.search : '');&#13;
      }&#13;
      result.href = result.format();&#13;
      return result;&#13;
    }&#13;
  &#13;
    if (!srcPath.length) {&#13;
      result.pathname = null;&#13;
      if (result.search) {&#13;
        result.path = '/' + result.search;&#13;
      } else {&#13;
        result.path = null;&#13;
      }&#13;
      result.href = result.format();&#13;
      return result;&#13;
    }&#13;
  &#13;
    var last = srcPath.slice(-1)[0];&#13;
    var hasTrailingSlash = (&#13;
        (result.host || relative.host) &amp;&amp; (last === '.' || last === '..') ||&#13;
        last === '');&#13;
  &#13;
    var up = 0;&#13;
    for (var i = srcPath.length; i &gt;= 0; i--) {&#13;
      last = srcPath[i];&#13;
      if (last == '.') {&#13;
        srcPath.splice(i, 1);&#13;
      } else if (last === '..') {&#13;
        srcPath.splice(i, 1);&#13;
        up++;&#13;
      } else if (up) {&#13;
        srcPath.splice(i, 1);&#13;
        up--;&#13;
      }&#13;
    }&#13;
  &#13;
    if (!mustEndAbs &amp;&amp; !removeAllDots) {&#13;
      for (; up--; up) {&#13;
        srcPath.unshift('..');&#13;
      }&#13;
    }&#13;
  &#13;
    if (mustEndAbs &amp;&amp; srcPath[0] !== '' &amp;&amp;&#13;
        (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {&#13;
      srcPath.unshift('');&#13;
    }&#13;
  &#13;
    if (hasTrailingSlash &amp;&amp; (srcPath.join('/').substr(-1) !== '/')) {&#13;
      srcPath.push('');&#13;
    }&#13;
  &#13;
    var isAbsolute = srcPath[0] === '' ||&#13;
        (srcPath[0] &amp;&amp; srcPath[0].charAt(0) === '/');&#13;
  &#13;
    if (psychotic) {&#13;
      result.hostname = result.host = isAbsolute ? '' :&#13;
                                      srcPath.length ? srcPath.shift() : '';&#13;
      var authInHost = result.host &amp;&amp; result.host.indexOf('@') &gt; 0 ?&#13;
                       result.host.split('@') : false;&#13;
      if (authInHost) {&#13;
        result.auth = authInHost.shift();&#13;
        result.host = result.hostname = authInHost.shift();&#13;
      }&#13;
    }&#13;
  &#13;
    mustEndAbs = mustEndAbs || (result.host &amp;&amp; srcPath.length);&#13;
  &#13;
    if (mustEndAbs &amp;&amp; !isAbsolute) {&#13;
      srcPath.unshift('');&#13;
    }&#13;
  &#13;
    if (!srcPath.length) {&#13;
      result.pathname = null;&#13;
      result.path = null;&#13;
    } else {&#13;
      result.pathname = srcPath.join('/');&#13;
    }&#13;
  &#13;
    if (!isNull(result.pathname) || !isNull(result.search)) {&#13;
      result.path = (result.pathname ? result.pathname : '') +&#13;
                    (result.search ? result.search : '');&#13;
    }&#13;
    result.auth = relative.auth || result.auth;&#13;
    result.slashes = result.slashes || relative.slashes;&#13;
    result.href = result.format();&#13;
    return result;&#13;
  };&#13;
  &#13;
  Url.prototype.parseHost = function() {&#13;
    var host = this.host;&#13;
    var port = portPattern.exec(host);&#13;
    if (port) {&#13;
      port = port[0];&#13;
      if (port !== ':') {&#13;
        this.port = port.substr(1);&#13;
      }&#13;
      host = host.substr(0, host.length - port.length);&#13;
    }&#13;
    if (host) this.hostname = host;&#13;
  };&#13;
  &#13;
  function isString(arg) {&#13;
    return typeof arg === "string";&#13;
  }&#13;
  &#13;
  function isObject(arg) {&#13;
    return typeof arg === 'object' &amp;&amp; arg !== null;&#13;
  }&#13;
  &#13;
  function isNull(arg) {&#13;
    return arg === null;&#13;
  }&#13;
  function isNullOrUndefined(arg) {&#13;
    return  arg == null;&#13;
  }&#13;
  &#13;
  },{"punycode":118,"querystring":121}],126:[function(require,module,exports){&#13;
  if (typeof Object.create === 'function') {&#13;
    module.exports = function inherits(ctor, superCtor) {&#13;
      ctor.super_ = superCtor&#13;
      ctor.prototype = Object.create(superCtor.prototype, {&#13;
        constructor: {&#13;
          value: ctor,&#13;
          enumerable: false,&#13;
          writable: true,&#13;
          configurable: true&#13;
        }&#13;
      });&#13;
    };&#13;
  } else {&#13;
    module.exports = function inherits(ctor, superCtor) {&#13;
      ctor.super_ = superCtor&#13;
      var TempCtor = function () {}&#13;
      TempCtor.prototype = superCtor.prototype&#13;
      ctor.prototype = new TempCtor()&#13;
      ctor.prototype.constructor = ctor&#13;
    }&#13;
  }&#13;
  &#13;
  },{}],127:[function(require,module,exports){&#13;
  module.exports = function isBuffer(arg) {&#13;
    return arg &amp;&amp; typeof arg === 'object'&#13;
      &amp;&amp; typeof arg.copy === 'function'&#13;
      &amp;&amp; typeof arg.fill === 'function'&#13;
      &amp;&amp; typeof arg.readUInt8 === 'function';&#13;
  }&#13;
  },{}],128:[function(require,module,exports){&#13;
  (function (process,global){&#13;
  &#13;
  var formatRegExp = /%[sdj%]/g;&#13;
  exports.format = function(f) {&#13;
    if (!isString(f)) {&#13;
      var objects = [];&#13;
      for (var i = 0; i &lt; arguments.length; i++) {&#13;
        objects.push(inspect(arguments[i]));&#13;
      }&#13;
      return objects.join(' ');&#13;
    }&#13;
  &#13;
    var i = 1;&#13;
    var args = arguments;&#13;
    var len = args.length;&#13;
    var str = String(f).replace(formatRegExp, function(x) {&#13;
      if (x === '%%') return '%';&#13;
      if (i &gt;= len) return x;&#13;
      switch (x) {&#13;
        case '%s': return String(args[i++]);&#13;
        case '%d': return Number(args[i++]);&#13;
        case '%j':&#13;
          try {&#13;
            return JSON.stringify(args[i++]);&#13;
          } catch (_) {&#13;
            return '[Circular]';&#13;
          }&#13;
        default:&#13;
          return x;&#13;
      }&#13;
    });&#13;
    for (var x = args[i]; i &lt; len; x = args[++i]) {&#13;
      if (isNull(x) || !isObject(x)) {&#13;
        str += ' ' + x;&#13;
      } else {&#13;
        str += ' ' + inspect(x);&#13;
      }&#13;
    }&#13;
    return str;&#13;
  };&#13;
  &#13;
  &#13;
  exports.deprecate = function(fn, msg) {&#13;
    if (isUndefined(global.process)) {&#13;
      return function() {&#13;
        return exports.deprecate(fn, msg).apply(this, arguments);&#13;
      };&#13;
    }&#13;
  &#13;
    if (process.noDeprecation === true) {&#13;
      return fn;&#13;
    }&#13;
  &#13;
    var warned = false;&#13;
    function deprecated() {&#13;
      if (!warned) {&#13;
        if (process.throwDeprecation) {&#13;
          throw new Error(msg);&#13;
        } else if (process.traceDeprecation) {&#13;
          console.trace(msg);&#13;
        } else {&#13;
          console.error(msg);&#13;
        }&#13;
        warned = true;&#13;
      }&#13;
      return fn.apply(this, arguments);&#13;
    }&#13;
  &#13;
    return deprecated;&#13;
  };&#13;
  &#13;
  &#13;
  var debugs = {};&#13;
  var debugEnviron;&#13;
  exports.debuglog = function(set) {&#13;
    if (isUndefined(debugEnviron))&#13;
      debugEnviron = process.env.NODE_DEBUG || '';&#13;
    set = set.toUpperCase();&#13;
    if (!debugs[set]) {&#13;
      if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {&#13;
        var pid = process.pid;&#13;
        debugs[set] = function() {&#13;
          var msg = exports.format.apply(exports, arguments);&#13;
          console.error('%s %d: %s', set, pid, msg);&#13;
        };&#13;
      } else {&#13;
        debugs[set] = function() {};&#13;
      }&#13;
    }&#13;
    return debugs[set];&#13;
  };&#13;
  &#13;
  &#13;
  &#13;
  &#13;
  function inspect(obj, opts) {&#13;
    var ctx = {&#13;
      seen: [],&#13;
      stylize: stylizeNoColor&#13;
    };&#13;
    if (arguments.length &gt;= 3) ctx.depth = arguments[2];&#13;
    if (arguments.length &gt;= 4) ctx.colors = arguments[3];&#13;
    if (isBoolean(opts)) {&#13;
      ctx.showHidden = opts;&#13;
    } else if (opts) {&#13;
      exports._extend(ctx, opts);&#13;
    }&#13;
    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;&#13;
    if (isUndefined(ctx.depth)) ctx.depth = 2;&#13;
    if (isUndefined(ctx.colors)) ctx.colors = false;&#13;
    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;&#13;
    if (ctx.colors) ctx.stylize = stylizeWithColor;&#13;
    return formatValue(ctx, obj, ctx.depth);&#13;
  }&#13;
  exports.inspect = inspect;&#13;
  &#13;
  &#13;
  inspect.colors = {&#13;
    'bold' : [1, 22],&#13;
    'italic' : [3, 23],&#13;
    'underline' : [4, 24],&#13;
    'inverse' : [7, 27],&#13;
    'white' : [37, 39],&#13;
    'grey' : [90, 39],&#13;
    'black' : [30, 39],&#13;
    'blue' : [34, 39],&#13;
    'cyan' : [36, 39],&#13;
    'green' : [32, 39],&#13;
    'magenta' : [35, 39],&#13;
    'red' : [31, 39],&#13;
    'yellow' : [33, 39]&#13;
  };&#13;
  &#13;
  inspect.styles = {&#13;
    'special': 'cyan',&#13;
    'number': 'yellow',&#13;
    'boolean': 'yellow',&#13;
    'undefined': 'grey',&#13;
    'null': 'bold',&#13;
    'string': 'green',&#13;
    'date': 'magenta',&#13;
    'regexp': 'red'&#13;
  };&#13;
  &#13;
  &#13;
  function stylizeWithColor(str, styleType) {&#13;
    var style = inspect.styles[styleType];&#13;
  &#13;
    if (style) {&#13;
      return '\u001b[' + inspect.colors[style][0] + 'm' + str +&#13;
             '\u001b[' + inspect.colors[style][1] + 'm';&#13;
    } else {&#13;
      return str;&#13;
    }&#13;
  }&#13;
  &#13;
  &#13;
  function stylizeNoColor(str, styleType) {&#13;
    return str;&#13;
  }&#13;
  &#13;
  &#13;
  function arrayToHash(array) {&#13;
    var hash = {};&#13;
  &#13;
    array.forEach(function(val, idx) {&#13;
      hash[val] = true;&#13;
    });&#13;
  &#13;
    return hash;&#13;
  }&#13;
  &#13;
  &#13;
  function formatValue(ctx, value, recurseTimes) {&#13;
    if (ctx.customInspect &amp;&amp;&#13;
        value &amp;&amp;&#13;
        isFunction(value.inspect) &amp;&amp;&#13;
        value.inspect !== exports.inspect &amp;&amp;&#13;
        !(value.constructor &amp;&amp; value.constructor.prototype === value)) {&#13;
      var ret = value.inspect(recurseTimes, ctx);&#13;
      if (!isString(ret)) {&#13;
        ret = formatValue(ctx, ret, recurseTimes);&#13;
      }&#13;
      return ret;&#13;
    }&#13;
  &#13;
    var primitive = formatPrimitive(ctx, value);&#13;
    if (primitive) {&#13;
      return primitive;&#13;
    }&#13;
  &#13;
    var keys = Object.keys(value);&#13;
    var visibleKeys = arrayToHash(keys);&#13;
  &#13;
    if (ctx.showHidden) {&#13;
      keys = Object.getOwnPropertyNames(value);&#13;
    }&#13;
  &#13;
    if (isError(value)&#13;
        &amp;&amp; (keys.indexOf('message') &gt;= 0 || keys.indexOf('description') &gt;= 0)) {&#13;
      return formatError(value);&#13;
    }&#13;
  &#13;
    if (keys.length === 0) {&#13;
      if (isFunction(value)) {&#13;
        var name = value.name ? ': ' + value.name : '';&#13;
        return ctx.stylize('[Function' + name + ']', 'special');&#13;
      }&#13;
      if (isRegExp(value)) {&#13;
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');&#13;
      }&#13;
      if (isDate(value)) {&#13;
        return ctx.stylize(Date.prototype.toString.call(value), 'date');&#13;
      }&#13;
      if (isError(value)) {&#13;
        return formatError(value);&#13;
      }&#13;
    }&#13;
  &#13;
    var base = '', array = false, braces = ['{', '}'];&#13;
  &#13;
    if (isArray(value)) {&#13;
      array = true;&#13;
      braces = ['[', ']'];&#13;
    }&#13;
  &#13;
    if (isFunction(value)) {&#13;
      var n = value.name ? ': ' + value.name : '';&#13;
      base = ' [Function' + n + ']';&#13;
    }&#13;
  &#13;
    if (isRegExp(value)) {&#13;
      base = ' ' + RegExp.prototype.toString.call(value);&#13;
    }&#13;
  &#13;
    if (isDate(value)) {&#13;
      base = ' ' + Date.prototype.toUTCString.call(value);&#13;
    }&#13;
  &#13;
    if (isError(value)) {&#13;
      base = ' ' + formatError(value);&#13;
    }&#13;
  &#13;
    if (keys.length === 0 &amp;&amp; (!array || value.length == 0)) {&#13;
      return braces[0] + base + braces[1];&#13;
    }&#13;
  &#13;
    if (recurseTimes &lt; 0) {&#13;
      if (isRegExp(value)) {&#13;
        return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');&#13;
      } else {&#13;
        return ctx.stylize('[Object]', 'special');&#13;
      }&#13;
    }&#13;
  &#13;
    ctx.seen.push(value);&#13;
  &#13;
    var output;&#13;
    if (array) {&#13;
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);&#13;
    } else {&#13;
      output = keys.map(function(key) {&#13;
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);&#13;
      });&#13;
    }&#13;
  &#13;
    ctx.seen.pop();&#13;
  &#13;
    return reduceToSingleString(output, base, braces);&#13;
  }&#13;
  &#13;
  &#13;
  function formatPrimitive(ctx, value) {&#13;
    if (isUndefined(value))&#13;
      return ctx.stylize('undefined', 'undefined');&#13;
    if (isString(value)) {&#13;
      var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')&#13;
                                               .replace(/'/g, "\\'")&#13;
                                               .replace(/\\"/g, '"') + '\'';&#13;
      return ctx.stylize(simple, 'string');&#13;
    }&#13;
    if (isNumber(value))&#13;
      return ctx.stylize('' + value, 'number');&#13;
    if (isBoolean(value))&#13;
      return ctx.stylize('' + value, 'boolean');&#13;
    if (isNull(value))&#13;
      return ctx.stylize('null', 'null');&#13;
  }&#13;
  &#13;
  &#13;
  function formatError(value) {&#13;
    return '[' + Error.prototype.toString.call(value) + ']';&#13;
  }&#13;
  &#13;
  &#13;
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {&#13;
    var output = [];&#13;
    for (var i = 0, l = value.length; i &lt; l; ++i) {&#13;
      if (hasOwnProperty(value, String(i))) {&#13;
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,&#13;
            String(i), true));&#13;
      } else {&#13;
        output.push('');&#13;
      }&#13;
    }&#13;
    keys.forEach(function(key) {&#13;
      if (!key.match(/^\d+$/)) {&#13;
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,&#13;
            key, true));&#13;
      }&#13;
    });&#13;
    return output;&#13;
  }&#13;
  &#13;
  &#13;
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {&#13;
    var name, str, desc;&#13;
    desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };&#13;
    if (desc.get) {&#13;
      if (desc.set) {&#13;
        str = ctx.stylize('[Getter/Setter]', 'special');&#13;
      } else {&#13;
        str = ctx.stylize('[Getter]', 'special');&#13;
      }&#13;
    } else {&#13;
      if (desc.set) {&#13;
        str = ctx.stylize('[Setter]', 'special');&#13;
      }&#13;
    }&#13;
    if (!hasOwnProperty(visibleKeys, key)) {&#13;
      name = '[' + key + ']';&#13;
    }&#13;
    if (!str) {&#13;
      if (ctx.seen.indexOf(desc.value) &lt; 0) {&#13;
        if (isNull(recurseTimes)) {&#13;
          str = formatValue(ctx, desc.value, null);&#13;
        } else {&#13;
          str = formatValue(ctx, desc.value, recurseTimes - 1);&#13;
        }&#13;
        if (str.indexOf('\n') &gt; -1) {&#13;
          if (array) {&#13;
            str = str.split('\n').map(function(line) {&#13;
              return '  ' + line;&#13;
            }).join('\n').substr(2);&#13;
          } else {&#13;
            str = '\n' + str.split('\n').map(function(line) {&#13;
              return '   ' + line;&#13;
            }).join('\n');&#13;
          }&#13;
        }&#13;
      } else {&#13;
        str = ctx.stylize('[Circular]', 'special');&#13;
      }&#13;
    }&#13;
    if (isUndefined(name)) {&#13;
      if (array &amp;&amp; key.match(/^\d+$/)) {&#13;
        return str;&#13;
      }&#13;
      name = JSON.stringify('' + key);&#13;
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {&#13;
        name = name.substr(1, name.length - 2);&#13;
        name = ctx.stylize(name, 'name');&#13;
      } else {&#13;
        name = name.replace(/'/g, "\\'")&#13;
                   .replace(/\\"/g, '"')&#13;
                   .replace(/(^"|"$)/g, "'");&#13;
        name = ctx.stylize(name, 'string');&#13;
      }&#13;
    }&#13;
  &#13;
    return name + ': ' + str;&#13;
  }&#13;
  &#13;
  &#13;
  function reduceToSingleString(output, base, braces) {&#13;
    var numLinesEst = 0;&#13;
    var length = output.reduce(function(prev, cur) {&#13;
      numLinesEst++;&#13;
      if (cur.indexOf('\n') &gt;= 0) numLinesEst++;&#13;
      return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;&#13;
    }, 0);&#13;
  &#13;
    if (length &gt; 60) {&#13;
      return braces[0] +&#13;
             (base === '' ? '' : base + '\n ') +&#13;
             ' ' +&#13;
             output.join(',\n  ') +&#13;
             ' ' +&#13;
             braces[1];&#13;
    }&#13;
  &#13;
    return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];&#13;
  }&#13;
  &#13;
  &#13;
  function isArray(ar) {&#13;
    return Array.isArray(ar);&#13;
  }&#13;
  exports.isArray = isArray;&#13;
  &#13;
  function isBoolean(arg) {&#13;
    return typeof arg === 'boolean';&#13;
  }&#13;
  exports.isBoolean = isBoolean;&#13;
  &#13;
  function isNull(arg) {&#13;
    return arg === null;&#13;
  }&#13;
  exports.isNull = isNull;&#13;
  &#13;
  function isNullOrUndefined(arg) {&#13;
    return arg == null;&#13;
  }&#13;
  exports.isNullOrUndefined = isNullOrUndefined;&#13;
  &#13;
  function isNumber(arg) {&#13;
    return typeof arg === 'number';&#13;
  }&#13;
  exports.isNumber = isNumber;&#13;
  &#13;
  function isString(arg) {&#13;
    return typeof arg === 'string';&#13;
  }&#13;
  exports.isString = isString;&#13;
  &#13;
  function isSymbol(arg) {&#13;
    return typeof arg === 'symbol';&#13;
  }&#13;
  exports.isSymbol = isSymbol;&#13;
  &#13;
  function isUndefined(arg) {&#13;
    return arg === void 0;&#13;
  }&#13;
  exports.isUndefined = isUndefined;&#13;
  &#13;
  function isRegExp(re) {&#13;
    return isObject(re) &amp;&amp; objectToString(re) === '[object RegExp]';&#13;
  }&#13;
  exports.isRegExp = isRegExp;&#13;
  &#13;
  function isObject(arg) {&#13;
    return typeof arg === 'object' &amp;&amp; arg !== null;&#13;
  }&#13;
  exports.isObject = isObject;&#13;
  &#13;
  function isDate(d) {&#13;
    return isObject(d) &amp;&amp; objectToString(d) === '[object Date]';&#13;
  }&#13;
  exports.isDate = isDate;&#13;
  &#13;
  function isError(e) {&#13;
    return isObject(e) &amp;&amp;&#13;
        (objectToString(e) === '[object Error]' || e instanceof Error);&#13;
  }&#13;
  exports.isError = isError;&#13;
  &#13;
  function isFunction(arg) {&#13;
    return typeof arg === 'function';&#13;
  }&#13;
  exports.isFunction = isFunction;&#13;
  &#13;
  function isPrimitive(arg) {&#13;
    return arg === null ||&#13;
           typeof arg === 'boolean' ||&#13;
           typeof arg === 'number' ||&#13;
           typeof arg === 'string' ||&#13;
           typeof arg === 'symbol' ||  // ES6 symbol&#13;
           typeof arg === 'undefined';&#13;
  }&#13;
  exports.isPrimitive = isPrimitive;&#13;
  &#13;
  exports.isBuffer = require('./support/isBuffer');&#13;
  &#13;
  function objectToString(o) {&#13;
    return Object.prototype.toString.call(o);&#13;
  }&#13;
  &#13;
  &#13;
  function pad(n) {&#13;
    return n &lt; 10 ? '0' + n.toString(10) : n.toString(10);&#13;
  }&#13;
  &#13;
  &#13;
  var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',&#13;
                'Oct', 'Nov', 'Dec'];&#13;
  &#13;
  function timestamp() {&#13;
    var d = new Date();&#13;
    var time = [pad(d.getHours()),&#13;
                pad(d.getMinutes()),&#13;
                pad(d.getSeconds())].join(':');&#13;
    return [d.getDate(), months[d.getMonth()], time].join(' ');&#13;
  }&#13;
  &#13;
  &#13;
  exports.log = function() {&#13;
    console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));&#13;
  };&#13;
  &#13;
  &#13;
  &#13;
  exports.inherits = require('inherits');&#13;
  &#13;
  exports._extend = function(origin, add) {&#13;
    if (!add || !isObject(add)) return origin;&#13;
  &#13;
    var keys = Object.keys(add);&#13;
    var i = keys.length;&#13;
    while (i--) {&#13;
      origin[keys[i]] = add[keys[i]];&#13;
    }&#13;
    return origin;&#13;
  };&#13;
  &#13;
  function hasOwnProperty(obj, prop) {&#13;
    return Object.prototype.hasOwnProperty.call(obj, prop);&#13;
  }&#13;
  &#13;
  }).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})&#13;
  },{"./support/isBuffer":127,"_process":117,"inherits":126}],129:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLAttribute, create;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    module.exports = XMLAttribute = (function() {&#13;
      function XMLAttribute(parent, name, value) {&#13;
        this.stringify = parent.stringify;&#13;
        if (name == null) {&#13;
          throw new Error("Missing attribute name of element " + parent.name);&#13;
        }&#13;
        if (value == null) {&#13;
          throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);&#13;
        }&#13;
        this.name = this.stringify.attName(name);&#13;
        this.value = this.stringify.attValue(value);&#13;
      }&#13;
  &#13;
      XMLAttribute.prototype.clone = function() {&#13;
        return create(XMLAttribute.prototype, this);&#13;
      };&#13;
  &#13;
      XMLAttribute.prototype.toString = function(options, level) {&#13;
        return ' ' + this.name + '="' + this.value + '"';&#13;
      };&#13;
  &#13;
      return XMLAttribute;&#13;
  &#13;
    })();&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"lodash/object/create":111}],130:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLBuilder, XMLDeclaration, XMLDocType, XMLElement, XMLStringifier;&#13;
  &#13;
    XMLStringifier = require('./XMLStringifier');&#13;
  &#13;
    XMLDeclaration = require('./XMLDeclaration');&#13;
  &#13;
    XMLDocType = require('./XMLDocType');&#13;
  &#13;
    XMLElement = require('./XMLElement');&#13;
  &#13;
    module.exports = XMLBuilder = (function() {&#13;
      function XMLBuilder(name, options) {&#13;
        var root, temp;&#13;
        if (name == null) {&#13;
          throw new Error("Root element needs a name");&#13;
        }&#13;
        if (options == null) {&#13;
          options = {};&#13;
        }&#13;
        this.options = options;&#13;
        this.stringify = new XMLStringifier(options);&#13;
        temp = new XMLElement(this, 'doc');&#13;
        root = temp.element(name);&#13;
        root.isRoot = true;&#13;
        root.documentObject = this;&#13;
        this.rootObject = root;&#13;
        if (!options.headless) {&#13;
          root.declaration(options);&#13;
          if ((options.pubID != null) || (options.sysID != null)) {&#13;
            root.doctype(options);&#13;
          }&#13;
        }&#13;
      }&#13;
  &#13;
      XMLBuilder.prototype.root = function() {&#13;
        return this.rootObject;&#13;
      };&#13;
  &#13;
      XMLBuilder.prototype.end = function(options) {&#13;
        return this.toString(options);&#13;
      };&#13;
  &#13;
      XMLBuilder.prototype.toString = function(options) {&#13;
        var indent, newline, offset, pretty, r, ref, ref1, ref2;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        r = '';&#13;
        if (this.xmldec != null) {&#13;
          r += this.xmldec.toString(options);&#13;
        }&#13;
        if (this.doctype != null) {&#13;
          r += this.doctype.toString(options);&#13;
        }&#13;
        r += this.rootObject.toString(options);&#13;
        if (pretty &amp;&amp; r.slice(-newline.length) === newline) {&#13;
          r = r.slice(0, -newline.length);&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      return XMLBuilder;&#13;
  &#13;
    })();&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"./XMLDeclaration":137,"./XMLDocType":138,"./XMLElement":139,"./XMLStringifier":143}],131:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLCData, XMLNode, create,&#13;
      extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },&#13;
      hasProp = {}.hasOwnProperty;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    XMLNode = require('./XMLNode');&#13;
  &#13;
    module.exports = XMLCData = (function(superClass) {&#13;
      extend(XMLCData, superClass);&#13;
  &#13;
      function XMLCData(parent, text) {&#13;
        XMLCData.__super__.constructor.call(this, parent);&#13;
        if (text == null) {&#13;
          throw new Error("Missing CDATA text");&#13;
        }&#13;
        this.text = this.stringify.cdata(text);&#13;
      }&#13;
  &#13;
      XMLCData.prototype.clone = function() {&#13;
        return create(XMLCData.prototype, this);&#13;
      };&#13;
  &#13;
      XMLCData.prototype.toString = function(options, level) {&#13;
        var indent, newline, offset, pretty, r, ref, ref1, ref2, space;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        level || (level = 0);&#13;
        space = new Array(level + offset + 1).join(indent);&#13;
        r = '';&#13;
        if (pretty) {&#13;
          r += space;&#13;
        }&#13;
        r += '&lt;![CDATA[' + this.text + ']]&gt;';&#13;
        if (pretty) {&#13;
          r += newline;&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      return XMLCData;&#13;
  &#13;
    })(XMLNode);&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"./XMLNode":140,"lodash/object/create":111}],132:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLComment, XMLNode, create,&#13;
      extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },&#13;
      hasProp = {}.hasOwnProperty;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    XMLNode = require('./XMLNode');&#13;
  &#13;
    module.exports = XMLComment = (function(superClass) {&#13;
      extend(XMLComment, superClass);&#13;
  &#13;
      function XMLComment(parent, text) {&#13;
        XMLComment.__super__.constructor.call(this, parent);&#13;
        if (text == null) {&#13;
          throw new Error("Missing comment text");&#13;
        }&#13;
        this.text = this.stringify.comment(text);&#13;
      }&#13;
  &#13;
      XMLComment.prototype.clone = function() {&#13;
        return create(XMLComment.prototype, this);&#13;
      };&#13;
  &#13;
      XMLComment.prototype.toString = function(options, level) {&#13;
        var indent, newline, offset, pretty, r, ref, ref1, ref2, space;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        level || (level = 0);&#13;
        space = new Array(level + offset + 1).join(indent);&#13;
        r = '';&#13;
        if (pretty) {&#13;
          r += space;&#13;
        }&#13;
        r += '&lt;!-- ' + this.text + ' --&gt;';&#13;
        if (pretty) {&#13;
          r += newline;&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      return XMLComment;&#13;
  &#13;
    })(XMLNode);&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"./XMLNode":140,"lodash/object/create":111}],133:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLDTDAttList, create;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    module.exports = XMLDTDAttList = (function() {&#13;
      function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {&#13;
        this.stringify = parent.stringify;&#13;
        if (elementName == null) {&#13;
          throw new Error("Missing DTD element name");&#13;
        }&#13;
        if (attributeName == null) {&#13;
          throw new Error("Missing DTD attribute name");&#13;
        }&#13;
        if (!attributeType) {&#13;
          throw new Error("Missing DTD attribute type");&#13;
        }&#13;
        if (!defaultValueType) {&#13;
          throw new Error("Missing DTD attribute default");&#13;
        }&#13;
        if (defaultValueType.indexOf('#') !== 0) {&#13;
          defaultValueType = '#' + defaultValueType;&#13;
        }&#13;
        if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {&#13;
          throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");&#13;
        }&#13;
        if (defaultValue &amp;&amp; !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {&#13;
          throw new Error("Default value only applies to #FIXED or #DEFAULT");&#13;
        }&#13;
        this.elementName = this.stringify.eleName(elementName);&#13;
        this.attributeName = this.stringify.attName(attributeName);&#13;
        this.attributeType = this.stringify.dtdAttType(attributeType);&#13;
        this.defaultValue = this.stringify.dtdAttDefault(defaultValue);&#13;
        this.defaultValueType = defaultValueType;&#13;
      }&#13;
  &#13;
      XMLDTDAttList.prototype.clone = function() {&#13;
        return create(XMLDTDAttList.prototype, this);&#13;
      };&#13;
  &#13;
      XMLDTDAttList.prototype.toString = function(options, level) {&#13;
        var indent, newline, offset, pretty, r, ref, ref1, ref2, space;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        level || (level = 0);&#13;
        space = new Array(level + offset + 1).join(indent);&#13;
        r = '';&#13;
        if (pretty) {&#13;
          r += space;&#13;
        }&#13;
        r += '&lt;!ATTLIST ' + this.elementName + ' ' + this.attributeName + ' ' + this.attributeType;&#13;
        if (this.defaultValueType !== '#DEFAULT') {&#13;
          r += ' ' + this.defaultValueType;&#13;
        }&#13;
        if (this.defaultValue) {&#13;
          r += ' "' + this.defaultValue + '"';&#13;
        }&#13;
        r += '&gt;';&#13;
        if (pretty) {&#13;
          r += newline;&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      return XMLDTDAttList;&#13;
  &#13;
    })();&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"lodash/object/create":111}],134:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLDTDElement, create, isArray;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    isArray = require('lodash/lang/isArray');&#13;
  &#13;
    module.exports = XMLDTDElement = (function() {&#13;
      function XMLDTDElement(parent, name, value) {&#13;
        this.stringify = parent.stringify;&#13;
        if (name == null) {&#13;
          throw new Error("Missing DTD element name");&#13;
        }&#13;
        if (!value) {&#13;
          value = '(#PCDATA)';&#13;
        }&#13;
        if (isArray(value)) {&#13;
          value = '(' + value.join(',') + ')';&#13;
        }&#13;
        this.name = this.stringify.eleName(name);&#13;
        this.value = this.stringify.dtdElementValue(value);&#13;
      }&#13;
  &#13;
      XMLDTDElement.prototype.clone = function() {&#13;
        return create(XMLDTDElement.prototype, this);&#13;
      };&#13;
  &#13;
      XMLDTDElement.prototype.toString = function(options, level) {&#13;
        var indent, newline, offset, pretty, r, ref, ref1, ref2, space;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        level || (level = 0);&#13;
        space = new Array(level + offset + 1).join(indent);&#13;
        r = '';&#13;
        if (pretty) {&#13;
          r += space;&#13;
        }&#13;
        r += '&lt;!ELEMENT ' + this.name + ' ' + this.value + '&gt;';&#13;
        if (pretty) {&#13;
          r += newline;&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      return XMLDTDElement;&#13;
  &#13;
    })();&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"lodash/lang/isArray":103,"lodash/object/create":111}],135:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLDTDEntity, create, isObject;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    isObject = require('lodash/lang/isObject');&#13;
  &#13;
    module.exports = XMLDTDEntity = (function() {&#13;
      function XMLDTDEntity(parent, pe, name, value) {&#13;
        this.stringify = parent.stringify;&#13;
        if (name == null) {&#13;
          throw new Error("Missing entity name");&#13;
        }&#13;
        if (value == null) {&#13;
          throw new Error("Missing entity value");&#13;
        }&#13;
        this.pe = !!pe;&#13;
        this.name = this.stringify.eleName(name);&#13;
        if (!isObject(value)) {&#13;
          this.value = this.stringify.dtdEntityValue(value);&#13;
        } else {&#13;
          if (!value.pubID &amp;&amp; !value.sysID) {&#13;
            throw new Error("Public and/or system identifiers are required for an external entity");&#13;
          }&#13;
          if (value.pubID &amp;&amp; !value.sysID) {&#13;
            throw new Error("System identifier is required for a public external entity");&#13;
          }&#13;
          if (value.pubID != null) {&#13;
            this.pubID = this.stringify.dtdPubID(value.pubID);&#13;
          }&#13;
          if (value.sysID != null) {&#13;
            this.sysID = this.stringify.dtdSysID(value.sysID);&#13;
          }&#13;
          if (value.nData != null) {&#13;
            this.nData = this.stringify.dtdNData(value.nData);&#13;
          }&#13;
          if (this.pe &amp;&amp; this.nData) {&#13;
            throw new Error("Notation declaration is not allowed in a parameter entity");&#13;
          }&#13;
        }&#13;
      }&#13;
  &#13;
      XMLDTDEntity.prototype.clone = function() {&#13;
        return create(XMLDTDEntity.prototype, this);&#13;
      };&#13;
  &#13;
      XMLDTDEntity.prototype.toString = function(options, level) {&#13;
        var indent, newline, offset, pretty, r, ref, ref1, ref2, space;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        level || (level = 0);&#13;
        space = new Array(level + offset + 1).join(indent);&#13;
        r = '';&#13;
        if (pretty) {&#13;
          r += space;&#13;
        }&#13;
        r += '&lt;!ENTITY';&#13;
        if (this.pe) {&#13;
          r += ' %';&#13;
        }&#13;
        r += ' ' + this.name;&#13;
        if (this.value) {&#13;
          r += ' "' + this.value + '"';&#13;
        } else {&#13;
          if (this.pubID &amp;&amp; this.sysID) {&#13;
            r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';&#13;
          } else if (this.sysID) {&#13;
            r += ' SYSTEM "' + this.sysID + '"';&#13;
          }&#13;
          if (this.nData) {&#13;
            r += ' NDATA ' + this.nData;&#13;
          }&#13;
        }&#13;
        r += '&gt;';&#13;
        if (pretty) {&#13;
          r += newline;&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      return XMLDTDEntity;&#13;
  &#13;
    })();&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"lodash/lang/isObject":107,"lodash/object/create":111}],136:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLDTDNotation, create;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    module.exports = XMLDTDNotation = (function() {&#13;
      function XMLDTDNotation(parent, name, value) {&#13;
        this.stringify = parent.stringify;&#13;
        if (name == null) {&#13;
          throw new Error("Missing notation name");&#13;
        }&#13;
        if (!value.pubID &amp;&amp; !value.sysID) {&#13;
          throw new Error("Public or system identifiers are required for an external entity");&#13;
        }&#13;
        this.name = this.stringify.eleName(name);&#13;
        if (value.pubID != null) {&#13;
          this.pubID = this.stringify.dtdPubID(value.pubID);&#13;
        }&#13;
        if (value.sysID != null) {&#13;
          this.sysID = this.stringify.dtdSysID(value.sysID);&#13;
        }&#13;
      }&#13;
  &#13;
      XMLDTDNotation.prototype.clone = function() {&#13;
        return create(XMLDTDNotation.prototype, this);&#13;
      };&#13;
  &#13;
      XMLDTDNotation.prototype.toString = function(options, level) {&#13;
        var indent, newline, offset, pretty, r, ref, ref1, ref2, space;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        level || (level = 0);&#13;
        space = new Array(level + offset + 1).join(indent);&#13;
        r = '';&#13;
        if (pretty) {&#13;
          r += space;&#13;
        }&#13;
        r += '&lt;!NOTATION ' + this.name;&#13;
        if (this.pubID &amp;&amp; this.sysID) {&#13;
          r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';&#13;
        } else if (this.pubID) {&#13;
          r += ' PUBLIC "' + this.pubID + '"';&#13;
        } else if (this.sysID) {&#13;
          r += ' SYSTEM "' + this.sysID + '"';&#13;
        }&#13;
        r += '&gt;';&#13;
        if (pretty) {&#13;
          r += newline;&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      return XMLDTDNotation;&#13;
  &#13;
    })();&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"lodash/object/create":111}],137:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLDeclaration, XMLNode, create, isObject,&#13;
      extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },&#13;
      hasProp = {}.hasOwnProperty;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    isObject = require('lodash/lang/isObject');&#13;
  &#13;
    XMLNode = require('./XMLNode');&#13;
  &#13;
    module.exports = XMLDeclaration = (function(superClass) {&#13;
      extend(XMLDeclaration, superClass);&#13;
  &#13;
      function XMLDeclaration(parent, version, encoding, standalone) {&#13;
        var ref;&#13;
        XMLDeclaration.__super__.constructor.call(this, parent);&#13;
        if (isObject(version)) {&#13;
          ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;&#13;
        }&#13;
        if (!version) {&#13;
          version = '1.0';&#13;
        }&#13;
        if (version != null) {&#13;
          this.version = this.stringify.xmlVersion(version);&#13;
        }&#13;
        if (encoding != null) {&#13;
          this.encoding = this.stringify.xmlEncoding(encoding);&#13;
        }&#13;
        if (standalone != null) {&#13;
          this.standalone = this.stringify.xmlStandalone(standalone);&#13;
        }&#13;
      }&#13;
  &#13;
      XMLDeclaration.prototype.clone = function() {&#13;
        return create(XMLDeclaration.prototype, this);&#13;
      };&#13;
  &#13;
      XMLDeclaration.prototype.toString = function(options, level) {&#13;
        var indent, newline, offset, pretty, r, ref, ref1, ref2, space;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        level || (level = 0);&#13;
        space = new Array(level + offset + 1).join(indent);&#13;
        r = '';&#13;
        if (pretty) {&#13;
          r += space;&#13;
        }&#13;
        r += '&lt;?xml';&#13;
        if (this.version != null) {&#13;
          r += ' version="' + this.version + '"';&#13;
        }&#13;
        if (this.encoding != null) {&#13;
          r += ' encoding="' + this.encoding + '"';&#13;
        }&#13;
        if (this.standalone != null) {&#13;
          r += ' standalone="' + this.standalone + '"';&#13;
        }&#13;
        r += '?&gt;';&#13;
        if (pretty) {&#13;
          r += newline;&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      return XMLDeclaration;&#13;
  &#13;
    })(XMLNode);&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"./XMLNode":140,"lodash/lang/isObject":107,"lodash/object/create":111}],138:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLProcessingInstruction, create, isObject;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    isObject = require('lodash/lang/isObject');&#13;
  &#13;
    XMLCData = require('./XMLCData');&#13;
  &#13;
    XMLComment = require('./XMLComment');&#13;
  &#13;
    XMLDTDAttList = require('./XMLDTDAttList');&#13;
  &#13;
    XMLDTDEntity = require('./XMLDTDEntity');&#13;
  &#13;
    XMLDTDElement = require('./XMLDTDElement');&#13;
  &#13;
    XMLDTDNotation = require('./XMLDTDNotation');&#13;
  &#13;
    XMLProcessingInstruction = require('./XMLProcessingInstruction');&#13;
  &#13;
    module.exports = XMLDocType = (function() {&#13;
      function XMLDocType(parent, pubID, sysID) {&#13;
        var ref, ref1;&#13;
        this.documentObject = parent;&#13;
        this.stringify = this.documentObject.stringify;&#13;
        this.children = [];&#13;
        if (isObject(pubID)) {&#13;
          ref = pubID, pubID = ref.pubID, sysID = ref.sysID;&#13;
        }&#13;
        if (sysID == null) {&#13;
          ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];&#13;
        }&#13;
        if (pubID != null) {&#13;
          this.pubID = this.stringify.dtdPubID(pubID);&#13;
        }&#13;
        if (sysID != null) {&#13;
          this.sysID = this.stringify.dtdSysID(sysID);&#13;
        }&#13;
      }&#13;
  &#13;
      XMLDocType.prototype.clone = function() {&#13;
        return create(XMLDocType.prototype, this);&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.element = function(name, value) {&#13;
        var child;&#13;
        child = new XMLDTDElement(this, name, value);&#13;
        this.children.push(child);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {&#13;
        var child;&#13;
        child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);&#13;
        this.children.push(child);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.entity = function(name, value) {&#13;
        var child;&#13;
        child = new XMLDTDEntity(this, false, name, value);&#13;
        this.children.push(child);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.pEntity = function(name, value) {&#13;
        var child;&#13;
        child = new XMLDTDEntity(this, true, name, value);&#13;
        this.children.push(child);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.notation = function(name, value) {&#13;
        var child;&#13;
        child = new XMLDTDNotation(this, name, value);&#13;
        this.children.push(child);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.cdata = function(value) {&#13;
        var child;&#13;
        child = new XMLCData(this, value);&#13;
        this.children.push(child);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.comment = function(value) {&#13;
        var child;&#13;
        child = new XMLComment(this, value);&#13;
        this.children.push(child);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.instruction = function(target, value) {&#13;
        var child;&#13;
        child = new XMLProcessingInstruction(this, target, value);&#13;
        this.children.push(child);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.root = function() {&#13;
        return this.documentObject.root();&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.document = function() {&#13;
        return this.documentObject;&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.toString = function(options, level) {&#13;
        var child, i, indent, len, newline, offset, pretty, r, ref, ref1, ref2, ref3, space;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        level || (level = 0);&#13;
        space = new Array(level + offset + 1).join(indent);&#13;
        r = '';&#13;
        if (pretty) {&#13;
          r += space;&#13;
        }&#13;
        r += '&lt;!DOCTYPE ' + this.root().name;&#13;
        if (this.pubID &amp;&amp; this.sysID) {&#13;
          r += ' PUBLIC "' + this.pubID + '" "' + this.sysID + '"';&#13;
        } else if (this.sysID) {&#13;
          r += ' SYSTEM "' + this.sysID + '"';&#13;
        }&#13;
        if (this.children.length &gt; 0) {&#13;
          r += ' [';&#13;
          if (pretty) {&#13;
            r += newline;&#13;
          }&#13;
          ref3 = this.children;&#13;
          for (i = 0, len = ref3.length; i &lt; len; i++) {&#13;
            child = ref3[i];&#13;
            r += child.toString(options, level + 1);&#13;
          }&#13;
          r += ']';&#13;
        }&#13;
        r += '&gt;';&#13;
        if (pretty) {&#13;
          r += newline;&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.ele = function(name, value) {&#13;
        return this.element(name, value);&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {&#13;
        return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.ent = function(name, value) {&#13;
        return this.entity(name, value);&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.pent = function(name, value) {&#13;
        return this.pEntity(name, value);&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.not = function(name, value) {&#13;
        return this.notation(name, value);&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.dat = function(value) {&#13;
        return this.cdata(value);&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.com = function(value) {&#13;
        return this.comment(value);&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.ins = function(target, value) {&#13;
        return this.instruction(target, value);&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.up = function() {&#13;
        return this.root();&#13;
      };&#13;
  &#13;
      XMLDocType.prototype.doc = function() {&#13;
        return this.document();&#13;
      };&#13;
  &#13;
      return XMLDocType;&#13;
  &#13;
    })();&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"./XMLCData":131,"./XMLComment":132,"./XMLDTDAttList":133,"./XMLDTDElement":134,"./XMLDTDEntity":135,"./XMLDTDNotation":136,"./XMLProcessingInstruction":141,"lodash/lang/isObject":107,"lodash/object/create":111}],139:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLAttribute, XMLElement, XMLNode, XMLProcessingInstruction, create, every, isArray, isFunction, isObject,&#13;
      extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },&#13;
      hasProp = {}.hasOwnProperty;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    isObject = require('lodash/lang/isObject');&#13;
  &#13;
    isArray = require('lodash/lang/isArray');&#13;
  &#13;
    isFunction = require('lodash/lang/isFunction');&#13;
  &#13;
    every = require('lodash/collection/every');&#13;
  &#13;
    XMLNode = require('./XMLNode');&#13;
  &#13;
    XMLAttribute = require('./XMLAttribute');&#13;
  &#13;
    XMLProcessingInstruction = require('./XMLProcessingInstruction');&#13;
  &#13;
    module.exports = XMLElement = (function(superClass) {&#13;
      extend(XMLElement, superClass);&#13;
  &#13;
      function XMLElement(parent, name, attributes) {&#13;
        XMLElement.__super__.constructor.call(this, parent);&#13;
        if (name == null) {&#13;
          throw new Error("Missing element name");&#13;
        }&#13;
        this.name = this.stringify.eleName(name);&#13;
        this.children = [];&#13;
        this.instructions = [];&#13;
        this.attributes = {};&#13;
        if (attributes != null) {&#13;
          this.attribute(attributes);&#13;
        }&#13;
      }&#13;
  &#13;
      XMLElement.prototype.clone = function() {&#13;
        var att, attName, clonedSelf, i, len, pi, ref, ref1;&#13;
        clonedSelf = create(XMLElement.prototype, this);&#13;
        if (clonedSelf.isRoot) {&#13;
          clonedSelf.documentObject = null;&#13;
        }&#13;
        clonedSelf.attributes = {};&#13;
        ref = this.attributes;&#13;
        for (attName in ref) {&#13;
          if (!hasProp.call(ref, attName)) continue;&#13;
          att = ref[attName];&#13;
          clonedSelf.attributes[attName] = att.clone();&#13;
        }&#13;
        clonedSelf.instructions = [];&#13;
        ref1 = this.instructions;&#13;
        for (i = 0, len = ref1.length; i &lt; len; i++) {&#13;
          pi = ref1[i];&#13;
          clonedSelf.instructions.push(pi.clone());&#13;
        }&#13;
        clonedSelf.children = [];&#13;
        this.children.forEach(function(child) {&#13;
          var clonedChild;&#13;
          clonedChild = child.clone();&#13;
          clonedChild.parent = clonedSelf;&#13;
          return clonedSelf.children.push(clonedChild);&#13;
        });&#13;
        return clonedSelf;&#13;
      };&#13;
  &#13;
      XMLElement.prototype.attribute = function(name, value) {&#13;
        var attName, attValue;&#13;
        if (name != null) {&#13;
          name = name.valueOf();&#13;
        }&#13;
        if (isObject(name)) {&#13;
          for (attName in name) {&#13;
            if (!hasProp.call(name, attName)) continue;&#13;
            attValue = name[attName];&#13;
            this.attribute(attName, attValue);&#13;
          }&#13;
        } else {&#13;
          if (isFunction(value)) {&#13;
            value = value.apply();&#13;
          }&#13;
          if (!this.options.skipNullAttributes || (value != null)) {&#13;
            this.attributes[name] = new XMLAttribute(this, name, value);&#13;
          }&#13;
        }&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLElement.prototype.removeAttribute = function(name) {&#13;
        var attName, i, len;&#13;
        if (name == null) {&#13;
          throw new Error("Missing attribute name");&#13;
        }&#13;
        name = name.valueOf();&#13;
        if (isArray(name)) {&#13;
          for (i = 0, len = name.length; i &lt; len; i++) {&#13;
            attName = name[i];&#13;
            delete this.attributes[attName];&#13;
          }&#13;
        } else {&#13;
          delete this.attributes[name];&#13;
        }&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLElement.prototype.instruction = function(target, value) {&#13;
        var i, insTarget, insValue, instruction, len;&#13;
        if (target != null) {&#13;
          target = target.valueOf();&#13;
        }&#13;
        if (value != null) {&#13;
          value = value.valueOf();&#13;
        }&#13;
        if (isArray(target)) {&#13;
          for (i = 0, len = target.length; i &lt; len; i++) {&#13;
            insTarget = target[i];&#13;
            this.instruction(insTarget);&#13;
          }&#13;
        } else if (isObject(target)) {&#13;
          for (insTarget in target) {&#13;
            if (!hasProp.call(target, insTarget)) continue;&#13;
            insValue = target[insTarget];&#13;
            this.instruction(insTarget, insValue);&#13;
          }&#13;
        } else {&#13;
          if (isFunction(value)) {&#13;
            value = value.apply();&#13;
          }&#13;
          instruction = new XMLProcessingInstruction(this, target, value);&#13;
          this.instructions.push(instruction);&#13;
        }&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLElement.prototype.toString = function(options, level) {&#13;
        var att, child, i, indent, instruction, j, len, len1, name, newline, offset, pretty, r, ref, ref1, ref2, ref3, ref4, ref5, space;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        level || (level = 0);&#13;
        space = new Array(level + offset + 1).join(indent);&#13;
        r = '';&#13;
        ref3 = this.instructions;&#13;
        for (i = 0, len = ref3.length; i &lt; len; i++) {&#13;
          instruction = ref3[i];&#13;
          r += instruction.toString(options, level + 1);&#13;
        }&#13;
        if (pretty) {&#13;
          r += space;&#13;
        }&#13;
        r += '&lt;' + this.name;&#13;
        ref4 = this.attributes;&#13;
        for (name in ref4) {&#13;
          if (!hasProp.call(ref4, name)) continue;&#13;
          att = ref4[name];&#13;
          r += att.toString(options);&#13;
        }&#13;
        if (this.children.length === 0 || every(this.children, function(e) {&#13;
          return e.value === '';&#13;
        })) {&#13;
          r += '/&gt;';&#13;
          if (pretty) {&#13;
            r += newline;&#13;
          }&#13;
        } else if (pretty &amp;&amp; this.children.length === 1 &amp;&amp; (this.children[0].value != null)) {&#13;
          r += '&gt;';&#13;
          r += this.children[0].value;&#13;
          r += '&lt;/' + this.name + '&gt;';&#13;
          r += newline;&#13;
        } else {&#13;
          r += '&gt;';&#13;
          if (pretty) {&#13;
            r += newline;&#13;
          }&#13;
          ref5 = this.children;&#13;
          for (j = 0, len1 = ref5.length; j &lt; len1; j++) {&#13;
            child = ref5[j];&#13;
            r += child.toString(options, level + 1);&#13;
          }&#13;
          if (pretty) {&#13;
            r += space;&#13;
          }&#13;
          r += '&lt;/' + this.name + '&gt;';&#13;
          if (pretty) {&#13;
            r += newline;&#13;
          }&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      XMLElement.prototype.att = function(name, value) {&#13;
        return this.attribute(name, value);&#13;
      };&#13;
  &#13;
      XMLElement.prototype.ins = function(target, value) {&#13;
        return this.instruction(target, value);&#13;
      };&#13;
  &#13;
      XMLElement.prototype.a = function(name, value) {&#13;
        return this.attribute(name, value);&#13;
      };&#13;
  &#13;
      XMLElement.prototype.i = function(target, value) {&#13;
        return this.instruction(target, value);&#13;
      };&#13;
  &#13;
      return XMLElement;&#13;
  &#13;
    })(XMLNode);&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"./XMLAttribute":129,"./XMLNode":140,"./XMLProcessingInstruction":141,"lodash/collection/every":69,"lodash/lang/isArray":103,"lodash/lang/isFunction":105,"lodash/lang/isObject":107,"lodash/object/create":111}],140:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLRaw, XMLText, isArray, isEmpty, isFunction, isObject,&#13;
      hasProp = {}.hasOwnProperty;&#13;
  &#13;
    isObject = require('lodash/lang/isObject');&#13;
  &#13;
    isArray = require('lodash/lang/isArray');&#13;
  &#13;
    isFunction = require('lodash/lang/isFunction');&#13;
  &#13;
    isEmpty = require('lodash/lang/isEmpty');&#13;
  &#13;
    XMLElement = null;&#13;
  &#13;
    XMLCData = null;&#13;
  &#13;
    XMLComment = null;&#13;
  &#13;
    XMLDeclaration = null;&#13;
  &#13;
    XMLDocType = null;&#13;
  &#13;
    XMLRaw = null;&#13;
  &#13;
    XMLText = null;&#13;
  &#13;
    module.exports = XMLNode = (function() {&#13;
      function XMLNode(parent) {&#13;
        this.parent = parent;&#13;
        this.options = this.parent.options;&#13;
        this.stringify = this.parent.stringify;&#13;
        if (XMLElement === null) {&#13;
          XMLElement = require('./XMLElement');&#13;
          XMLCData = require('./XMLCData');&#13;
          XMLComment = require('./XMLComment');&#13;
          XMLDeclaration = require('./XMLDeclaration');&#13;
          XMLDocType = require('./XMLDocType');&#13;
          XMLRaw = require('./XMLRaw');&#13;
          XMLText = require('./XMLText');&#13;
        }&#13;
      }&#13;
  &#13;
      XMLNode.prototype.clone = function() {&#13;
        throw new Error("Cannot clone generic XMLNode");&#13;
      };&#13;
  &#13;
      XMLNode.prototype.element = function(name, attributes, text) {&#13;
        var item, j, key, lastChild, len, ref, val;&#13;
        lastChild = null;&#13;
        if (attributes == null) {&#13;
          attributes = {};&#13;
        }&#13;
        attributes = attributes.valueOf();&#13;
        if (!isObject(attributes)) {&#13;
          ref = [attributes, text], text = ref[0], attributes = ref[1];&#13;
        }&#13;
        if (name != null) {&#13;
          name = name.valueOf();&#13;
        }&#13;
        if (isArray(name)) {&#13;
          for (j = 0, len = name.length; j &lt; len; j++) {&#13;
            item = name[j];&#13;
            lastChild = this.element(item);&#13;
          }&#13;
        } else if (isFunction(name)) {&#13;
          lastChild = this.element(name.apply());&#13;
        } else if (isObject(name)) {&#13;
          for (key in name) {&#13;
            if (!hasProp.call(name, key)) continue;&#13;
            val = name[key];&#13;
            if (isFunction(val)) {&#13;
              val = val.apply();&#13;
            }&#13;
            if ((isObject(val)) &amp;&amp; (isEmpty(val))) {&#13;
              val = null;&#13;
            }&#13;
            if (!this.options.ignoreDecorators &amp;&amp; this.stringify.convertAttKey &amp;&amp; key.indexOf(this.stringify.convertAttKey) === 0) {&#13;
              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);&#13;
            } else if (!this.options.ignoreDecorators &amp;&amp; this.stringify.convertPIKey &amp;&amp; key.indexOf(this.stringify.convertPIKey) === 0) {&#13;
              lastChild = this.instruction(key.substr(this.stringify.convertPIKey.length), val);&#13;
            } else if (isObject(val)) {&#13;
              if (!this.options.ignoreDecorators &amp;&amp; this.stringify.convertListKey &amp;&amp; key.indexOf(this.stringify.convertListKey) === 0 &amp;&amp; isArray(val)) {&#13;
                lastChild = this.element(val);&#13;
              } else {&#13;
                lastChild = this.element(key);&#13;
                lastChild.element(val);&#13;
              }&#13;
            } else {&#13;
              lastChild = this.element(key, val);&#13;
            }&#13;
          }&#13;
        } else {&#13;
          if (!this.options.ignoreDecorators &amp;&amp; this.stringify.convertTextKey &amp;&amp; name.indexOf(this.stringify.convertTextKey) === 0) {&#13;
            lastChild = this.text(text);&#13;
          } else if (!this.options.ignoreDecorators &amp;&amp; this.stringify.convertCDataKey &amp;&amp; name.indexOf(this.stringify.convertCDataKey) === 0) {&#13;
            lastChild = this.cdata(text);&#13;
          } else if (!this.options.ignoreDecorators &amp;&amp; this.stringify.convertCommentKey &amp;&amp; name.indexOf(this.stringify.convertCommentKey) === 0) {&#13;
            lastChild = this.comment(text);&#13;
          } else if (!this.options.ignoreDecorators &amp;&amp; this.stringify.convertRawKey &amp;&amp; name.indexOf(this.stringify.convertRawKey) === 0) {&#13;
            lastChild = this.raw(text);&#13;
          } else {&#13;
            lastChild = this.node(name, attributes, text);&#13;
          }&#13;
        }&#13;
        if (lastChild == null) {&#13;
          throw new Error("Could not create any elements with: " + name);&#13;
        }&#13;
        return lastChild;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.insertBefore = function(name, attributes, text) {&#13;
        var child, i, removed;&#13;
        if (this.isRoot) {&#13;
          throw new Error("Cannot insert elements at root level");&#13;
        }&#13;
        i = this.parent.children.indexOf(this);&#13;
        removed = this.parent.children.splice(i);&#13;
        child = this.parent.element(name, attributes, text);&#13;
        Array.prototype.push.apply(this.parent.children, removed);&#13;
        return child;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.insertAfter = function(name, attributes, text) {&#13;
        var child, i, removed;&#13;
        if (this.isRoot) {&#13;
          throw new Error("Cannot insert elements at root level");&#13;
        }&#13;
        i = this.parent.children.indexOf(this);&#13;
        removed = this.parent.children.splice(i + 1);&#13;
        child = this.parent.element(name, attributes, text);&#13;
        Array.prototype.push.apply(this.parent.children, removed);&#13;
        return child;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.remove = function() {&#13;
        var i, ref;&#13;
        if (this.isRoot) {&#13;
          throw new Error("Cannot remove the root element");&#13;
        }&#13;
        i = this.parent.children.indexOf(this);&#13;
        [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref = [])), ref;&#13;
        return this.parent;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.node = function(name, attributes, text) {&#13;
        var child, ref;&#13;
        if (name != null) {&#13;
          name = name.valueOf();&#13;
        }&#13;
        if (attributes == null) {&#13;
          attributes = {};&#13;
        }&#13;
        attributes = attributes.valueOf();&#13;
        if (!isObject(attributes)) {&#13;
          ref = [attributes, text], text = ref[0], attributes = ref[1];&#13;
        }&#13;
        child = new XMLElement(this, name, attributes);&#13;
        if (text != null) {&#13;
          child.text(text);&#13;
        }&#13;
        this.children.push(child);&#13;
        return child;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.text = function(value) {&#13;
        var child;&#13;
        child = new XMLText(this, value);&#13;
        this.children.push(child);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.cdata = function(value) {&#13;
        var child;&#13;
        child = new XMLCData(this, value);&#13;
        this.children.push(child);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.comment = function(value) {&#13;
        var child;&#13;
        child = new XMLComment(this, value);&#13;
        this.children.push(child);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.raw = function(value) {&#13;
        var child;&#13;
        child = new XMLRaw(this, value);&#13;
        this.children.push(child);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.declaration = function(version, encoding, standalone) {&#13;
        var doc, xmldec;&#13;
        doc = this.document();&#13;
        xmldec = new XMLDeclaration(doc, version, encoding, standalone);&#13;
        doc.xmldec = xmldec;&#13;
        return doc.root();&#13;
      };&#13;
  &#13;
      XMLNode.prototype.doctype = function(pubID, sysID) {&#13;
        var doc, doctype;&#13;
        doc = this.document();&#13;
        doctype = new XMLDocType(doc, pubID, sysID);&#13;
        doc.doctype = doctype;&#13;
        return doctype;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.up = function() {&#13;
        if (this.isRoot) {&#13;
          throw new Error("The root node has no parent. Use doc() if you need to get the document object.");&#13;
        }&#13;
        return this.parent;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.root = function() {&#13;
        var child;&#13;
        if (this.isRoot) {&#13;
          return this;&#13;
        }&#13;
        child = this.parent;&#13;
        while (!child.isRoot) {&#13;
          child = child.parent;&#13;
        }&#13;
        return child;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.document = function() {&#13;
        return this.root().documentObject;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.end = function(options) {&#13;
        return this.document().toString(options);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.prev = function() {&#13;
        var i;&#13;
        if (this.isRoot) {&#13;
          throw new Error("Root node has no siblings");&#13;
        }&#13;
        i = this.parent.children.indexOf(this);&#13;
        if (i &lt; 1) {&#13;
          throw new Error("Already at the first node");&#13;
        }&#13;
        return this.parent.children[i - 1];&#13;
      };&#13;
  &#13;
      XMLNode.prototype.next = function() {&#13;
        var i;&#13;
        if (this.isRoot) {&#13;
          throw new Error("Root node has no siblings");&#13;
        }&#13;
        i = this.parent.children.indexOf(this);&#13;
        if (i === -1 || i === this.parent.children.length - 1) {&#13;
          throw new Error("Already at the last node");&#13;
        }&#13;
        return this.parent.children[i + 1];&#13;
      };&#13;
  &#13;
      XMLNode.prototype.importXMLBuilder = function(xmlbuilder) {&#13;
        var clonedRoot;&#13;
        clonedRoot = xmlbuilder.root().clone();&#13;
        clonedRoot.parent = this;&#13;
        clonedRoot.isRoot = false;&#13;
        this.children.push(clonedRoot);&#13;
        return this;&#13;
      };&#13;
  &#13;
      XMLNode.prototype.ele = function(name, attributes, text) {&#13;
        return this.element(name, attributes, text);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.nod = function(name, attributes, text) {&#13;
        return this.node(name, attributes, text);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.txt = function(value) {&#13;
        return this.text(value);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.dat = function(value) {&#13;
        return this.cdata(value);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.com = function(value) {&#13;
        return this.comment(value);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.doc = function() {&#13;
        return this.document();&#13;
      };&#13;
  &#13;
      XMLNode.prototype.dec = function(version, encoding, standalone) {&#13;
        return this.declaration(version, encoding, standalone);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.dtd = function(pubID, sysID) {&#13;
        return this.doctype(pubID, sysID);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.e = function(name, attributes, text) {&#13;
        return this.element(name, attributes, text);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.n = function(name, attributes, text) {&#13;
        return this.node(name, attributes, text);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.t = function(value) {&#13;
        return this.text(value);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.d = function(value) {&#13;
        return this.cdata(value);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.c = function(value) {&#13;
        return this.comment(value);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.r = function(value) {&#13;
        return this.raw(value);&#13;
      };&#13;
  &#13;
      XMLNode.prototype.u = function() {&#13;
        return this.up();&#13;
      };&#13;
  &#13;
      return XMLNode;&#13;
  &#13;
    })();&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"./XMLCData":131,"./XMLComment":132,"./XMLDeclaration":137,"./XMLDocType":138,"./XMLElement":139,"./XMLRaw":142,"./XMLText":144,"lodash/lang/isArray":103,"lodash/lang/isEmpty":104,"lodash/lang/isFunction":105,"lodash/lang/isObject":107}],141:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLProcessingInstruction, create;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    module.exports = XMLProcessingInstruction = (function() {&#13;
      function XMLProcessingInstruction(parent, target, value) {&#13;
        this.stringify = parent.stringify;&#13;
        if (target == null) {&#13;
          throw new Error("Missing instruction target");&#13;
        }&#13;
        this.target = this.stringify.insTarget(target);&#13;
        if (value) {&#13;
          this.value = this.stringify.insValue(value);&#13;
        }&#13;
      }&#13;
  &#13;
      XMLProcessingInstruction.prototype.clone = function() {&#13;
        return create(XMLProcessingInstruction.prototype, this);&#13;
      };&#13;
  &#13;
      XMLProcessingInstruction.prototype.toString = function(options, level) {&#13;
        var indent, newline, offset, pretty, r, ref, ref1, ref2, space;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        level || (level = 0);&#13;
        space = new Array(level + offset + 1).join(indent);&#13;
        r = '';&#13;
        if (pretty) {&#13;
          r += space;&#13;
        }&#13;
        r += '&lt;?';&#13;
        r += this.target;&#13;
        if (this.value) {&#13;
          r += ' ' + this.value;&#13;
        }&#13;
        r += '?&gt;';&#13;
        if (pretty) {&#13;
          r += newline;&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      return XMLProcessingInstruction;&#13;
  &#13;
    })();&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"lodash/object/create":111}],142:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLNode, XMLRaw, create,&#13;
      extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },&#13;
      hasProp = {}.hasOwnProperty;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    XMLNode = require('./XMLNode');&#13;
  &#13;
    module.exports = XMLRaw = (function(superClass) {&#13;
      extend(XMLRaw, superClass);&#13;
  &#13;
      function XMLRaw(parent, text) {&#13;
        XMLRaw.__super__.constructor.call(this, parent);&#13;
        if (text == null) {&#13;
          throw new Error("Missing raw text");&#13;
        }&#13;
        this.value = this.stringify.raw(text);&#13;
      }&#13;
  &#13;
      XMLRaw.prototype.clone = function() {&#13;
        return create(XMLRaw.prototype, this);&#13;
      };&#13;
  &#13;
      XMLRaw.prototype.toString = function(options, level) {&#13;
        var indent, newline, offset, pretty, r, ref, ref1, ref2, space;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        level || (level = 0);&#13;
        space = new Array(level + offset + 1).join(indent);&#13;
        r = '';&#13;
        if (pretty) {&#13;
          r += space;&#13;
        }&#13;
        r += this.value;&#13;
        if (pretty) {&#13;
          r += newline;&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      return XMLRaw;&#13;
  &#13;
    })(XMLNode);&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"./XMLNode":140,"lodash/object/create":111}],143:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLStringifier,&#13;
      bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },&#13;
      hasProp = {}.hasOwnProperty;&#13;
  &#13;
    module.exports = XMLStringifier = (function() {&#13;
      function XMLStringifier(options) {&#13;
        this.assertLegalChar = bind(this.assertLegalChar, this);&#13;
        var key, ref, value;&#13;
        this.allowSurrogateChars = options != null ? options.allowSurrogateChars : void 0;&#13;
        ref = (options != null ? options.stringify : void 0) || {};&#13;
        for (key in ref) {&#13;
          if (!hasProp.call(ref, key)) continue;&#13;
          value = ref[key];&#13;
          this[key] = value;&#13;
        }&#13;
      }&#13;
  &#13;
      XMLStringifier.prototype.eleName = function(val) {&#13;
        val = '' + val || '';&#13;
        return this.assertLegalChar(val);&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.eleText = function(val) {&#13;
        val = '' + val || '';&#13;
        return this.assertLegalChar(this.elEscape(val));&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.cdata = function(val) {&#13;
        val = '' + val || '';&#13;
        if (val.match(/]]&gt;/)) {&#13;
          throw new Error("Invalid CDATA text: " + val);&#13;
        }&#13;
        return this.assertLegalChar(val);&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.comment = function(val) {&#13;
        val = '' + val || '';&#13;
        if (val.match(/--/)) {&#13;
          throw new Error("Comment text cannot contain double-hypen: " + val);&#13;
        }&#13;
        return this.assertLegalChar(val);&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.raw = function(val) {&#13;
        return '' + val || '';&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.attName = function(val) {&#13;
        return '' + val || '';&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.attValue = function(val) {&#13;
        val = '' + val || '';&#13;
        return this.attEscape(val);&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.insTarget = function(val) {&#13;
        return '' + val || '';&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.insValue = function(val) {&#13;
        val = '' + val || '';&#13;
        if (val.match(/\?&gt;/)) {&#13;
          throw new Error("Invalid processing instruction value: " + val);&#13;
        }&#13;
        return val;&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.xmlVersion = function(val) {&#13;
        val = '' + val || '';&#13;
        if (!val.match(/1\.[0-9]+/)) {&#13;
          throw new Error("Invalid version number: " + val);&#13;
        }&#13;
        return val;&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.xmlEncoding = function(val) {&#13;
        val = '' + val || '';&#13;
        if (!val.match(/[A-Za-z](?:[A-Za-z0-9._-]|-)*/)) {&#13;
          throw new Error("Invalid encoding: " + val);&#13;
        }&#13;
        return val;&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.xmlStandalone = function(val) {&#13;
        if (val) {&#13;
          return "yes";&#13;
        } else {&#13;
          return "no";&#13;
        }&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.dtdPubID = function(val) {&#13;
        return '' + val || '';&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.dtdSysID = function(val) {&#13;
        return '' + val || '';&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.dtdElementValue = function(val) {&#13;
        return '' + val || '';&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.dtdAttType = function(val) {&#13;
        return '' + val || '';&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.dtdAttDefault = function(val) {&#13;
        if (val != null) {&#13;
          return '' + val || '';&#13;
        } else {&#13;
          return val;&#13;
        }&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.dtdEntityValue = function(val) {&#13;
        return '' + val || '';&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.dtdNData = function(val) {&#13;
        return '' + val || '';&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.convertAttKey = '@';&#13;
  &#13;
      XMLStringifier.prototype.convertPIKey = '?';&#13;
  &#13;
      XMLStringifier.prototype.convertTextKey = '#text';&#13;
  &#13;
      XMLStringifier.prototype.convertCDataKey = '#cdata';&#13;
  &#13;
      XMLStringifier.prototype.convertCommentKey = '#comment';&#13;
  &#13;
      XMLStringifier.prototype.convertRawKey = '#raw';&#13;
  &#13;
      XMLStringifier.prototype.convertListKey = '#list';&#13;
  &#13;
      XMLStringifier.prototype.assertLegalChar = function(str) {&#13;
        var chars, chr;&#13;
        if (this.allowSurrogateChars) {&#13;
          chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uFFFE-\uFFFF]/;&#13;
        } else {&#13;
          chars = /[\u0000-\u0008\u000B-\u000C\u000E-\u001F\uD800-\uDFFF\uFFFE-\uFFFF]/;&#13;
        }&#13;
        chr = str.match(chars);&#13;
        if (chr) {&#13;
          throw new Error("Invalid character (" + chr + ") in string: " + str + " at index " + chr.index);&#13;
        }&#13;
        return str;&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.elEscape = function(str) {&#13;
        return str.replace(/&amp;/g, '&amp;amp;').replace(/&lt;/g, '&amp;lt;').replace(/&gt;/g, '&amp;gt;').replace(/\r/g, '&amp;#xD;');&#13;
      };&#13;
  &#13;
      XMLStringifier.prototype.attEscape = function(str) {&#13;
        return str.replace(/&amp;/g, '&amp;amp;').replace(/&lt;/g, '&amp;lt;').replace(/"/g, '&amp;quot;').replace(/\t/g, '&amp;#x9;').replace(/\n/g, '&amp;#xA;').replace(/\r/g, '&amp;#xD;');&#13;
      };&#13;
  &#13;
      return XMLStringifier;&#13;
  &#13;
    })();&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{}],144:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLNode, XMLText, create,&#13;
      extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },&#13;
      hasProp = {}.hasOwnProperty;&#13;
  &#13;
    create = require('lodash/object/create');&#13;
  &#13;
    XMLNode = require('./XMLNode');&#13;
  &#13;
    module.exports = XMLText = (function(superClass) {&#13;
      extend(XMLText, superClass);&#13;
  &#13;
      function XMLText(parent, text) {&#13;
        XMLText.__super__.constructor.call(this, parent);&#13;
        if (text == null) {&#13;
          throw new Error("Missing element text");&#13;
        }&#13;
        this.value = this.stringify.eleText(text);&#13;
      }&#13;
  &#13;
      XMLText.prototype.clone = function() {&#13;
        return create(XMLText.prototype, this);&#13;
      };&#13;
  &#13;
      XMLText.prototype.toString = function(options, level) {&#13;
        var indent, newline, offset, pretty, r, ref, ref1, ref2, space;&#13;
        pretty = (options != null ? options.pretty : void 0) || false;&#13;
        indent = (ref = options != null ? options.indent : void 0) != null ? ref : '  ';&#13;
        offset = (ref1 = options != null ? options.offset : void 0) != null ? ref1 : 0;&#13;
        newline = (ref2 = options != null ? options.newline : void 0) != null ? ref2 : '\n';&#13;
        level || (level = 0);&#13;
        space = new Array(level + offset + 1).join(indent);&#13;
        r = '';&#13;
        if (pretty) {&#13;
          r += space;&#13;
        }&#13;
        r += this.value;&#13;
        if (pretty) {&#13;
          r += newline;&#13;
        }&#13;
        return r;&#13;
      };&#13;
  &#13;
      return XMLText;&#13;
  &#13;
    })(XMLNode);&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"./XMLNode":140,"lodash/object/create":111}],145:[function(require,module,exports){&#13;
  (function() {&#13;
    var XMLBuilder, assign;&#13;
  &#13;
    assign = require('lodash/object/assign');&#13;
  &#13;
    XMLBuilder = require('./XMLBuilder');&#13;
  &#13;
    module.exports.create = function(name, xmldec, doctype, options) {&#13;
      options = assign({}, xmldec, doctype, options);&#13;
      return new XMLBuilder(name, options).root();&#13;
    };&#13;
  &#13;
  }).call(this);&#13;
  &#13;
  },{"./XMLBuilder":130,"lodash/object/assign":110}],146:[function(require,module,exports){&#13;
  require('./browser_loader');&#13;
  &#13;
  var AWS = require('./core');&#13;
  &#13;
  if (typeof window !== 'undefined') window.AWS = AWS;&#13;
  if (typeof module !== 'undefined') module.exports = AWS;&#13;
  if (typeof self !== 'undefined') self.AWS = AWS;&#13;
  &#13;
  if (!Object.prototype.hasOwnProperty.call(AWS, 'Connect')) {&#13;
    AWS.apiLoader.services['connect'] = {};&#13;
    AWS.Connect = AWS.Service.defineService('connect', [ '2017-02-15' ]);&#13;
  }&#13;
  AWS.apiLoader.services['connect']['2017-02-15'] = require('../apis/connect-2017-02-15.min');&#13;
  &#13;
  if (!Object.prototype.hasOwnProperty.call(AWS, 'STS')) {&#13;
    AWS.apiLoader.services['sts'] = {};&#13;
    AWS.STS = AWS.Service.defineService('sts', [ '2011-06-15' ]);&#13;
    require('./services/sts');&#13;
  }&#13;
  AWS.apiLoader.services['sts']['2011-06-15'] = require('../apis/sts-2011-06-15.min');&#13;
  &#13;
  &#13;
  },{"../apis/connect-2017-02-15.min":2,"../apis/sts-2011-06-15.min":4,"./browser_loader":8,"./core":10,"./services/sts":43}]},{},[146]);&#13;
  &#13;
  /*! @license sprintf.js | Copyright (c) 2007-2013 Alexandru Marasteanu &lt;hello at alexei dot ro&gt; | 3 clause BSD license */&#13;
  &#13;
  (function() {&#13;
     var ctx = this;&#13;
  &#13;
    var sprintf = function() {&#13;
      if (!sprintf.cache.hasOwnProperty(arguments[0])) {&#13;
        sprintf.cache[arguments[0]] = sprintf.parse(arguments[0]);&#13;
      }&#13;
      return sprintf.format.call(null, sprintf.cache[arguments[0]], arguments);&#13;
    };&#13;
  &#13;
    sprintf.format = function(parse_tree, argv) {&#13;
      var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;&#13;
      for (i = 0; i &lt; tree_length; i++) {&#13;
        node_type = get_type(parse_tree[i]);&#13;
        if (node_type === 'string') {&#13;
          output.push(parse_tree[i]);&#13;
        }&#13;
        else if (node_type === 'array') {&#13;
          match = parse_tree[i]; // convenience purposes only&#13;
          if (match[2]) { // keyword argument&#13;
            arg = argv[cursor];&#13;
            for (k = 0; k &lt; match[2].length; k++) {&#13;
              if (!arg.hasOwnProperty(match[2][k])) {&#13;
                throw(sprintf('[sprintf] property "%s" does not exist', match[2][k]));&#13;
              }&#13;
              arg = arg[match[2][k]];&#13;
            }&#13;
          }&#13;
          else if (match[1]) { // positional argument (explicit)&#13;
            arg = argv[match[1]];&#13;
          }&#13;
          else { // positional argument (implicit)&#13;
            arg = argv[cursor++];&#13;
          }&#13;
  &#13;
          if (/[^s]/.test(match[8]) &amp;&amp; (get_type(arg) != 'number')) {&#13;
            throw(sprintf('[sprintf] expecting number but found %s', get_type(arg)));&#13;
          }&#13;
          switch (match[8]) {&#13;
            case 'b': arg = arg.toString(2); break;&#13;
            case 'c': arg = String.fromCharCode(arg); break;&#13;
            case 'd': arg = parseInt(arg, 10); break;&#13;
            case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;&#13;
            case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;&#13;
            case 'o': arg = arg.toString(8); break;&#13;
            case 's': arg = ((arg = String(arg)) &amp;&amp; match[7] ? arg.substring(0, match[7]) : arg); break;&#13;
            case 'u': arg = arg &gt;&gt;&gt; 0; break;&#13;
            case 'x': arg = arg.toString(16); break;&#13;
            case 'X': arg = arg.toString(16).toUpperCase(); break;&#13;
          }&#13;
          arg = (/[def]/.test(match[8]) &amp;&amp; match[3] &amp;&amp; arg &gt;= 0 ? '+'+ arg : arg);&#13;
          pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';&#13;
          pad_length = match[6] - String(arg).length;&#13;
          pad = match[6] ? str_repeat(pad_character, pad_length) : '';&#13;
          output.push(match[5] ? arg + pad : pad + arg);&#13;
        }&#13;
      }&#13;
      return output.join('');&#13;
    };&#13;
  &#13;
    sprintf.cache = {};&#13;
  &#13;
    sprintf.parse = function(fmt) {&#13;
      var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;&#13;
      while (_fmt) {&#13;
        if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {&#13;
          parse_tree.push(match[0]);&#13;
        }&#13;
        else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {&#13;
          parse_tree.push('%');&#13;
        }&#13;
        else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {&#13;
          if (match[2]) {&#13;
            arg_names |= 1;&#13;
            var field_list = [], replacement_field = match[2], field_match = [];&#13;
            if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {&#13;
              field_list.push(field_match[1]);&#13;
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {&#13;
                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {&#13;
                  field_list.push(field_match[1]);&#13;
                }&#13;
                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {&#13;
                  field_list.push(field_match[1]);&#13;
                }&#13;
                else {&#13;
                  throw('[sprintf] huh?');&#13;
                }&#13;
              }&#13;
            }&#13;
            else {&#13;
              throw('[sprintf] huh?');&#13;
            }&#13;
            match[2] = field_list;&#13;
          }&#13;
          else {&#13;
            arg_names |= 2;&#13;
          }&#13;
          if (arg_names === 3) {&#13;
            throw('[sprintf] mixing positional and named placeholders is not (yet) supported');&#13;
          }&#13;
          parse_tree.push(match);&#13;
        }&#13;
        else {&#13;
          throw('[sprintf] huh?');&#13;
        }&#13;
        _fmt = _fmt.substring(match[0].length);&#13;
      }&#13;
      return parse_tree;&#13;
    };&#13;
  &#13;
    var vsprintf = function(fmt, argv, _argv) {&#13;
      _argv = argv.slice(0);&#13;
      _argv.splice(0, 0, fmt);&#13;
      return sprintf.apply(null, _argv);&#13;
    };&#13;
  &#13;
    /**&#13;
     * helpers&#13;
     */&#13;
    function get_type(variable) {&#13;
      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();&#13;
    }&#13;
  &#13;
    function str_repeat(input, multiplier) {&#13;
      for (var output = []; multiplier &gt; 0; output[--multiplier] = input) {/* do nothing */}&#13;
      return output.join('');&#13;
    }&#13;
  &#13;
    /**&#13;
     * export to either browser or node.js&#13;
     */&#13;
    ctx.sprintf = sprintf;&#13;
    ctx.vsprintf = vsprintf;&#13;
  })();&#13;
  &#13;
  /*&#13;
   * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.&#13;
   *&#13;
   * Licensed under the Amazon Software License (the "License"). You may not use&#13;
   * this file except in compliance with the License. A copy of the License is&#13;
   * located at&#13;
   *&#13;
   *    http://aws.amazon.com/asl/&#13;
   *&#13;
   * or in the "license" file accompanying this file. This file is distributed&#13;
   * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express&#13;
   * or implied. See the License for the specific language governing permissions&#13;
   * and limitations under the License.&#13;
   */&#13;
  (function() {&#13;
     var global = this;&#13;
     connect = global.connect || {};&#13;
     global.connect = connect;&#13;
     global.lily = connect;&#13;
  &#13;
     // How frequently logs should be collected and reported to shared worker.&#13;
     var LOG_REPORT_INTERVAL_MILLIS = 5000;&#13;
  &#13;
     // The default log roll interval (30min)&#13;
     var DEFAULT_LOG_ROLL_INTERVAL = 1800000;&#13;
  &#13;
     /**&#13;
      * An enumeration of common logging levels.&#13;
      */&#13;
     var LogLevel = {&#13;
        TEST:          "TEST",&#13;
        TRACE:         "TRACE",&#13;
        DEBUG:         "DEBUG",&#13;
        INFO:          "INFO",&#13;
        LOG:           "LOG",&#13;
        WARN:          "WARN",&#13;
        ERROR:         "ERROR",&#13;
        CRITICAL:      "CRITICAL"&#13;
     };&#13;
  &#13;
     /**&#13;
      * An enumeration of common logging components.&#13;
      */&#13;
     var LogComponent = {&#13;
        CCP:          "ccp",&#13;
        SOFTPHONE:    "softphone"&#13;
     };&#13;
  &#13;
     /**&#13;
      * The numeric order of the logging levels above.&#13;
      * They are spaced to allow the addition of other log&#13;
      * levels at a later time.&#13;
      */&#13;
     var LogLevelOrder = {&#13;
        TEST:          0,&#13;
        TRACE:         10,&#13;
        DEBUG:         20,&#13;
        INFO:          30,&#13;
        LOG:           40,&#13;
        WARN:          50,&#13;
        ERROR:         100,&#13;
        CRITICAL:      200&#13;
  &#13;
     };&#13;
  &#13;
     /**&#13;
      * A map from log level to console logger function.&#13;
      */&#13;
     var CONSOLE_LOGGER_MAP = {&#13;
        TRACE:         function(text) {console.info(text);},&#13;
        DEBUG:         function(text) {console.info(text);},&#13;
        INFO:          function(text) {console.info(text);},&#13;
        LOG:           function(text) {console.log(text);},&#13;
        TEST:          function(text) {console.log(text);},&#13;
        WARN:          function(text) {console.warn(text);},&#13;
        ERROR:         function(text) {console.error(text);},&#13;
        CRITICAL:      function(text) {console.error(text);}&#13;
     };&#13;
  &#13;
      /**&#13;
      * Checks if it is a valid log component enum&#13;
      */&#13;
  &#13;
      var isValidLogComponent = function(component) {&#13;
          if (component === LogComponent.CCP || component === LogComponent.SOFTPHONE) {&#13;
              return true;&#13;
          } else {&#13;
              return false;&#13;
          }&#13;
      };&#13;
  &#13;
      /**&#13;
      * Extract the custom arguments as required by the logger&#13;
      */&#13;
      var extractLoggerArgs = function(loggerArgs) {&#13;
            var args = Array.prototype.slice.call(loggerArgs, 0);&#13;
            var firstArg = args.shift();&#13;
            var format;&#13;
            var component;&#13;
            if (isValidLogComponent(firstArg)) {&#13;
              component = firstArg;&#13;
              format = args.shift();&#13;
            } else {&#13;
              //default to CCP component&#13;
              format= firstArg;&#13;
              component = LogComponent.CCP;&#13;
            }&#13;
            return {format: format,&#13;
                    component: component,&#13;
                    args:  args};&#13;
      };&#13;
  &#13;
     /**&#13;
      * A log entry.&#13;
      *&#13;
      * @param level The log level of this log entry.&#13;
      * @param text The text contained in the log entry.&#13;
      *&#13;
      * Log entries are aware of their timestamp, order,&#13;
      * and can contain objects and exception stack traces.&#13;
      */&#13;
     var LogEntry = function(component, level, text) {&#13;
        this.component = component;&#13;
        this.level = level;&#13;
        this.text = text;&#13;
        this.time = new Date();&#13;
        this.exception = null;&#13;
        this.objects = [];&#13;
        this.line = 0;&#13;
     };&#13;
  &#13;
     LogEntry.fromObject = function(obj) {&#13;
        var entry = new LogEntry(LogComponent.CCP, obj.level, obj.text);&#13;
  &#13;
        // Required to check for Date objects sent across frame boundaries&#13;
        if (Object.prototype.toString.call(obj.time) === '[object Date]') {&#13;
           entry.time = new Date(obj.time.getTime());&#13;
        } else if (typeof obj.time === 'number') {&#13;
           entry.time = new Date(obj.time);&#13;
        } else if (typeof obj.time === 'string') {&#13;
           entry.time = Date.parse(obj.time);&#13;
        } else {&#13;
           entry.time = new Date();&#13;
        }&#13;
        entry.exception = obj.exception;&#13;
        entry.objects = obj.objects;&#13;
        return entry;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Pulls the type, message, and stack trace&#13;
      * out of the given exception for JSON serialization.&#13;
      */&#13;
     var LoggedException = function(e) {&#13;
        this.type = Object.prototype.toString.call(e);&#13;
        this.message = e.message;&#13;
        this.stack = e.stack ? e.stack.split('\n') : [];&#13;
     };&#13;
  &#13;
     /**&#13;
      * Minimally stringify this log entry for printing&#13;
      * to the console.&#13;
      */&#13;
     LogEntry.prototype.toString = function() {&#13;
        return connect.sprintf("[%s] [%s]: %s",&#13;
           this.getTime() &amp;&amp; this.getTime().toISOString ? this.getTime().toISOString() : "???",&#13;
           this.getLevel(),&#13;
           this.getText());&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get the log entry timestamp.&#13;
      */&#13;
     LogEntry.prototype.getTime = function() {&#13;
        return this.time;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get the level of the log entry.&#13;
      */&#13;
     LogEntry.prototype.getLevel = function() {&#13;
        return this.level;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get the log entry text.&#13;
      */&#13;
     LogEntry.prototype.getText = function() {&#13;
        return this.text;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get the log entry component.&#13;
      */&#13;
     LogEntry.prototype.getComponent = function() {&#13;
        return this.component;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Add an exception stack trace to this log entry.&#13;
      * A log entry may contain only one exception stack trace.&#13;
      */&#13;
     LogEntry.prototype.withException = function(e) {&#13;
        this.exception = new LoggedException(e);&#13;
        return this;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Add an arbitrary object to the log entry.  A log entry&#13;
      * may contain any number of objects.&#13;
      */&#13;
     LogEntry.prototype.withObject = function(obj) {&#13;
        this.objects.push(connect.deepcopy(obj));&#13;
        return this;&#13;
     };&#13;
  &#13;
     /**&#13;
      * The logger instance.&#13;
      */&#13;
     var Logger = function() {&#13;
        this._logs = [];&#13;
        this._rolledLogs = [];&#13;
        this._logsToPush = [];&#13;
        this._echoLevel = LogLevelOrder.INFO;&#13;
        this._logLevel = LogLevelOrder.INFO;&#13;
        this._lineCount = 0;&#13;
        this._logRollInterval = 0;&#13;
        this._logRollTimer = null;&#13;
        this.setLogRollInterval(DEFAULT_LOG_ROLL_INTERVAL);&#13;
     };&#13;
     &#13;
     /**&#13;
      * Sets the interval in milliseconds that the logs will be rotated.&#13;
      * Logs are rotated out completely at the end of the second roll&#13;
      * and will eventually be garbage collected.&#13;
      */&#13;
     Logger.prototype.setLogRollInterval = function(interval) {&#13;
        var self = this;&#13;
  &#13;
        if (! (this._logRollTimer) || interval !== this._logRollInterval) {&#13;
           if (this._logRollTimer) {&#13;
              global.clearInterval(this._logRollTimer);&#13;
           }&#13;
           this._logRollInterval = interval;&#13;
           this._logRollTimer = global.setInterval(function() {&#13;
              this._rolledLogs = this._logs;&#13;
              this._logs = [];&#13;
              self.info("Log roll interval occurred.");&#13;
           }, this._logRollInterval);&#13;
        } else {&#13;
           this.warn("Logger is already set to the given interval: %d", this._logRollInterval);&#13;
        }&#13;
     };&#13;
  &#13;
     /**&#13;
      * Set the log level.  This is the minimum level at which logs will&#13;
      * be kept for later archiving.&#13;
      */&#13;
     Logger.prototype.setLogLevel = function(level) {&#13;
        if (level in LogLevelOrder) {&#13;
           this._logLevel = LogLevelOrder[level];&#13;
        } else {&#13;
           throw new Error("Unknown logging level: " + level);&#13;
        }&#13;
     };&#13;
  &#13;
     /**&#13;
      * Set the echo level.  This is the minimum level at which logs will&#13;
      * be printed to the javascript console.&#13;
      */&#13;
     Logger.prototype.setEchoLevel = function(level) {&#13;
        if (level in LogLevelOrder) {&#13;
           this._echoLevel = LogLevelOrder[level];&#13;
        } else {&#13;
           throw new Error("Unknown logging level: " + level);&#13;
        }&#13;
     };&#13;
  &#13;
     /**&#13;
      * Write a particular log entry.&#13;
      *&#13;
      * @param level The logging level of the entry.&#13;
      * @param text The text contents of the entry.&#13;
      *&#13;
      * @returns The new log entry.&#13;
      */&#13;
     Logger.prototype.write = function(component, level, text) {&#13;
        var logEntry = new LogEntry(component, level, text);&#13;
        this.addLogEntry(logEntry);&#13;
        return logEntry;&#13;
     };&#13;
  &#13;
     Logger.prototype.addLogEntry = function(logEntry) {&#13;
        this._logs.push(logEntry);&#13;
        //For now only send softphone logs only.&#13;
        //TODO add CCP logs once we are sure that no sensitive data is being logged.&#13;
        if (LogComponent.SOFTPHONE === logEntry.component) {&#13;
           this._logsToPush.push(logEntry);&#13;
        }&#13;
  &#13;
        if (logEntry.level in LogLevelOrder &amp;&amp;&#13;
            LogLevelOrder[logEntry.level] &gt;= this._logLevel) {&#13;
  &#13;
           if (LogLevelOrder[logEntry.level] &gt;= this._echoLevel) {&#13;
              CONSOLE_LOGGER_MAP[logEntry.getLevel()](logEntry.toString());&#13;
           }&#13;
  &#13;
           logEntry.line = this._lineCount++;&#13;
        }&#13;
     };&#13;
  &#13;
     /**&#13;
      * Remove all objects from all log entries.&#13;
      */&#13;
     Logger.prototype.clearObjects = function() {&#13;
        for (var x = 0; x &lt; this._logs.length; x++) {&#13;
           if (this._logs[x].objects) {&#13;
              delete this._logs[x].objects;&#13;
           }&#13;
        }&#13;
     };&#13;
  &#13;
     /**&#13;
      * Remove all exception stack traces from the log entries.&#13;
      */&#13;
     Logger.prototype.clearExceptions = function() {&#13;
        for (var x = 0; x &lt; this._logs.length; x++) {&#13;
           if (this._logs[x].exception) {&#13;
              delete this._logs[x].exception;&#13;
           }&#13;
        }&#13;
     };&#13;
  &#13;
     Logger.prototype.trace = function() {&#13;
        var logArgs = extractLoggerArgs(arguments);&#13;
        return this.write(logArgs.component, LogLevel.TRACE, connect.vsprintf(logArgs.format, logArgs.args));&#13;
     };&#13;
  &#13;
     Logger.prototype.debug = function() {&#13;
        var logArgs = extractLoggerArgs(arguments);&#13;
        return this.write(logArgs.component, LogLevel.DEBUG, connect.vsprintf(logArgs.format, logArgs.args));&#13;
     };&#13;
  &#13;
     Logger.prototype.info = function() {&#13;
        var logArgs = extractLoggerArgs(arguments);&#13;
        return this.write(logArgs.component, LogLevel.INFO, connect.vsprintf(logArgs.format, logArgs.args));&#13;
     };&#13;
  &#13;
     Logger.prototype.log = function() {&#13;
        var logArgs = extractLoggerArgs(arguments);&#13;
        return this.write(logArgs.component, LogLevel.LOG, connect.vsprintf(logArgs.format, logArgs.args));&#13;
     };&#13;
  &#13;
     Logger.prototype.test = function() {&#13;
        var logArgs = extractLoggerArgs(arguments);&#13;
        return this.write(logArgs.component, LogLevel.TEST, connect.vsprintf(logArgs.format, logArgs.args));&#13;
     };&#13;
  &#13;
     Logger.prototype.warn = function() {&#13;
        var logArgs = extractLoggerArgs(arguments);&#13;
        return this.write(logArgs.component, LogLevel.WARN, connect.vsprintf(logArgs.format, logArgs.args));&#13;
     };&#13;
  &#13;
     Logger.prototype.error = function() {&#13;
        var logArgs = extractLoggerArgs(arguments);&#13;
        return this.write(logArgs.component, LogLevel.ERROR, connect.vsprintf(logArgs.format, logArgs.args));&#13;
     };&#13;
  &#13;
     Logger.prototype.critical = function() {&#13;
        var logArgs = extractLoggerArgs(arguments);&#13;
        return this.write(logArgs.component, LogLevel.ERROR, connect.vsprintf(logArgs.format, logArgs.args));&#13;
     };&#13;
  &#13;
     /**&#13;
      * Create a string representation of the logger contents.&#13;
      */&#13;
     Logger.prototype.toString = function() {&#13;
        var lines = [];&#13;
        for (var x = 0; x &lt; this._logs.length; x++) {&#13;
           lines.push(this._logs[x].toString());&#13;
        }&#13;
  &#13;
        return lines.join("\n");&#13;
     };&#13;
  &#13;
     Logger.prototype.download = function() {&#13;
        var logBlob = new global.Blob([JSON.stringify(this._rolledLogs.concat(this._logs), undefined, 4)], ['text/plain']);&#13;
        var downloadLink = document.createElement('a');&#13;
        downloadLink.href = global.URL.createObjectURL(logBlob);&#13;
        downloadLink.download = 'agent-log.txt';&#13;
        document.body.appendChild(downloadLink);&#13;
        downloadLink.click();&#13;
        document.body.removeChild(downloadLink);&#13;
     };&#13;
  &#13;
     Logger.prototype.scheduleUpstreamLogPush = function(conduit) {&#13;
        if (!connect.upstreamLogPushScheduled) {&#13;
            connect.upstreamLogPushScheduled = true;&#13;
            /** Schedule pushing logs frequently to sharedworker upstream, sharedworker will report to LARS*/&#13;
            global.setInterval(connect.hitch(this, this.reportMasterLogsUpStream, conduit), LOG_REPORT_INTERVAL_MILLIS);&#13;
        }&#13;
     };&#13;
  &#13;
     Logger.prototype.reportMasterLogsUpStream = function(conduit) {&#13;
        var logsToPush = this._logsToPush.slice();&#13;
        this._logsToPush = [];&#13;
        connect.ifMaster(connect.MasterTopics.SEND_LOGS, function(){&#13;
            if (logsToPush.length &gt; 0) {&#13;
               conduit.sendUpstream(connect.EventType.SEND_LOGS, logsToPush);&#13;
            }&#13;
        });&#13;
     };&#13;
  &#13;
     var DownstreamConduitLogger = function(conduit) {&#13;
        Logger.call(this);&#13;
        this.conduit = conduit;&#13;
        global.setInterval(connect.hitch(this, this._pushLogsDownstream),&#13;
              DownstreamConduitLogger.LOG_PUSH_INTERVAL);&#13;
  &#13;
        // Disable log rolling, we will purge our own logs once they have&#13;
        // been pushed downstream.&#13;
        global.clearInterval(this._logRollTimer);&#13;
        this._logRollTimer = null;&#13;
     };&#13;
     // How frequently logs should be collected and delivered downstream.&#13;
     DownstreamConduitLogger.LOG_PUSH_INTERVAL = 1000;&#13;
     DownstreamConduitLogger.prototype = Object.create(Logger.prototype);&#13;
     DownstreamConduitLogger.prototype.constructor = DownstreamConduitLogger;&#13;
  &#13;
     DownstreamConduitLogger.prototype._pushLogsDownstream = function() {&#13;
        var self = this;&#13;
        this._logs.forEach(function(log) {&#13;
           self.conduit.sendDownstream(connect.EventType.LOG, log);&#13;
        });&#13;
        this._logs = [];&#13;
     };&#13;
  &#13;
     /** Create the singleton logger instance. */&#13;
     connect.rootLogger = new Logger();&#13;
  &#13;
     /** Fetch the singleton logger instance. */&#13;
     var getLog = function() {&#13;
        return connect.rootLogger;&#13;
     };&#13;
  &#13;
     connect = connect || {};&#13;
     connect.getLog = getLog;&#13;
     connect.LogEntry = LogEntry;&#13;
     connect.Logger = Logger;&#13;
     connect.LogLevel = LogLevel;&#13;
     connect.LogComponent = LogComponent;&#13;
     connect.DownstreamConduitLogger = DownstreamConduitLogger;&#13;
  })();&#13;
  /*&#13;
   * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.&#13;
   *&#13;
   * Licensed under the Amazon Software License (the "License"). You may not use&#13;
   * this file except in compliance with the License. A copy of the License is&#13;
   * located at&#13;
   *&#13;
   *    http://aws.amazon.com/asl/&#13;
   *&#13;
   * or in the "license" file accompanying this file. This file is distributed&#13;
   * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express&#13;
   * or implied. See the License for the specific language governing permissions&#13;
   * and limitations under the License.&#13;
   */&#13;
  (function() {&#13;
     var global = this;&#13;
     connect = global.connect || {};&#13;
     global.connect = connect;&#13;
     global.lily = connect;&#13;
  &#13;
     var userAgent = navigator.userAgent;&#13;
     var ONE_DAY_MILLIS = 24*60*60*1000;&#13;
  &#13;
     /**&#13;
      * Unpollute sprintf functions from the global namespace.&#13;
      */&#13;
     connect.sprintf = global.sprintf;&#13;
     connect.vsprintf = global.vsprintf;&#13;
     delete global.sprintf;&#13;
     delete global.vsprintf;&#13;
  &#13;
     /**&#13;
      * Binds the given instance object as the context for&#13;
      * the method provided.&#13;
      *&#13;
      * @param scope The instance object to be set as the scope&#13;
      *    of the function.&#13;
      * @param method The method to be encapsulated.&#13;
      *&#13;
      * All other arguments, if any, are bound to the method&#13;
      * invocation inside the closure.&#13;
      *&#13;
      * @return A closure encapsulating the invocation of the&#13;
      *    method provided in context of the given instance.&#13;
      */&#13;
     connect.hitch = function() {&#13;
        var args = Array.prototype.slice.call(arguments);&#13;
        var scope = args.shift();&#13;
        var method = args.shift();&#13;
  &#13;
        connect.assertNotNull(scope, 'scope');&#13;
        connect.assertNotNull(method, 'method');&#13;
        connect.assertTrue(connect.isFunction(method), 'method must be a function');&#13;
  &#13;
        return function() {&#13;
           var closureArgs = Array.prototype.slice.call(arguments);&#13;
           return method.apply(scope, args.concat(closureArgs));&#13;
        };&#13;
     };&#13;
  &#13;
     /**&#13;
      * Determine if the given value is a callable function type.&#13;
      * Borrowed from Underscore.js.&#13;
      */&#13;
     connect.isFunction = function(obj) {&#13;
        return !!(obj &amp;&amp; obj.constructor &amp;&amp; obj.call &amp;&amp; obj.apply);&#13;
     };&#13;
  &#13;
     /**&#13;
      * Determine if the given value is an array.&#13;
      */&#13;
     connect.isArray = function(obj) {&#13;
        return Object.prototype.toString.call(obj) === '[object Array]';&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get a list of keys from a Javascript object used&#13;
      * as a hash map.&#13;
      */&#13;
     connect.keys = function(map) {&#13;
        var keys = [];&#13;
  &#13;
        connect.assertNotNull(map, 'map');&#13;
  &#13;
        for (var k in map) {&#13;
           keys.push(k);&#13;
        }&#13;
  &#13;
        return keys;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get a list of values from a Javascript object used&#13;
      * as a hash map.&#13;
      */&#13;
     connect.values = function(map) {&#13;
        var values = [];&#13;
  &#13;
        connect.assertNotNull(map, 'map');&#13;
  &#13;
        for (var k in map) {&#13;
           values.push(map[k]);&#13;
        }&#13;
  &#13;
        return values;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get a list of key/value pairs from the given map.&#13;
      */&#13;
     connect.entries = function(map) {&#13;
        var entries = [];&#13;
  &#13;
        for (var k in map) {&#13;
           entries.push({key: k, value: map[k]});&#13;
        }&#13;
  &#13;
        return entries;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Merge two or more maps together into a new map,&#13;
      * or simply copy a single map.&#13;
      */&#13;
     connect.merge = function() {&#13;
        var argMaps = Array.prototype.slice.call(arguments, 0);&#13;
        var resultMap = {};&#13;
  &#13;
        argMaps.forEach(function(map) {&#13;
           connect.entries(map).forEach(function(kv) {&#13;
              resultMap[kv.key] = kv.value;&#13;
           });&#13;
        });&#13;
  &#13;
        return resultMap;&#13;
     };&#13;
  &#13;
     connect.now = function() {&#13;
        return new Date().getTime();&#13;
     };&#13;
  &#13;
     connect.find = function(array, predicate) {&#13;
        for (var x = 0; x &lt; array.length; x++) {&#13;
           if (predicate(array[x])) {&#13;
              return array[x];&#13;
           }&#13;
        }&#13;
  &#13;
        return null;&#13;
     };&#13;
  &#13;
     connect.contains = function(obj, value) {&#13;
        if (obj instanceof Array) {&#13;
           return connect.find(obj, function(v) { return v === value; }) != null;&#13;
  &#13;
        } else {&#13;
           return (value in obj);&#13;
        }&#13;
     };&#13;
  &#13;
     connect.containsValue = function(obj, value) {&#13;
        if (obj instanceof Array) {&#13;
           return connect.find(obj, function(v) { return v === value; }) != null;&#13;
  &#13;
        } else {&#13;
           return connect.find(connect.values(obj), function(v) { return v === value; }) != null;&#13;
        }&#13;
     };&#13;
  &#13;
     /**&#13;
      * Generate a random ID consisting of the current timestamp&#13;
      * and a random base-36 number based on Math.random().&#13;
      */&#13;
     connect.randomId = function() {&#13;
        return connect.sprintf("%s-%s", connect.now(), Math.random().toString(36).slice(2));&#13;
     };&#13;
  &#13;
     /**&#13;
      * Generate an enum from the given list of lower-case enum values,&#13;
      * where the enum keys will be upper case.&#13;
      *&#13;
      * Conversion from pascal case based on code from here:&#13;
      * http://stackoverflow.com/questions/30521224&#13;
      */&#13;
     connect.makeEnum = function(values) {&#13;
        var enumObj = {};&#13;
  &#13;
        values.forEach(function(value) {&#13;
           var key = value.replace(/\.?([a-z]+)_?/g, function (x, y) { return y.toUpperCase() + "_"; })&#13;
              .replace(/_$/, "");&#13;
  &#13;
           enumObj[key] = value;&#13;
        });&#13;
  &#13;
        return enumObj;&#13;
     };&#13;
  &#13;
     connect.makeNamespacedEnum = function(prefix, values) {&#13;
        var enumObj = connect.makeEnum(values);&#13;
        connect.keys(enumObj).forEach(function(key) {&#13;
           enumObj[key] = connect.sprintf("%s::%s", prefix, enumObj[key]);&#13;
        });&#13;
        return enumObj;&#13;
     };&#13;
  &#13;
     /**&#13;
     * Methods to determine browser type and versions, used for softphone initialization.&#13;
     */&#13;
     connect.isChromeBrowser = function() {&#13;
         return userAgent.indexOf("Chrome") !== -1;&#13;
     };&#13;
  &#13;
     connect.isFirefoxBrowser = function() {&#13;
         return userAgent.indexOf("Firefox") !== -1;&#13;
     };&#13;
  &#13;
     connect.isOperaBrowser = function() {&#13;
         return userAgent.indexOf("Opera") !== -1;&#13;
     };&#13;
  &#13;
     connect.getChromeBrowserVersion = function() {&#13;
         var chromeVersion = userAgent.substring(userAgent.indexOf("Chrome")+7);&#13;
         if (chromeVersion) {&#13;
             return parseFloat(chromeVersion);&#13;
         } else {&#13;
             return -1;&#13;
         }&#13;
     };&#13;
  &#13;
     connect.getFirefoxBrowserVersion = function() {&#13;
         var firefoxVersion = userAgent.substring(userAgent.indexOf("Firefox")+8);&#13;
         if (firefoxVersion) {&#13;
             return parseFloat(firefoxVersion);&#13;
         } else {&#13;
             return -1;&#13;
         }&#13;
     };&#13;
  &#13;
     connect.getOperaBrowserVersion = function() {&#13;
         var versionOffset = userAgent.indexOf("Opera");&#13;
         var operaVersion = (userAgent.indexOf("Version") !== -1) ? userAgent.substring(versionOffset+8) : userAgent.substring(versionOffset+6);&#13;
         if (operaVersion) {&#13;
             return parseFloat(operaVersion);&#13;
         } else {&#13;
             return -1;&#13;
         }&#13;
     };&#13;
  &#13;
     /**&#13;
      * Return a map of items in the given list indexed by&#13;
      * keys determined by the closure provided.&#13;
      *&#13;
      * @param iterable A list-like object.&#13;
      * @param closure A closure to determine the index for the&#13;
      *    items in the iterable.&#13;
      * @return A map from index to item for each item in the iterable.&#13;
      */&#13;
     connect.index = function(iterable, closure) {&#13;
        var map = {};&#13;
  &#13;
        iterable.forEach(function(item) {&#13;
           map[closure(item)] = item;&#13;
        });&#13;
  &#13;
        return map;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Converts the given array into a map as a set,&#13;
      * where elements in the array are mapped to 1.&#13;
      */&#13;
     connect.set = function(arrayIn) {&#13;
        var setMap = {};&#13;
  &#13;
        arrayIn.forEach(function(key) {&#13;
           setMap[key] = 1;&#13;
        });&#13;
  &#13;
        return setMap;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Returns a map for each key in mapB which&#13;
      * is NOT in mapA.&#13;
      */&#13;
     connect.relativeComplement = function(mapA, mapB) {&#13;
        var compMap = {};&#13;
  &#13;
        connect.keys(mapB).forEach(function(key) {&#13;
           if (! (key in mapA)) {&#13;
              compMap[key] = mapB[key];&#13;
           }&#13;
        });&#13;
  &#13;
        return compMap;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Asserts that a premise is true.&#13;
      */&#13;
     connect.assertTrue = function(premise, message) {&#13;
        if (! premise) {&#13;
           throw new connect.ValueError(message);&#13;
        }&#13;
     };&#13;
  &#13;
     /**&#13;
      * Asserts that a value is not null or undefined.&#13;
      */&#13;
     connect.assertNotNull = function(value, name) {&#13;
        connect.assertTrue(value != null &amp;&amp; typeof value !== undefined,&#13;
              connect.sprintf("%s must be provided", name || 'A value'));&#13;
        return value;&#13;
     };&#13;
  &#13;
     connect.deepcopy = function(src) {&#13;
        return JSON.parse(JSON.stringify(src));&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get the current base url of the open page, e.g. if the page is&#13;
      * https://example.com:9494/oranges, this will be "https://example.com:9494".&#13;
      */&#13;
     connect.getBaseUrl = function() {&#13;
        var location = global.location;&#13;
        return connect.sprintf("%s//%s:%s", location.protocol, location.hostname, location.port);&#13;
     };&#13;
  &#13;
     /**&#13;
      * Determine if the current window is in an iframe.&#13;
      * Courtesy: http://stackoverflow.com/questions/326069/&#13;
      */&#13;
     connect.isFramed = function() {&#13;
        try {&#13;
           return window.self !== window.top;&#13;
        } catch (e) {&#13;
           return true;&#13;
        }&#13;
     };&#13;
  &#13;
     /**&#13;
      * A wrapper around Window.open() for managing single instance popups.&#13;
      */&#13;
     connect.PopupManager = function() {};&#13;
  &#13;
     connect.PopupManager.prototype.open = function(url, name) {&#13;
        var then = this._getLastOpenedTimestamp(name);&#13;
        var now = new Date().getTime();&#13;
  &#13;
        if (now - then &gt; ONE_DAY_MILLIS) {&#13;
           var win = window.open('', name);&#13;
           if (win.location !== url) {&#13;
              window.open(url, name);&#13;
           }&#13;
           this._setLastOpenedTimestamp(name, now);&#13;
        }&#13;
     };&#13;
  &#13;
     connect.PopupManager.prototype.clear = function(name) {&#13;
        var key = this._getLocalStorageKey(name);&#13;
        global.localStorage.removeItem(key);&#13;
     };&#13;
  &#13;
     connect.PopupManager.prototype._getLastOpenedTimestamp = function(name) {&#13;
        var key = this._getLocalStorageKey(name);&#13;
        var value = global.localStorage.getItem(key);&#13;
  &#13;
        if (value) {&#13;
           return parseInt(value, 10);&#13;
  &#13;
        } else {&#13;
           return 0;&#13;
        }&#13;
     };&#13;
  &#13;
     connect.PopupManager.prototype._setLastOpenedTimestamp = function(name, ts) {&#13;
        var key = this._getLocalStorageKey(name);&#13;
        global.localStorage.setItem(key, '' + ts);&#13;
     };&#13;
  &#13;
     connect.PopupManager.prototype._getLocalStorageKey = function(name) {&#13;
        return "connectPopupManager::" + name;&#13;
     };&#13;
  &#13;
     /**&#13;
      * An enumeration of the HTML5 notification permission values.&#13;
      */&#13;
     var NotificationPermission = connect.makeEnum([&#13;
        'granted',&#13;
        'denied',&#13;
        'default'&#13;
     ]);&#13;
  &#13;
     /**&#13;
      * A simple engine for showing notification popups.&#13;
      */&#13;
     connect.NotificationManager = function() {&#13;
        this.queue = [];&#13;
        this.permission = NotificationPermission.DEFAULT;&#13;
     };&#13;
  &#13;
     connect.NotificationManager.prototype.requestPermission = function() {&#13;
        var self = this;&#13;
        if (!("Notification" in global)) {&#13;
           connect.getLog().warn("This browser doesn't support notifications.");&#13;
           this.permission = NotificationPermission.DENIED;&#13;
  &#13;
        } else if (global.Notification.permission === NotificationPermission.DENIED) {&#13;
           connect.getLog().warn("The user has requested to not receive notifications.");&#13;
           this.permission = NotificationPermission.DENIED;&#13;
  &#13;
        } else if (this.permission !== NotificationPermission.GRANTED) {&#13;
           global.Notification.requestPermission(function(permission) {&#13;
              self.permission = permission;&#13;
              if (permission === NotificationPermission.GRANTED) {&#13;
                 self._showQueued();&#13;
  &#13;
              } else {&#13;
                 self.queue = [];&#13;
              }&#13;
           });&#13;
        }&#13;
     };&#13;
  &#13;
     connect.NotificationManager.prototype.show = function(title, options) {&#13;
        if (this.permission === NotificationPermission.GRANTED) {&#13;
           return this._showImpl({title: title, options: options});&#13;
  &#13;
        } else if (this.permission === NotificationPermission.DENIED) {&#13;
           connect.getLog().warn("Unable to show notification.").withObject({&#13;
              title: title,&#13;
              options: options&#13;
           });&#13;
  &#13;
        } else {&#13;
           var params = {title: title, options: options};&#13;
           connect.getLog().warn("Deferring notification until user decides to allow or deny.")&#13;
              .withObject(params);&#13;
           this.queue.push(params);&#13;
        }&#13;
     };&#13;
  &#13;
     connect.NotificationManager.prototype._showQueued = function() {&#13;
        var self = this;&#13;
        var notifications = this.queue.map(function(params) {&#13;
           return self._showImpl(params);&#13;
        });&#13;
        this.queue = [];&#13;
        return notifications;&#13;
     };&#13;
  &#13;
     connect.NotificationManager.prototype._showImpl = function(params) {&#13;
        var notification = new global.Notification(params.title, params.options);&#13;
        if (params.options.clicked) {&#13;
           notification.onclick = function() {&#13;
              params.options.clicked.call(notification);&#13;
           };&#13;
        }&#13;
        return notification;&#13;
     };&#13;
  &#13;
     connect.BaseError = function(format, args) {&#13;
        global.Error.call(this, connect.vsprintf(format, args));&#13;
     };&#13;
     connect.BaseError.prototype = Object.create(Error.prototype);&#13;
     connect.BaseError.prototype.constructor = connect.BaseError;&#13;
  &#13;
     connect.ValueError = function() {&#13;
        var args = Array.prototype.slice.call(arguments, 0);&#13;
        var format = args.shift();&#13;
        connect.BaseError.call(this, format, args);&#13;
     };&#13;
     connect.ValueError.prototype = Object.create(connect.BaseError.prototype);&#13;
     connect.ValueError.prototype.constructor = connect.ValueError;&#13;
  &#13;
     connect.NotImplementedError = function() {&#13;
        var args = Array.prototype.slice.call(arguments, 0);&#13;
        var format = args.shift();&#13;
        connect.BaseError.call(this, format, args);&#13;
     };&#13;
     connect.NotImplementedError.prototype = Object.create(connect.BaseError.prototype);&#13;
     connect.NotImplementedError.prototype.constructor = connect.NotImplementedError;&#13;
  &#13;
     connect.StateError = function() {&#13;
        var args = Array.prototype.slice.call(arguments, 0);&#13;
        var format = args.shift();&#13;
        connect.BaseError.call(this, format, args);&#13;
     };&#13;
     connect.StateError.prototype = Object.create(connect.BaseError.prototype);&#13;
     connect.StateError.prototype.constructor = connect.StateError;&#13;
  &#13;
  })();&#13;
  /*&#13;
   * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.&#13;
   *&#13;
   * Licensed under the Amazon Software License (the "License"). You may not use&#13;
   * this file except in compliance with the License. A copy of the License is&#13;
   * located at&#13;
   *&#13;
   *    http://aws.amazon.com/asl/&#13;
   *&#13;
   * or in the "license" file accompanying this file. This file is distributed&#13;
   * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express&#13;
   * or implied. See the License for the specific language governing permissions&#13;
   * and limitations under the License.&#13;
   */&#13;
  (function() {&#13;
     var global = this;&#13;
     connect = global.connect || {};&#13;
     global.connect = connect;&#13;
  &#13;
     var ALL_EVENTS = '&lt;&lt;all&gt;&gt;';&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * enum EventType&#13;
      */&#13;
     var EventType = connect.makeEnum([&#13;
           'acknowledge',&#13;
           'ack_timeout',&#13;
           'api_request',&#13;
           'api_response',&#13;
           'auth_fail',&#13;
           'close',&#13;
           'configure',&#13;
           'log',&#13;
           'master_request',&#13;
           'master_response',&#13;
           'synchronize',&#13;
           'terminate',&#13;
           'terminated',&#13;
           'send_logs',&#13;
           'reload_agent_configuration',&#13;
           'broadcast'&#13;
     ]);&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * enum MasterTopics&#13;
      */&#13;
     var MasterTopics = connect.makeNamespacedEnum('connect', [&#13;
           'loginPopup',&#13;
           'sendLogs',&#13;
           'softphone',&#13;
           'ringtone'&#13;
     ]);&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * enum AgentEvents&#13;
      */&#13;
     var AgentEvents = connect.makeNamespacedEnum('agent', [&#13;
           'init',&#13;
           'update',&#13;
           'refresh',&#13;
           'routable',&#13;
           'not_routable',&#13;
           'pending',&#13;
           'contact_pending',&#13;
           'offline',&#13;
           'error',&#13;
           'softphone_error',&#13;
           'state_change',&#13;
           'acw'&#13;
     ]);&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * enum ContactEvents&#13;
      */&#13;
     var ContactEvents = connect.makeNamespacedEnum('contact', [&#13;
           'init',&#13;
           'refresh',&#13;
           'destroyed',&#13;
           'incoming',&#13;
           'pending',&#13;
           'connecting',&#13;
           'connected',&#13;
           'missed',&#13;
           'acw',&#13;
           'ended',&#13;
           'error',&#13;
           'accepted'&#13;
     ]);&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class EventFactory&#13;
      */&#13;
     var EventFactory = function() {};&#13;
     EventFactory.createRequest = function(type, method, params) {&#13;
        return {&#13;
           event:      type,&#13;
           requestId:  connect.randomId(),&#13;
           method:     method,&#13;
           params:     params&#13;
        };&#13;
     };&#13;
  &#13;
     EventFactory.createResponse = function(type, request, data, err) {&#13;
        return {&#13;
           event:      type,&#13;
           requestId:  request.requestId,&#13;
           data:       data,&#13;
           err:        err || null&#13;
        };&#13;
     };&#13;
  &#13;
     /**&#13;
      * An object representing an event subscription in an EventBus.&#13;
      */&#13;
     var Subscription = function(subMap, eventName, f) {&#13;
        this.subMap = subMap;&#13;
        this.id = connect.randomId();&#13;
        this.eventName = eventName;&#13;
        this.f = f;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Unsubscribe the handler of this subscription from the EventBus&#13;
      * from which it was created.&#13;
      */&#13;
     Subscription.prototype.unsubscribe = function() {&#13;
        this.subMap.unsubscribe(this.eventName, this.id);&#13;
     };&#13;
  &#13;
     /**&#13;
      * A map of event subscriptions, used by the EventBus.&#13;
      */&#13;
     var SubscriptionMap = function() {&#13;
        this.subIdMap = {};&#13;
        this.subEventNameMap = {};&#13;
     };&#13;
  &#13;
     /**&#13;
      * Add a subscription for the named event.  Creates a new Subscription&#13;
      * object and returns it.  This object can be used to unsubscribe.&#13;
      */&#13;
     SubscriptionMap.prototype.subscribe = function(eventName, f) {&#13;
        var sub = new Subscription(this, eventName, f);&#13;
  &#13;
        this.subIdMap[sub.id] = sub;&#13;
        var subList = this.subEventNameMap[eventName] || [];&#13;
        subList.push(sub);&#13;
        this.subEventNameMap[eventName] = subList;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Unsubscribe a subscription matching the given event name and id.&#13;
      */&#13;
     SubscriptionMap.prototype.unsubscribe = function(eventName, subId) {&#13;
        if (connect.contains(this.subEventNameMap, eventName)) {&#13;
           this.subEventNameMap[eventName] = this.subEventNameMap[eventName].filter(function(s) { return s.id !== subId; });&#13;
  &#13;
           if (this.subEventNameMap[eventName].length &lt; 1) {&#13;
              delete this.subEventNameMap[eventName];&#13;
           }&#13;
        }&#13;
  &#13;
        if (connect.contains(this.subIdMap, subId)) {&#13;
           delete this.subIdMap[subId];&#13;
        }&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get a list of all subscriptions in the subscription map.&#13;
      */&#13;
     SubscriptionMap.prototype.getAllSubscriptions = function() {&#13;
        return connect.values(this.subEventNameMap).reduce(function(a, b) {&#13;
           return a.concat(b);&#13;
        }, []);&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get a list of subscriptions for the given event name, or an empty&#13;
      * list if there are no subscriptions.&#13;
      */&#13;
     SubscriptionMap.prototype.getSubscriptions = function(eventName) {&#13;
        return this.subEventNameMap[eventName] || [];&#13;
     };&#13;
  &#13;
     /**&#13;
      * An object which maintains a map of subscriptions and serves as the&#13;
      * mechanism for triggering events to be handled by subscribers.&#13;
      */&#13;
     var EventBus = function(paramsIn) {&#13;
        var params = paramsIn || {};&#13;
  &#13;
        this.subMap = new SubscriptionMap();&#13;
        this.logEvents = params.logEvents || false;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Subscribe to the named event.  Returns a new Subscription object&#13;
      * which can be used to unsubscribe.&#13;
      */&#13;
     EventBus.prototype.subscribe = function(eventName, f) {&#13;
        connect.assertNotNull(eventName, 'eventName');&#13;
        connect.assertNotNull(f, 'f');&#13;
        connect.assertTrue(connect.isFunction(f), 'f must be a function');&#13;
        return this.subMap.subscribe(eventName, f);&#13;
     };&#13;
  &#13;
     /**&#13;
      * Subscribe a function to be called on all events.&#13;
      */&#13;
     EventBus.prototype.subscribeAll = function(f) {&#13;
        connect.assertNotNull(f, 'f');&#13;
        connect.assertTrue(connect.isFunction(f), 'f must be a function');&#13;
        return this.subMap.subscribe(ALL_EVENTS, f);&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get a list of subscriptions for the given event name, or an empty&#13;
      * list if there are no subscriptions.&#13;
      */&#13;
     EventBus.prototype.getSubscriptions = function(eventName) {&#13;
        return this.subMap.getSubscriptions(eventName);&#13;
     };&#13;
  &#13;
     /**&#13;
      * Trigger the given event with the given data.  All methods subscribed&#13;
      * to this event will be called and are provided with the given arbitrary&#13;
      * data object and the name of the event, in that order.&#13;
      */&#13;
     EventBus.prototype.trigger = function(eventName, data) {&#13;
        connect.assertNotNull(eventName, 'eventName');&#13;
        var self = this;&#13;
        var allEventSubs = this.subMap.getSubscriptions(ALL_EVENTS);&#13;
        var eventSubs = this.subMap.getSubscriptions(eventName);&#13;
  &#13;
        if (this.logEvents) {&#13;
           connect.getLog().trace("Publishing event: %s", eventName);&#13;
        }&#13;
  &#13;
        allEventSubs.concat(eventSubs).forEach(function(sub) {&#13;
           try {&#13;
              sub.f(data || null, eventName, self);&#13;
  &#13;
           } catch (e) {&#13;
              connect.getLog().error("'%s' event handler failed.", eventName).withException(e);&#13;
           }&#13;
        });&#13;
     };&#13;
  &#13;
     /**&#13;
      * Returns a closure which bridges an event from another EventBus to this bus.&#13;
      *&#13;
      * Usage:&#13;
      * conduit.onUpstream("MyEvent", bus.bridge());&#13;
      */&#13;
     EventBus.prototype.bridge = function() {&#13;
        var self = this;&#13;
        return function(data, event) {&#13;
           self.trigger(event, data);&#13;
        };&#13;
     };&#13;
  &#13;
     /**&#13;
      * Unsubscribe all events in the event bus.&#13;
      */&#13;
     EventBus.prototype.unsubscribeAll = function() {&#13;
        this.subMap.getAllSubscriptions().forEach(function(sub) {&#13;
           sub.unsubscribe();&#13;
        });&#13;
     };&#13;
  &#13;
     connect.EventBus = EventBus;&#13;
     connect.EventFactory = EventFactory;&#13;
     connect.EventType = EventType;&#13;
     connect.AgentEvents = AgentEvents;&#13;
     connect.ContactEvents = ContactEvents;&#13;
     connect.MasterTopics = MasterTopics;&#13;
  })();&#13;
  /*&#13;
   * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.&#13;
   *&#13;
   * Licensed under the Amazon Software License (the "License"). You may not use&#13;
   * this file except in compliance with the License. A copy of the License is&#13;
   * located at&#13;
   *&#13;
   *    http://aws.amazon.com/asl/&#13;
   *&#13;
   * or in the "license" file accompanying this file. This file is distributed&#13;
   * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express&#13;
   * or implied. See the License for the specific language governing permissions&#13;
   * and limitations under the License.&#13;
   */&#13;
  (function() {&#13;
     var global = this;&#13;
     connect = global.connect || {};&#13;
     global.connect = connect;&#13;
     global.lily = connect;&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class Stream&#13;
      *&#13;
      * Represents an object from which messages can be read and to which&#13;
      * messages can be sent.&#13;
      */&#13;
     var Stream = function() {};&#13;
  &#13;
     /**&#13;
      * Send a message to the stream.  This method must be implemented by subclasses.&#13;
      */&#13;
     Stream.prototype.send = function(message) {&#13;
        throw new connect.NotImplementedError();&#13;
     };&#13;
  &#13;
     /**&#13;
      * Provide a method to be called when messages are received from this stream.&#13;
      * This method must be implemented by subclasses.&#13;
      */&#13;
     Stream.prototype.onMessage = function(f) {&#13;
        throw new connect.NotImplementedError();&#13;
     };&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class NullStream extends Stream&#13;
      *&#13;
      * A null stream which provides no message sending or receiving facilities.&#13;
      */&#13;
     var NullStream = function() {&#13;
        Stream.call(this);&#13;
     };&#13;
     NullStream.prototype = Object.create(Stream.prototype);&#13;
     NullStream.prototype.constructor = NullStream;&#13;
  &#13;
     NullStream.prototype.onMessage = function(f) {};&#13;
     NullStream.prototype.send = function(message) {};&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class WindowStream extends Stream&#13;
      *&#13;
      * A stream for communicating with a window object.  The domain provided&#13;
      * must match the allowed message domains of the downstream receiver&#13;
      * or messages will be rejected, see https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage&#13;
      * for more info.&#13;
      */&#13;
     var WindowStream = function(win, domain) {&#13;
        Stream.call(this);&#13;
        this.window = win;&#13;
        this.domain = domain || '*';&#13;
     };&#13;
     WindowStream.prototype = Object.create(Stream.prototype);&#13;
     WindowStream.prototype.constructor = WindowStream;&#13;
  &#13;
     WindowStream.prototype.send = function(message) {&#13;
        this.window.postMessage(message, this.domain);&#13;
     };&#13;
  &#13;
     WindowStream.prototype.onMessage = function(f) {&#13;
        this.window.addEventListener("message", f);&#13;
     };&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class WindowIOStream extends Stream&#13;
      *&#13;
      * A stream used by IFrame/popup windows to communicate with their parents&#13;
      * and vise versa.&#13;
      *&#13;
      * This object encapsulates the fact that incoming and outgoing messages&#13;
      * arrive on different windows and allows this to be managed as a single&#13;
      * Stream object.&#13;
      */&#13;
     var WindowIOStream = function(inputwin, outputwin, domain) {&#13;
        Stream.call(this);&#13;
        this.input = inputwin;&#13;
        this.output = outputwin;&#13;
        this.domain = domain || '*';&#13;
     };&#13;
     WindowIOStream.prototype = Object.create(Stream.prototype);&#13;
     WindowIOStream.prototype.constructor = WindowIOStream;&#13;
  &#13;
     WindowIOStream.prototype.send = function(message) {&#13;
        this.output.postMessage(message, this.domain);&#13;
     };&#13;
  &#13;
     WindowIOStream.prototype.onMessage = function(f) {&#13;
        this.input.addEventListener("message", f);&#13;
     };&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class PortStream extends Stream&#13;
      *&#13;
      * A stream wrapping an HTML5 Worker port.  This could be the port&#13;
      * used to connect to a Worker or one of the multitude of ports&#13;
      * made available to a SharedWorker for communication back to&#13;
      * its connected clients.&#13;
      */&#13;
     var PortStream = function(port) {&#13;
        Stream.call(this);&#13;
        this.port = port;&#13;
        this.id = connect.randomId();&#13;
     };&#13;
     PortStream.prototype = Object.create(Stream.prototype);&#13;
     PortStream.prototype.constructor = PortStream;&#13;
  &#13;
     PortStream.prototype.send = function(message) {&#13;
        this.port.postMessage(message);&#13;
     };&#13;
  &#13;
     PortStream.prototype.onMessage = function(f) {&#13;
        this.port.addEventListener("message", f);&#13;
     };&#13;
  &#13;
     PortStream.prototype.getId = function() {&#13;
        return this.id;&#13;
     };&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class StreamMultiplexer extends Stream&#13;
      *&#13;
      * A wrapper for multiplexed downstream communication with&#13;
      * multiple streams at once.  Mainly useful for the SharedWorker to&#13;
      * broadcast events to many PortStream objects at once.&#13;
      */&#13;
     var StreamMultiplexer = function(streams) {&#13;
        Stream.call(this);&#13;
        this.streamMap = streams ?&#13;
           connect.index(streams, function(s) { return s.getId(); }) : {};&#13;
        this.messageListeners = [];&#13;
     };&#13;
     StreamMultiplexer.prototype = Object.create(Stream.prototype);&#13;
     StreamMultiplexer.prototype.constructor = StreamMultiplexer;&#13;
  &#13;
     /**&#13;
      * Send a message to all ports in the multiplexer.&#13;
      */&#13;
     StreamMultiplexer.prototype.send = function(message) {&#13;
        this.getStreams().forEach(function(stream) {&#13;
           try {&#13;
              stream.send(message);&#13;
  &#13;
           } catch (e) {&#13;
              // Couldn't send message to one of the downstreams for some reason...&#13;
              // No reliable logging possible without further failures,&#13;
              // no recovery, just eat it.&#13;
           }&#13;
        });&#13;
     };&#13;
  &#13;
     /**&#13;
      * Register a method which will be called when a message is received from&#13;
      * any of the downstreams.&#13;
      */&#13;
     StreamMultiplexer.prototype.onMessage = function(f) {&#13;
        this.messageListeners.push(f);&#13;
  &#13;
        // Update existing streams with the new listener.&#13;
        this.getStreams().forEach(function(stream) {&#13;
           stream.onMessage(f);&#13;
        });&#13;
     };&#13;
  &#13;
     /**&#13;
      * Add a stream to the multiplexer.&#13;
      */&#13;
     StreamMultiplexer.prototype.addStream = function(stream) {&#13;
        var self = this;&#13;
        this.streamMap[stream.getId()] = stream;&#13;
  &#13;
        // Update stream with existing listeners.&#13;
        this.messageListeners.forEach(function(messageListener) {&#13;
           stream.onMessage(messageListener);&#13;
        });&#13;
     };&#13;
  &#13;
     /**&#13;
      * Remove the given downstream.  This is typically used in response&#13;
      * to the SharedWorker's onclose event, indicating that a consumer&#13;
      * tab has been closed.&#13;
      */&#13;
     StreamMultiplexer.prototype.removeStream = function(stream) {&#13;
        delete this.streamMap[stream.getId()];&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get a list of streams in the multiplexer.&#13;
      */&#13;
     StreamMultiplexer.prototype.getStreams = function(stream) {&#13;
        return connect.values(this.streamMap);&#13;
     };&#13;
  &#13;
     /**&#13;
      * Get the stream matching the given port.&#13;
      */&#13;
     StreamMultiplexer.prototype.getStreamForPort = function(port) {&#13;
        return connect.find(this.getStreams(), function(s) {&#13;
           return s.port === port;&#13;
        });&#13;
     };&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class Conduit&#13;
      *&#13;
      * An object which bridges an upstream and a downstream, allowing messages&#13;
      * to be passed to and from each and providing an event bus for event&#13;
      * subscriptions to be made upstream and downstream.&#13;
      */&#13;
     var Conduit = function(name, upstream, downstream) {&#13;
        this.name = name;&#13;
        this.upstream = upstream || new NullStream();&#13;
        this.downstream = downstream || new NullStream();&#13;
        this.downstreamBus = new connect.EventBus();&#13;
        this.upstreamBus = new connect.EventBus();&#13;
  &#13;
        this.upstream.onMessage(connect.hitch(this, this._dispatchEvent, this.upstreamBus));&#13;
        this.downstream.onMessage(connect.hitch(this, this._dispatchEvent, this.downstreamBus));&#13;
     };&#13;
  &#13;
     Conduit.prototype.onUpstream = function(eventName, f) {&#13;
        connect.assertNotNull(eventName, 'eventName');&#13;
        connect.assertNotNull(f, 'f');&#13;
        connect.assertTrue(connect.isFunction(f), 'f must be a function');&#13;
        return this.upstreamBus.subscribe(eventName, f);&#13;
     };&#13;
  &#13;
     Conduit.prototype.onAllUpstream = function(f) {&#13;
        connect.assertNotNull(f, 'f');&#13;
        connect.assertTrue(connect.isFunction(f), 'f must be a function');&#13;
        return this.upstreamBus.subscribeAll(f);&#13;
     };&#13;
  &#13;
     Conduit.prototype.onDownstream = function(eventName, f) {&#13;
        connect.assertNotNull(eventName, 'eventName');&#13;
        connect.assertNotNull(f, 'f');&#13;
        connect.assertTrue(connect.isFunction(f), 'f must be a function');&#13;
        return this.downstreamBus.subscribe(eventName, f);&#13;
     };&#13;
  &#13;
     Conduit.prototype.onAllDownstream = function(f) {&#13;
        connect.assertNotNull(f, 'f');&#13;
        connect.assertTrue(connect.isFunction(f), 'f must be a function');&#13;
        return this.downstreamBus.subscribeAll(f);&#13;
     };&#13;
  &#13;
     Conduit.prototype.sendUpstream = function(eventName, data) {&#13;
        connect.assertNotNull(eventName, 'eventName');&#13;
        this.upstream.send({event: eventName, data: data});&#13;
     };&#13;
  &#13;
     Conduit.prototype.sendDownstream = function(eventName, data) {&#13;
        connect.assertNotNull(eventName, 'eventName');&#13;
        this.downstream.send({event: eventName, data: data});&#13;
     };&#13;
  &#13;
     Conduit.prototype._dispatchEvent = function(bus, messageEvent) {&#13;
        var message = messageEvent.data;&#13;
        if (message.event) {&#13;
           bus.trigger(message.event, message.data);&#13;
        }&#13;
     };&#13;
  &#13;
     /**&#13;
      * Returns a closure which passes events upstream.&#13;
      *&#13;
      * Usage:&#13;
      * conduit.onDownstream("MyEvent", conduit.passUpstream());&#13;
      */&#13;
     Conduit.prototype.passUpstream = function() {&#13;
        var self = this;&#13;
        return function(data, eventName) {&#13;
           self.upstream.send({event: eventName, data: data});&#13;
        };&#13;
     };&#13;
  &#13;
     /**&#13;
      * Returns a closure which passes events downstream.&#13;
      *&#13;
      * Usage:&#13;
      * conduit.onUpstream("MyEvent", conduit.passDownstream());&#13;
      */&#13;
     Conduit.prototype.passDownstream = function() {&#13;
        var self = this;&#13;
        return function(data, eventName) {&#13;
           self.downstream.send({event: eventName, data: data});&#13;
        };&#13;
     };&#13;
  &#13;
     /**&#13;
      * Shutdown the conduit's event busses and remove all subscriptions.&#13;
      */&#13;
     Conduit.prototype.shutdown = function() {&#13;
        this.upstreamBus.unsubscribeAll();&#13;
        this.downstreamBus.unsubscribeAll();&#13;
     };&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class IFrameConduit extends Conduit&#13;
      *&#13;
      * Creates a conduit for the given IFrame element.&#13;
      */&#13;
     var IFrameConduit = function(name, window, iframe, domain) {&#13;
        Conduit.call(this, name, new WindowIOStream(window, iframe.contentWindow, domain || '*'), null);&#13;
     };&#13;
     IFrameConduit.prototype = Object.create(Conduit.prototype);&#13;
     IFrameConduit.prototype.constructor = IFrameConduit;&#13;
  &#13;
     connect.Stream = Stream;&#13;
     connect.NullStream = NullStream;&#13;
     connect.WindowStream = WindowStream;&#13;
     connect.WindowIOStream = WindowIOStream;&#13;
     connect.PortStream = PortStream;&#13;
     connect.StreamMultiplexer = StreamMultiplexer;&#13;
     connect.Conduit = Conduit;&#13;
     connect.IFrameConduit = IFrameConduit;&#13;
  })();&#13;
  /*&#13;
   * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.&#13;
   *&#13;
   * Licensed under the Amazon Software License (the "License"). You may not use&#13;
   * this file except in compliance with the License. A copy of the License is&#13;
   * located at&#13;
   *&#13;
   *    http://aws.amazon.com/asl/&#13;
   *&#13;
   * or in the "license" file accompanying this file. This file is distributed&#13;
   * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express&#13;
   * or implied. See the License for the specific language governing permissions&#13;
   * and limitations under the License.&#13;
   */&#13;
  (function() {&#13;
     var global = this;&#13;
     connect = global.connect || {};&#13;
     global.connect = connect;&#13;
     global.lily = connect;&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * enum ClientMethods&#13;
      */&#13;
     connect.ClientMethods = connect.makeEnum([&#13;
           'getAgentSnapshot',&#13;
           'putAgentState',&#13;
           'getAgentStates',&#13;
           'getDialableCountryCodes',&#13;
           'getRoutingProfileQueues',&#13;
           'getAgentPermissions',&#13;
           'getAgentConfiguration',&#13;
           'updateAgentConfiguration',&#13;
           'acceptContact',&#13;
           'createOutboundContact',&#13;
           'destroyContact',&#13;
           'notifyContactIssue',&#13;
           'updateContactAttributes',&#13;
           'createAdditionalConnection',&#13;
           'destroyConnection',&#13;
           'holdConnection',&#13;
           'resumeConnection',&#13;
           'toggleActiveConnections',&#13;
           'conferenceConnections',&#13;
           'sendClientLogs',&#13;
           'sendDigits',&#13;
           'sendSoftphoneCallReport',&#13;
           'sendSoftphoneCallMetrics',&#13;
           'getEndpoints',&#13;
           'getNewAuthToken'&#13;
     ]);&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * enum MasterMethods&#13;
      */&#13;
     connect.MasterMethods = connect.makeEnum([&#13;
           'becomeMaster',&#13;
           'checkMaster'&#13;
     ]);&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * abstract class ClientBase&#13;
      */&#13;
     var ClientBase = function() {};&#13;
     ClientBase.EMPTY_CALLBACKS = {&#13;
        success: function() { },&#13;
        failure: function() { }&#13;
     };&#13;
  &#13;
     ClientBase.prototype.call = function(method, paramsIn, callbacksIn) {&#13;
        connect.assertNotNull(method, 'method');&#13;
        var params = paramsIn || {};&#13;
        var callbacks = callbacksIn || ClientBase.EMPTY_CALLBACKS;&#13;
        this._callImpl(method, params, callbacks);&#13;
     };&#13;
  &#13;
     ClientBase.prototype._callImpl = function(method, params, callbacks) {&#13;
        throw new connect.NotImplementedError();&#13;
     };&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class NullClient extends ClientBase&#13;
      */&#13;
     var NullClient = function() {&#13;
        ClientBase.call(this);&#13;
     };&#13;
     NullClient.prototype = Object.create(ClientBase.prototype);&#13;
     NullClient.prototype.constructor = NullClient;&#13;
  &#13;
     NullClient.prototype._callImpl = function(method, params, callbacks) {&#13;
        if (callbacks &amp;&amp; callbacks.failure) {&#13;
           var message = connect.sprintf('No such method exists on NULL client: %s', method);&#13;
           callbacks.failure(new connect.ValueError(message), {message: message});&#13;
        }&#13;
     };&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * abstract class UpstreamConduitClientBase extends ClientBase&#13;
      */&#13;
     var UpstreamConduitClientBase = function(conduit, requestEvent, responseEvent) {&#13;
        ClientBase.call(this);&#13;
        this.conduit = conduit;&#13;
        this.requestEvent = requestEvent;&#13;
        this.responseEvent = responseEvent;&#13;
        this._requestIdCallbacksMap = {};&#13;
  &#13;
        this.conduit.onUpstream(responseEvent, connect.hitch(this, this._handleResponse));&#13;
     };&#13;
  &#13;
     UpstreamConduitClientBase.prototype = Object.create(ClientBase.prototype);&#13;
     UpstreamConduitClientBase.prototype.constructor = UpstreamConduitClientBase;&#13;
  &#13;
     UpstreamConduitClientBase.prototype._callImpl = function(method, params, callbacks) {&#13;
        var request = connect.EventFactory.createRequest(this.requestEvent, method, params);&#13;
        this._requestIdCallbacksMap[request.requestId] = callbacks;&#13;
        this.conduit.sendUpstream(request.event, request);&#13;
     };&#13;
  &#13;
     UpstreamConduitClientBase.prototype._getCallbacksForRequest = function(requestId) {&#13;
        var callbacks = this._requestIdCallbacksMap[requestId] || null;&#13;
  &#13;
        if (callbacks != null) {&#13;
           delete this._requestIdCallbacksMap[requestId];&#13;
        }&#13;
  &#13;
        return callbacks;&#13;
     };&#13;
  &#13;
     UpstreamConduitClientBase.prototype._handleResponse = function(data) {&#13;
        var callbacks = this._getCallbacksForRequest(data.requestId);&#13;
        if (callbacks == null) {&#13;
           return;&#13;
        }&#13;
  &#13;
        if (data.err &amp;&amp; callbacks.failure) {&#13;
           callbacks.failure(data.err, data.data);&#13;
  &#13;
        } else if (callbacks.success) {&#13;
           callbacks.success(data.data);&#13;
        }&#13;
     };&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class UpstreamConduitClient extends ClientBase&#13;
      */&#13;
     var UpstreamConduitClient = function(conduit) {&#13;
        UpstreamConduitClientBase.call(this, conduit, connect.EventType.API_REQUEST, connect.EventType.API_RESPONSE);&#13;
     };&#13;
     UpstreamConduitClient.prototype = Object.create(UpstreamConduitClientBase.prototype);&#13;
     UpstreamConduitClient.prototype.constructor = UpstreamConduitClient;&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class UpstreamConduitMasterClient extends ClientBase&#13;
      */&#13;
     var UpstreamConduitMasterClient = function(conduit) {&#13;
        UpstreamConduitClientBase.call(this, conduit, connect.EventType.MASTER_REQUEST, connect.EventType.MASTER_RESPONSE);&#13;
     };&#13;
     UpstreamConduitMasterClient.prototype = Object.create(UpstreamConduitClientBase.prototype);&#13;
     UpstreamConduitMasterClient.prototype.constructor = UpstreamConduitMasterClient;&#13;
  &#13;
     /**---------------------------------------------------------------&#13;
      * class AWSClient extends ClientBase&#13;
      */&#13;
     var AWSClient = function(authToken, region, endpointIn) {&#13;
        connect.assertNotNull(authToken, 'authToken');&#13;
        connect.assertNotNull(region, 'region');&#13;
        ClientBase.call(this);&#13;
        AWS.config.credentials = new AWS.Credentials({});&#13;
        AWS.config.region = region;&#13;
        this.authToken = authToken;&#13;
        var endpointUrl = endpointIn || connect.getBaseUrl() + '/connect/api';&#13;
        var endpoint = new AWS.Endpoint(endpointUrl);&#13;
        this.client = new AWS.Connect({endpoint: endpoint});&#13;
     };&#13;
     AWSClient.prototype = Object.create(ClientBase.prototype);&#13;
     AWSClient.prototype.constructor = AWSClient;&#13;
  &#13;
     AWSClient.prototype._callImpl = function(method, params, callbacks) {&#13;
        var self = this;&#13;
        var log = connect.getLog();&#13;
  &#13;
        params.authentication = {&#13;
           authToken: this.authToken&#13;
        };&#13;
  &#13;
        if (! connect.contains(this.client, method)) {&#13;
           var message = connect.sprintf('No such method exists on AWS client: %s', method);&#13;
           callbacks.failure(new connect.ValueError(message), {message: message});&#13;
  &#13;
        } else {&#13;
           params = this._translateParams(method, params);&#13;
  &#13;
           log.trace("AWSClient: --&gt; Calling operation '%s'", method);&#13;
  &#13;
           this.client[method](params)&#13;
              .on('build', function(request) {&#13;
                 request.httpRequest.headers['X-Amz-Bearer'] = self.authToken;&#13;
              })&#13;
              .send(function(err, data) {&#13;
                 try {&#13;
                    if (err) {&#13;
                       if (err.code === connect.CTIExceptions.UNAUTHORIZED_EXCEPTION) {&#13;
                          callbacks.authFailure();&#13;
                       } else {&#13;
                          // Can't pass err directly to postMessage&#13;
                          // postMessage() tries to clone the err object and failed.&#13;
                          // Refer to https://github.com/goatslacker/alt-devtool/issues/5&#13;
                          var error = {};&#13;
                          error.type = err.code;&#13;
                          error.message = err.message;&#13;
                          error.stack = err.stack ? err.stack.split('\n') : [];&#13;
                          callbacks.failure(error, data);&#13;
                       }&#13;
  &#13;
                       log.trace("AWSClient: &lt;-- Operation '%s' failed: %s", method, JSON.stringify(err));&#13;
  &#13;
                    } else {&#13;
                       log.trace("AWSClient: &lt;-- Operation '%s' succeeded.", method).withObject(data);&#13;
                       callbacks.success(data);&#13;
                    }&#13;
                 } catch (e) {&#13;
                    connect.getLog().error("Failed to handle AWS API request for method %s", method)&#13;
                          .withException(e);&#13;
                 }&#13;
              });&#13;
        }&#13;
     };&#13;
  &#13;
     AWSClient.prototype._translateParams = function(method, params) {&#13;
        switch (method) {&#13;
           case connect.ClientMethods.UPDATE_AGENT_CONFIGURATION:&#13;
              params.configuration = this._translateAgentConfiguration(params.configuration);&#13;
              break;&#13;
  &#13;
           case connect.ClientMethods.SEND_SOFTPHONE_CALL_METRICS:&#13;
              params.softphoneStreamStatistics = this._translateSoftphoneStreamStatistics(&#13;
                    params.softphoneStreamStatistics);&#13;
              break;&#13;
  &#13;
           case connect.ClientMethods.SEND_SOFTPHONE_CALL_REPORT:&#13;
              params.report = this._translateSoftphoneCallReport(params.report);&#13;
              break;&#13;
  &#13;
           default:&#13;
              break;&#13;
        }&#13;
  &#13;
        return params;&#13;
     };&#13;
  &#13;
     AWSClient.prototype._translateAgentConfiguration = function(config) {&#13;
        return {&#13;
           name: config.name,&#13;
           softphoneEnabled: config.softphoneEnabled,&#13;
           softphoneAutoAccept: config.softphoneAutoAccept,&#13;
           extension: config.extension,&#13;
           routingProfile: this._translateRoutingProfile(config.routingProfile),&#13;
           agentPreferences: config.agentPreferences&#13;
        };&#13;
     };&#13;
  &#13;
     AWSClient.prototype._translateRoutingProfile = function(profile) {&#13;
        return {&#13;
           name: profile.name,&#13;
           routingProfileARN: profile.routingProfileARN,&#13;
           defaultOutboundQueue: this._translateQueue(profile.defaultOutboundQueue)&#13;
        };&#13;
     };&#13;
  &#13;
     AWSClient.prototype._translateQueue = function(queue) {&#13;
        return {&#13;
           queueARN:   queue.queueARN,&#13;
           name:       queue.name&#13;
        };&#13;
     };&#13;
  &#13;
     AWSClient.prototype._translateSoftphoneStreamStatistics = function(stats) {&#13;
        stats.forEach(function(stat) {&#13;
           if ('packetsCount' in stat) {&#13;
              stat.packetCount = stat.packetsCount;&#13;
              delete stat.packetsCount;&#13;
           }&#13;
        });&#13;
  &#13;
        return stats;&#13;
     };&#13;
  &#13;
     AWSClient.prototype._translateSoftphoneCallReport = function(report) {&#13;
        if ('handshakingTimeMillis' in report) {&#13;
           report.handshakeTimeMillis = report.handshakingTimeMillis;&#13;
           delete report.handshakingTimeMillis;&#13;
        }&#13;
  &#13;
        if ('preTalkingTimeMillis' in report) {&#13;
           report.preTalkTimeMillis = report.preTalkingTimeMillis;&#13;
           delete report.preTalkingTimeMillis;&#13;
        }&#13;
  &#13;
        if ('handshakingFailure' in report) {&#13;
           report.handshakeFailure = report.handshakingFailure;&#13;
           delete report.handshakingFailure;&#13;
        }&#13;
  &#13;
        if ('talkingTimeMillis' in report) {&#13;
           report.talkTimeMillis = report.talkingTimeMillis;&#13;
           delete report.talkingTimeMillis;&#13;
        }&#13;
  &#13;
        report.softphoneStreamStatistics = this._translateSoftphoneStreamStatistics(&#13;
              report.softphoneStreamStatistics);&#13;
  &#13;
        return report;&#13;
     };&#13;
  &#13;
     connect.NullClient = NullClient;&#13;
     connect.UpstreamConduitClient = UpstreamConduitClient;&#13;
     connect.UpstreamConduitMasterClient = UpstreamConduitMasterClient;&#13;
     connect.AWSClient = AWSClient;&#13;
  &#13;
  })();&#13;
  /*&#13;
   * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.&#13;
   *&#13;
   * Licensed under the Amazon Software License (the "License"). You may not use&#13;
   * this file except in compliance with the License. A copy of the License is&#13;
   * located at&#13;
   *&#13;
   *    http://aws.amazon.com/asl/&#13;
   *&#13;
   * or in the "license" file accompanying this file. This file is distributed&#13;
   * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express&#13;
   * or implied. See the License for the specific language governing permissions&#13;
   * and limitations under the License.&#13;
   */&#13;
  (function() {&#13;
     var global = this;&#13;
     connect = global.connect || {};&#13;
     global.connect = connect;&#13;
     global.lily = connect;&#13;
  &#13;
     /**-------------------------------------------------------------------------&#13;
      * GraphLink &lt;&lt;abstract class&gt;&gt;&#13;
      *&#13;
      * Represents the association of one or more attributes to a state transition.&#13;
      */&#13;
     var GraphLink = function(fromState, toState) {&#13;
        connect.assertNotNull(fromState, 'fromState');&#13;
        connect.assertNotNull(toState, 'toState');&#13;
        this.fromState = fromState;&#13;
        this.toState = toState;&#13;
     };&#13;
  &#13;
     GraphLink.prototype.getAssociations = function(context) {&#13;
        throw connect.NotImplementedError();&#13;
     };&#13;
  &#13;
     GraphLink.prototype.getFromState = function() {&#13;
        return this.fromState;&#13;
     };&#13;
  &#13;
     GraphLink.prototype.getToState = function() {&#13;
        return this.toState;&#13;
     };&#13;
  &#13;
     /**-------------------------------------------------------------------------&#13;
      * DirectGraphLink &lt;&lt;concrete class&gt;&gt; extends GraphLink&#13;
      *&#13;
      * Represents the by-value representation of one or more attributes to a&#13;
      * state transition.&#13;
      */&#13;
     var DirectGraphLink = function(fromState, toState, associations) {&#13;
        connect.assertNotNull(fromState, 'fromState');&#13;
        connect.assertNotNull(toState, 'toState');&#13;
        connect.assertNotNull(associations, 'associations');&#13;
        GraphLink.call(this, fromState, toState);&#13;
        this.associations = associations;&#13;
     };&#13;
     DirectGraphLink.prototype = Object.create(GraphLink.prototype);&#13;
     DirectGraphLink.prototype.constructor = DirectGraphLink;&#13;
  &#13;
     DirectGraphLink.prototype.getAssociations = function(context) {&#13;
        return this.associations;&#13;
     };&#13;
  &#13;
     /**&#13;
      * FunctionalGraphLink &lt;&lt;concrete class&gt;&gt; extends GraphLink&#13;
      *&#13;
      * Represents a functional association of one or more attributes to a&#13;
      * state transition.&#13;
      */&#13;
     var FunctionalGraphLink = function(fromState, toState, closure) {&#13;
        connect.assertNotNull(fromState, 'fromState');&#13;
        connect.assertNotNull(toState, 'toState');&#13;
        connect.assertNotNull(closure, 'closure');&#13;
        connect.assertTrue(connect.isFunction(closure), 'closure must be a function');&#13;
        GraphLink.call(this, fromState, toState);&#13;
        this.closure = closure;&#13;
     };&#13;
     FunctionalGraphLink.prototype = Object.create(GraphLink.prototype);&#13;
     FunctionalGraphLink.prototype.constructor = FunctionalGraphLink;&#13;
  &#13;
     FunctionalGraphLink.prototype.getAssociations = function(context) {&#13;
        return this.closure(context, this.getFromState(), this.getToState());&#13;
     };&#13;
  &#13;
     /**-------------------------------------------------------------------------&#13;
      * EventGraph &lt;&lt;class&gt;&gt;&#13;
      *&#13;
      * Builds a map of associations from one state to another in context of a&#13;
      * particular object.  The associations can be direct (one or more values)&#13;
      * or functional (a method returning one or more values), and are used to&#13;
      * provide additional contextual event hooks for the UI to consume.&#13;
      */&#13;
     var EventGraph = function() {&#13;
        this.fromMap = {};&#13;
     };&#13;
     EventGraph.ANY = "&lt;&lt;any&gt;&gt;";&#13;
  &#13;
     EventGraph.prototype.assoc = function(fromStateObj, toStateObj, assocObj) {&#13;
        var self = this;&#13;
  &#13;
        if (! fromStateObj) {&#13;
           throw new Error("fromStateObj is not defined.");&#13;
        }&#13;
  &#13;
        if (! toStateObj) {&#13;
           throw new Error("toStateObj is not defined.");&#13;
        }&#13;
  &#13;
        if (! assocObj) {&#13;
           throw new Error("assocObj is not defined.");&#13;
        }&#13;
  &#13;
        if (fromStateObj instanceof Array) {&#13;
           fromStateObj.forEach(function(fromState) {&#13;
              self.assoc(fromState, toStateObj, assocObj);&#13;
           });&#13;
        } else if (toStateObj instanceof Array) {&#13;
           toStateObj.forEach(function(toState) {&#13;
              self.assoc(fromStateObj, toState, assocObj);&#13;
           });&#13;
        } else {&#13;
           if (typeof assocObj === "function") {&#13;
              this._addAssociation(new FunctionalGraphLink(fromStateObj, toStateObj, assocObj));&#13;
           } else if (assocObj instanceof Array) {&#13;
              this._addAssociation(new DirectGraphLink(fromStateObj, toStateObj, assocObj));&#13;
           } else {&#13;
              this._addAssociation(new DirectGraphLink(fromStateObj, toStateObj, [assocObj]));&#13;
           }&#13;
        }&#13;
        return this;&#13;
     };&#13;
  &#13;
     EventGraph.prototype.getAssociations = function(context, fromState, toState) {&#13;
        connect.assertNotNull(fromState, 'fromState');&#13;
        connect.assertNotNull(toState, 'toState');&#13;
        var associations = [];&#13;
  &#13;
        var toMapFromAny = this.fromMap[EventGraph.ANY] || {};&#13;
        var toMap = this.fromMap[fromState] || {};&#13;
  &#13;
        associations = associations.concat(this._getAssociationsFromMap(&#13;
                 toMapFromAny, context, fromState, toState));&#13;
        associations = associations.concat(this._getAssociationsFromMap(&#13;
                 toMap, context, fromState, toState));&#13;
  &#13;
        return associations;&#13;
     };&#13;
  &#13;
     EventGraph.prototype._addAssociation = function(assoc) {&#13;
        var toMap = this.fromMap[assoc.getFromState()];&#13;
  &#13;
        if (! toMap) {&#13;
           toMap = this.fromMap[assoc.getFromState()] = {};&#13;
        }&#13;
  &#13;
        var assocList = toMap[assoc.getToState()];&#13;
  &#13;
        if (! assocList) {&#13;
           assocList = toMap[assoc.getToState()] = [];&#13;
        }&#13;
  &#13;
        assocList.push(assoc);&#13;
     };&#13;
  &#13;
     EventGraph.prototype._getAssociationsFromMap = function(map, context, fromState, toState) {&#13;
        var assocList = (map[EventGraph.ANY] || []).concat(map[toState] || []);&#13;
        return assocList.reduce(function(prev, assoc) {&#13;
           return prev.concat(assoc.getAssociations(context));&#13;
        }, []);&#13;
     };&#13;
  &#13;
     connect.EventGraph = EventGraph;&#13;
  &#13;
  })();&#13;
  /*&#13;
   * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.&#13;
   *&#13;
   * Licensed under the Amazon Software License (the "License"). You may not use&#13;
   * this file except in compliance with the License. A copy of the License is&#13;
   * located at&#13;
   *&#13;
   *    http://aws.amazon.com/asl/&#13;
   *&#13;
   * or in the "license" file accompanying this file. This file is distributed&#13;
   * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express&#13;
   * or implied. See the License for the specific language governing permissions&#13;
   * and limitations under the License.&#13;
   */&#13;
  (function() {&#13;
     var global = this;&#13;
     connect = global.connect || {};&#13;
     global.connect = connect;&#13;
     global.lily = connect;&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * enum AgentStateType&#13;
      */&#13;
     connect.AgentStateType = connect.makeEnum([&#13;
           'init',&#13;
           'routable',&#13;
           'not_routable',&#13;
           'offline'&#13;
     ]);&#13;
     connect.AgentStatusType = connect.AgentStateType;&#13;
  &#13;
     /**&#13;
      * enum AgentAvailStates&#13;
      */&#13;
     connect.AgentAvailStates = connect.makeEnum([&#13;
           'Init',&#13;
           'Busy',&#13;
           'AfterCallWork',&#13;
           'CallingCustomer',&#13;
           'Dialing',&#13;
           'Joining',&#13;
           'PendingAvailable',&#13;
           'PendingBusy'&#13;
     ]);&#13;
  /*   connect.AgentAvailStates = connect.makeEnum([&#13;
      'Init',&#13;
      'Busy',&#13;
      'AfterCallWork',&#13;
      'Talking',&#13;
      'Dialing',&#13;
      'Joining',&#13;
      'PendingAvailable',&#13;
      'PendingBusy'&#13;
]);*/&#13;
     /**&#13;
      * enum AgentErrorStates&#13;
      */&#13;
     connect.AgentErrorStates = connect.makeEnum([&#13;
           'Error',&#13;
           'AgentHungUp',&#13;
           'BadAddressAgent',&#13;
           'BadAddressCustomer',&#13;
           'Default',&#13;
           'FailedConnectAgent',&#13;
           'FailedConnectCustomer',&#13;
           'LineEngagedAgent',&#13;
           'LineEngagedCustomer',&#13;
           'MissedCallAgent',&#13;
           'MissedCallCustomer',&#13;
           'MultipleCcpWindows',&#13;
           'RealtimeCommunicationError'&#13;
     ]);&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * enum AddressType&#13;
      */&#13;
     connect.EndpointType = connect.makeEnum([&#13;
           'phone_number',&#13;
           'agent',&#13;
           'queue'&#13;
     ]);&#13;
     connect.AddressType = connect.EndpointType;&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * enum ConnectionType&#13;
      */&#13;
     connect.ConnectionType = connect.makeEnum([&#13;
           'agent',&#13;
           'inbound',&#13;
           'outbound',&#13;
           'monitoring'&#13;
     ]);&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * enum ConnectionStateType&#13;
      */&#13;
     connect.ConnectionStateType = connect.makeEnum([&#13;
           'init',&#13;
           'connecting',&#13;
           'connected',&#13;
           'hold',&#13;
           'disconnected'&#13;
     ]);&#13;
     connect.ConnectionStatusType = connect.ConnectionStateType;&#13;
  &#13;
     connect.CONNECTION_ACTIVE_STATES = connect.set([&#13;
           connect.ConnectionStateType.CONNECTING,&#13;
           connect.ConnectionStateType.CONNECTED,&#13;
           connect.ConnectionStateType.HOLD&#13;
     ]);&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * enum ContactStateType&#13;
      */&#13;
     connect.ContactStateType = connect.makeEnum([&#13;
           'init',&#13;
           'incoming',&#13;
           'pending',&#13;
           'connecting',&#13;
           'connected',&#13;
           'missed',&#13;
           'error',&#13;
           'ended'&#13;
     ]);&#13;
     connect.ContactStatusType = connect.ContactStateType;&#13;
  &#13;
     connect.CONTACT_ACTIVE_STATES = connect.makeEnum([&#13;
           'incoming',&#13;
           'connecting',&#13;
           'connected'&#13;
     ]);&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * enum ContactType&#13;
      */&#13;
     connect.ContactType = connect.makeEnum([&#13;
           'voice',&#13;
           'queue_callback'&#13;
     ]);&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * enum SoftphoneCallType&#13;
      */&#13;
     connect.SoftphoneCallType = connect.makeEnum([&#13;
           'audio_video',&#13;
           'video_only',&#13;
           'audio_only',&#13;
           'none'&#13;
     ]);&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * enum for SoftphoneErrorTypes&#13;
      */&#13;
      connect.SoftphoneErrorTypes = connect.makeEnum([&#13;
          'unsupported_browser',&#13;
          'microphone_not_shared',&#13;
          'signalling_handshake_failure',&#13;
          'signalling_connection_failure',&#13;
          'ice_collection_timeout',&#13;
          'user_busy_error',&#13;
          'webrtc_error',&#13;
          'realtime_communication_error',&#13;
          'other'&#13;
     ]);&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * enum for CTI exceptions&#13;
      */&#13;
      connect.CTIExceptions = connect.makeEnum([&#13;
          "AccessDeniedException",&#13;
          "InvalidStateException",&#13;
          "BadEndpointException",&#13;
          "InvalidAgentARNException",&#13;
          "InvalidConfigurationException",&#13;
          "InvalidContactTypeException",&#13;
          "PaginationException",&#13;
          "RefreshTokenExpiredException",&#13;
          "SendDataFailedException",&#13;
          "UnauthorizedException"&#13;
      ]);&#13;
     /*----------------------------------------------------------------&#13;
      * class Agent&#13;
      */&#13;
     var Agent = function() {&#13;
        if (! connect.agent.initialized) {&#13;
           throw new connect.StateError("The agent is not yet initialized!");&#13;
        }&#13;
     };&#13;
  &#13;
     Agent.prototype._getData = function() {&#13;
        return connect.core.getAgentDataProvider().getAgentData();&#13;
     };&#13;
  &#13;
     Agent.prototype._createContactAPI = function(contactData) {&#13;
        return new connect.Contact(contactData.contactId);&#13;
     };&#13;
  &#13;
     Agent.prototype.onContactPending = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(connect.AgentEvents.CONTACT_PENDING, f);&#13;
     };&#13;
  &#13;
     Agent.prototype.onRefresh = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(connect.AgentEvents.REFRESH, f);&#13;
     };&#13;
  &#13;
     Agent.prototype.onRoutable = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(connect.AgentEvents.ROUTABLE, f);&#13;
     };&#13;
  &#13;
     Agent.prototype.onNotRoutable = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(connect.AgentEvents.NOT_ROUTABLE, f);&#13;
     };&#13;
  &#13;
     Agent.prototype.onOffline = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(connect.AgentEvents.OFFLINE, f);&#13;
     };&#13;
  &#13;
     Agent.prototype.onError = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(connect.AgentEvents.ERROR, f);&#13;
     };&#13;
  &#13;
     Agent.prototype.onSoftphoneError = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(connect.AgentEvents.SOFTPHONE_ERROR, f);&#13;
     };&#13;
  &#13;
     Agent.prototype.onAfterCallWork = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(connect.AgentEvents.ACW, f);&#13;
     };&#13;
  &#13;
     Agent.prototype.onStateChange = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(connect.AgentEvents.STATE_CHANGE, f);&#13;
     };&#13;
  &#13;
     Agent.prototype.getState = function() {&#13;
        return this._getData().snapshot.state;&#13;
     };&#13;
  &#13;
     Agent.prototype.getStatus = Agent.prototype.getState;&#13;
  &#13;
     Agent.prototype.getStateDuration = function() {&#13;
        return connect.now() - this._getData().snapshot.state.startTimestamp.getTime() + connect.core.getSkew();&#13;
     };&#13;
  &#13;
     Agent.prototype.getStatusDuration = Agent.prototype.getStateDuration;&#13;
  &#13;
     Agent.prototype.getPermissions = function() {&#13;
        return this.getConfiguration().permissions;&#13;
     };&#13;
  &#13;
     Agent.prototype.getContacts = function(contactTypeFilter) {&#13;
        var self = this;&#13;
        return this._getData().snapshot.contacts.map(function(contactData) {&#13;
           return self._createContactAPI(contactData);&#13;
        }).filter(function(contact) {&#13;
           return (! contactTypeFilter) || contact.getType() === contactTypeFilter;&#13;
        });&#13;
     };&#13;
  &#13;
     Agent.prototype.getConfiguration = function() {&#13;
        return this._getData().configuration;&#13;
     };&#13;
  &#13;
     Agent.prototype.getAgentStates = function() {&#13;
        return this.getConfiguration().agentStates;&#13;
     };&#13;
  &#13;
     Agent.prototype.getRoutingProfile = function() {&#13;
        return this.getConfiguration().routingProfile;&#13;
     };&#13;
  &#13;
     Agent.prototype.getName = function() {&#13;
        return this.getConfiguration().name;&#13;
     };&#13;
  &#13;
     Agent.prototype.getExtension = function() {&#13;
        return this.getConfiguration().extension;&#13;
     };&#13;
  &#13;
     Agent.prototype.getDialableCountries = function() {&#13;
        return this.getConfiguration().dialableCountries;&#13;
     };&#13;
  &#13;
     Agent.prototype.isSoftphoneEnabled = function() {&#13;
        return this.getConfiguration().softphoneEnabled;&#13;
     };&#13;
  &#13;
     Agent.prototype.setConfiguration = function(configuration, callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        client.call(connect.ClientMethods.UPDATE_AGENT_CONFIGURATION, {&#13;
           configuration: connect.assertNotNull(configuration, 'configuration')&#13;
        }, {&#13;
           success: function(data) {&#13;
              // We need to ask the shared worker to reload agent config&#13;
              // once we change it so every tab has accurate config.&#13;
              var conduit = connect.core.getUpstream();&#13;
              conduit.sendUpstream(connect.EventType.RELOAD_AGENT_CONFIGURATION);&#13;
  &#13;
              if (callbacks.success) {&#13;
                 callbacks.success(data);&#13;
              }&#13;
           },&#13;
           failure: callbacks.failure&#13;
        });&#13;
     };&#13;
  &#13;
     Agent.prototype.setState = function(state, callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        client.call(connect.ClientMethods.PUT_AGENT_STATE, {&#13;
           state: connect.assertNotNull(state, 'state')&#13;
        }, callbacks);&#13;
     };&#13;
  &#13;
     Agent.prototype.setStatus = Agent.prototype.setState;&#13;
  &#13;
     Agent.prototype.connect = function(endpointIn, params) {&#13;
        var client = connect.core.getClient();&#13;
        var endpoint = new connect.Endpoint(endpointIn);&#13;
        // Have to remove the endpointId field or AWS JS SDK gets mad.&#13;
        delete endpoint.endpointId;&#13;
  &#13;
        client.call(connect.ClientMethods.CREATE_OUTBOUND_CONTACT, {&#13;
           endpoint:    connect.assertNotNull(endpoint, 'endpoint'),&#13;
           queueARN:   params.queueARN || params.queueId || this.getRoutingProfile().defaultOutboundQueue.queueARN&#13;
        }, {&#13;
           success: params.success,&#13;
           failure: params.failure&#13;
        });&#13;
     };&#13;
  &#13;
     Agent.prototype.getAllQueueARNs = function() {&#13;
        return this.getConfiguration().routingProfile.queues.map(function(queue) {&#13;
           return queue.queueARN;&#13;
        });&#13;
     };&#13;
  &#13;
     Agent.prototype.getEndpoints = function(queueARNs, callbacks, pageInfoIn) {&#13;
        var self = this;&#13;
        var client = connect.core.getClient();&#13;
        var pageInfo = pageInfoIn || {endpoints: []};&#13;
  &#13;
        pageInfo.maxResults = pageInfo.maxResults || connect.DEFAULT_BATCH_SIZE;&#13;
  &#13;
        // Backwards compatibility allowing a single queueARN to be specified&#13;
        // instead of an array.&#13;
        if (! connect.isArray(queueARNs)) {&#13;
           queueARNs = [queueARNs];&#13;
        }&#13;
  &#13;
        client.call(connect.ClientMethods.GET_ENDPOINTS, {&#13;
           queueARNs:   queueARNs,&#13;
           nextToken:   pageInfo.nextToken || null,&#13;
           maxResults:  pageInfo.maxResults&#13;
        }, {&#13;
           success: function(data) {&#13;
              if (data.nextToken) {&#13;
                 self.getEndpoints(queueARNs, callbacks, {&#13;
                    nextToken:  data.nextToken,&#13;
                    maxResults: pageInfo.maxResults,&#13;
                    endpoints:  pageInfo.endpoints.concat(data.endpoints)&#13;
                 });&#13;
              } else {&#13;
                 pageInfo.endpoints = pageInfo.endpoints.concat(data.endpoints);&#13;
                 var endpoints = pageInfo.endpoints.map(function(endpoint) {&#13;
                       return new connect.Endpoint(endpoint);&#13;
                 });&#13;
  &#13;
                 callbacks.success({&#13;
                    endpoints: endpoints,&#13;
                    addresses: endpoints&#13;
                 });&#13;
              }&#13;
           },&#13;
           failure: callbacks.failure&#13;
        });&#13;
     };&#13;
  &#13;
     Agent.prototype.getAddresses = Agent.prototype.getEndpoints;&#13;
  &#13;
     Agent.prototype.toSnapshot = function() {&#13;
        return new connect.AgentSnapshot(this._getData());&#13;
     };&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * class AgentSnapshot&#13;
      */&#13;
     var AgentSnapshot = function(agentData) {&#13;
        connect.Agent.call(this);&#13;
        this.agentData = agentData;&#13;
     };&#13;
     AgentSnapshot.prototype = Object.create(Agent.prototype);&#13;
     AgentSnapshot.prototype.constructor = AgentSnapshot;&#13;
  &#13;
     AgentSnapshot.prototype._getData = function() {&#13;
        return this.agentData;&#13;
     };&#13;
  &#13;
     AgentSnapshot.prototype._createContactAPI = function(contactData) {&#13;
        return new connect.ContactSnapshot(contactData);&#13;
     };&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * class Contact&#13;
      */&#13;
     var Contact = function(contactId) {&#13;
        this.contactId = contactId;&#13;
     };&#13;
  &#13;
     Contact.prototype._getData = function() {&#13;
        return connect.core.getAgentDataProvider().getContactData(this.getContactId());&#13;
     };&#13;
  &#13;
     Contact.prototype._createConnectionAPI = function(connectionData) {&#13;
        return new connect.Connection(this.contactId, connectionData.connectionId);&#13;
     };&#13;
  &#13;
     Contact.prototype.getEventName = function(eventName) {&#13;
        return connect.core.getContactEventName(eventName, this.getContactId());&#13;
     };&#13;
  &#13;
     Contact.prototype.onRefresh = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(this.getEventName(connect.ContactEvents.REFRESH), f);&#13;
     };&#13;
  &#13;
     Contact.prototype.onIncoming = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(this.getEventName(connect.ContactEvents.INCOMING), f);&#13;
     };&#13;
  &#13;
     Contact.prototype.onConnecting = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(this.getEventName(connect.ContactEvents.CONNECTING), f);&#13;
     };&#13;
  &#13;
     Contact.prototype.onPending = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(this.getEventName(connect.ContactEvents.PENDING), f);&#13;
     };&#13;
  &#13;
     Contact.prototype.onAccepted = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(this.getEventName(connect.ContactEvents.ACCEPTED), f);&#13;
     };&#13;
  &#13;
     Contact.prototype.onMissed = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(this.getEventName(connect.ContactEvents.MISSED), f);&#13;
     };&#13;
  &#13;
     Contact.prototype.onEnded = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(this.getEventName(connect.ContactEvents.ENDED), f);&#13;
        bus.subscribe(this.getEventName(connect.ContactEvents.DESTROYED), f);&#13;
     };&#13;
  &#13;
     Contact.prototype.onACW = function(f) {&#13;
       var bus = connect.core.getEventBus();&#13;
       bus.subscribe(this.getEventName(connect.ContactEvents.ACW), f);&#13;
     };&#13;
  &#13;
     Contact.prototype.onConnected = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(this.getEventName(connect.ContactEvents.CONNECTED), f);&#13;
     };&#13;
  &#13;
     Contact.prototype.getContactId = function() {&#13;
        return this.contactId;&#13;
     };&#13;
  &#13;
     Contact.prototype.getOriginalContactId = function() {&#13;
        return this._getData().initialContactId;&#13;
     };&#13;
  &#13;
     Contact.prototype.getType = function() {&#13;
        return this._getData().type;&#13;
     };&#13;
  &#13;
     Contact.prototype.getStatus = function() {&#13;
        return this._getData().state;&#13;
     };&#13;
  &#13;
     Contact.prototype.getStatusDuration = function() {&#13;
        return connect.now() - this._getData().state.timestamp.getTime() + connect.core.getSkew();&#13;
     };&#13;
  &#13;
     Contact.prototype.getQueue = function() {&#13;
        return this._getData().queue;&#13;
     };&#13;
  &#13;
     Contact.prototype.getQueueTimestamp = function() {&#13;
        return this._getData().queueTimestamp;&#13;
     };&#13;
  &#13;
     Contact.prototype.getConnections = function() {&#13;
        var self = this;&#13;
        return this._getData().connections.map(function(connData) {&#13;
           return new connect.Connection(self.contactId, connData.connectionId);&#13;
        });&#13;
     };&#13;
  &#13;
     Contact.prototype.getInitialConnection = function() {&#13;
        return connect.find(this.getConnections(), function(conn) {&#13;
           return conn.isInitialConnection();&#13;
        }) || null;&#13;
     };&#13;
  &#13;
     Contact.prototype.getActiveInitialConnection = function() {&#13;
        var initialConn = this.getInitialConnection();&#13;
        if (initialConn != null &amp;&amp; initialConn.isActive()) {&#13;
           return initialConn;&#13;
        } else {&#13;
           return null;&#13;
        }&#13;
     };&#13;
  &#13;
     Contact.prototype.getThirdPartyConnections = function() {&#13;
        return this.getConnections().filter(function(conn) {&#13;
           return ! conn.isInitialConnection() &amp;&amp; conn.getType() !== connect.ConnectionType.AGENT;&#13;
        });&#13;
     };&#13;
  &#13;
     Contact.prototype.getSingleActiveThirdPartyConnection = function() {&#13;
        return this.getThirdPartyConnections().filter(function(conn) {&#13;
           return conn.isActive();&#13;
        })[0] || null;&#13;
     };&#13;
  &#13;
     Contact.prototype.getAgentConnection = function() {&#13;
        return connect.find(this.getConnections(), function(conn) {&#13;
           var connType =  conn.getType();&#13;
           return connType === connect.ConnectionType.AGENT || connType === connect.ConnectionType.MONITORING;&#13;
        });&#13;
     };&#13;
  &#13;
     Contact.prototype.getAttributes = function() {&#13;
        return this._getData().attributes;&#13;
     };&#13;
  &#13;
     Contact.prototype.isSoftphoneCall = function() {&#13;
        return connect.find(this.getConnections(), function(conn) {&#13;
           return conn.getSoftphoneMediaInfo() != null;&#13;
        }) != null;&#13;
     };&#13;
  &#13;
     Contact.prototype.isInbound = function() {&#13;
        var conn = this.getInitialConnection();&#13;
        return conn ? conn.getType() === connect.ConnectionType.INBOUND : false;&#13;
     };&#13;
  &#13;
     Contact.prototype.isConnected = function() {&#13;
        return this.getStatus().type === connect.ContactStateType.CONNECTED;&#13;
     };&#13;
  &#13;
     Contact.prototype.accept = function(callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        var self = this;&#13;
        client.call(connect.ClientMethods.ACCEPT_CONTACT, {&#13;
           contactId:  this.getContactId()&#13;
        }, {&#13;
           success: function(data) {&#13;
              var conduit = connect.core.getUpstream();&#13;
              conduit.sendUpstream(connect.EventType.BROADCAST, {&#13;
                 event: connect.ContactEvents.ACCEPTED&#13;
              });&#13;
              conduit.sendUpstream(connect.EventType.BROADCAST, {&#13;
                 event: connect.core.getContactEventName(connect.ContactEvents.ACCEPTED,&#13;
                    self.getContactId())&#13;
              });&#13;
  &#13;
              if (callbacks &amp;&amp; callbacks.success) {&#13;
                 callbacks.success(data);&#13;
              }&#13;
           },&#13;
           failure: callbacks ? callbacks.failure : null&#13;
        });&#13;
     };&#13;
  &#13;
     Contact.prototype.destroy = function(callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        client.call(connect.ClientMethods.DESTROY_CONTACT, {&#13;
           contactId:  this.getContactId()&#13;
        }, callbacks);&#13;
     };&#13;
  &#13;
     Contact.prototype.notifyIssue = function(issueCode, description, callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        client.call(connect.ClientMethods.NOTIFY_CONTACT_ISSUE, {&#13;
           contactId:     this.getContactId(),&#13;
           issueCode:     issueCode,&#13;
           description:   description&#13;
        }, callbacks);&#13;
     };&#13;
  &#13;
     Contact.prototype.addConnection = function(endpointIn, callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        var endpoint = new connect.Endpoint(endpointIn);&#13;
        // Have to remove the endpointId field or AWS JS SDK gets mad.&#13;
        delete endpoint.endpointId;&#13;
  &#13;
        client.call(connect.ClientMethods.CREATE_ADDITIONAL_CONNECTION, {&#13;
           contactId:     this.getContactId(),&#13;
           endpoint:      endpoint&#13;
        }, callbacks);&#13;
     };&#13;
  &#13;
     Contact.prototype.toggleActiveConnections = function(callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        var connectionId = null;&#13;
        var holdingConn = connect.find(this.getConnections(), function(conn) {&#13;
           return conn.getStatus().type === connect.ConnectionStateType.HOLD;&#13;
        });&#13;
  &#13;
        if (holdingConn != null) {&#13;
           connectionId = holdingConn.getConnectionId();&#13;
  &#13;
        } else {&#13;
           var activeConns = this.getConnections().filter(function(conn) {&#13;
              return conn.isActive();&#13;
           });&#13;
           if (activeConns.length &gt; 0) {&#13;
              connectionId = activeConns[0].getConnectionId();&#13;
           }&#13;
        }&#13;
  &#13;
        client.call(connect.ClientMethods.TOGGLE_ACTIVE_CONNECTIONS, {&#13;
           contactId:     this.getContactId(),&#13;
           connectionId:  connectionId&#13;
        }, callbacks);&#13;
     };&#13;
  &#13;
     Contact.prototype.sendSoftphoneMetrics = function(softphoneStreamStatistics, callbacks) {&#13;
        var client = connect.core.getClient();&#13;
  &#13;
        client.call(connect.ClientMethods.SEND_SOFTPHONE_CALL_METRICS, {&#13;
           contactId:     this.getContactId(),&#13;
           softphoneStreamStatistics:  softphoneStreamStatistics&#13;
        }, callbacks);&#13;
     };&#13;
  &#13;
     Contact.prototype.sendSoftphoneReport = function(report, callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        client.call(connect.ClientMethods.SEND_SOFTPHONE_CALL_REPORT, {&#13;
           contactId:     this.getContactId(),&#13;
           report:  report&#13;
        }, callbacks);&#13;
     };&#13;
  &#13;
     Contact.prototype.conferenceConnections = function(callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        client.call(connect.ClientMethods.CONFERENCE_CONNECTIONS, {&#13;
           contactId:     this.getContactId()&#13;
        }, callbacks);&#13;
     };&#13;
  &#13;
     Contact.prototype.toSnapshot = function() {&#13;
        return new connect.ContactSnapshot(this._getData());&#13;
     };&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * class ContactSnapshot&#13;
      */&#13;
     var ContactSnapshot = function(contactData) {&#13;
        connect.Contact.call(this, contactData.contactId);&#13;
        this.contactData = contactData;&#13;
     };&#13;
     ContactSnapshot.prototype = Object.create(Contact.prototype);&#13;
     ContactSnapshot.prototype.constructor = ContactSnapshot;&#13;
  &#13;
     ContactSnapshot.prototype._getData = function() {&#13;
        return this.contactData;&#13;
     };&#13;
  &#13;
     ContactSnapshot.prototype._createConnectionAPI = function(connectionData) {&#13;
        return new connect.ConnectionSnapshot(connectionData);&#13;
     };&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * class Connection&#13;
      */&#13;
     var Connection = function(contactId, connectionId) {&#13;
        this.contactId = contactId;&#13;
        this.connectionId = connectionId;&#13;
     };&#13;
  &#13;
     Connection.prototype._getData = function() {&#13;
        return connect.core.getAgentDataProvider().getConnectionData(&#13;
              this.getContactId(), this.getConnectionId());&#13;
     };&#13;
  &#13;
     Connection.prototype.getContactId = function() {&#13;
        return this.contactId;&#13;
     };&#13;
  &#13;
     Connection.prototype.getConnectionId = function() {&#13;
        return this.connectionId;&#13;
     };&#13;
  &#13;
     Connection.prototype.getEndpoint = function() {&#13;
        return new connect.Endpoint(this._getData().endpoint);&#13;
     };&#13;
  &#13;
     Connection.prototype.getAddress = Connection.prototype.getEndpoint;&#13;
  &#13;
     Connection.prototype.getStatus = function() {&#13;
        return this._getData().state;&#13;
     };&#13;
  &#13;
     Connection.prototype.getStatusDuration = function() {&#13;
        return connect.now() - this._getData().state.timestamp.getTime() + connect.core.getSkew();&#13;
     };&#13;
  &#13;
     Connection.prototype.getType = function() {&#13;
        return this._getData().type;&#13;
     };&#13;
  &#13;
     Connection.prototype.isInitialConnection = function() {&#13;
        return this._getData().initial;&#13;
     };&#13;
  &#13;
     Connection.prototype.isActive = function() {&#13;
        return connect.contains(connect.CONNECTION_ACTIVE_STATES, this.getStatus().type);&#13;
     };&#13;
  &#13;
     Connection.prototype.isConnected = function() {&#13;
        return this.getStatus().type === connect.ConnectionStateType.CONNECTED;&#13;
     };&#13;
  &#13;
     Connection.prototype.isConnecting = function() {&#13;
        return this.getStatus().type === connect.ConnectionStateType.CONNECTING;&#13;
     };&#13;
  &#13;
     Connection.prototype.isOnHold = function() {&#13;
        return this.getStatus().type === connect.ConnectionStateType.HOLD;&#13;
     };&#13;
  &#13;
     Connection.prototype.getSoftphoneMediaInfo = function() {&#13;
        return this._getData().softphoneMediaInfo;&#13;
     };&#13;
  &#13;
     Connection.prototype.destroy = function(callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        client.call(connect.ClientMethods.DESTROY_CONNECTION, {&#13;
           contactId:     this.getContactId(),&#13;
           connectionId:  this.getConnectionId()&#13;
        }, callbacks);&#13;
     };&#13;
  &#13;
     Connection.prototype.sendDigits = function(digits, callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        client.call(connect.ClientMethods.SEND_DIGITS, {&#13;
           contactId:     this.getContactId(),&#13;
           connectionId:  this.getConnectionId(),&#13;
           digits:        digits&#13;
        }, callbacks);&#13;
     };&#13;
  &#13;
     Connection.prototype.hold = function(callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        client.call(connect.ClientMethods.HOLD_CONNECTION, {&#13;
           contactId:     this.getContactId(),&#13;
           connectionId:  this.getConnectionId()&#13;
        }, callbacks);&#13;
     };&#13;
  &#13;
     Connection.prototype.resume = function(callbacks) {&#13;
        var client = connect.core.getClient();&#13;
        client.call(connect.ClientMethods.RESUME_CONNECTION, {&#13;
           contactId:     this.getContactId(),&#13;
           connectionId:  this.getConnectionId()&#13;
        }, callbacks);&#13;
     };&#13;
  &#13;
     Connection.prototype.toSnapshot = function() {&#13;
        return new connect.ConnectionSnapshot(this._getData());&#13;
     };&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * class ConnectionSnapshot&#13;
      */&#13;
     var ConnectionSnapshot = function(connectionData) {&#13;
        connect.Connection.call(this, connectionData.contactId, connectionData.connectionId);&#13;
        this.connectionData = connectionData;&#13;
     };&#13;
     ConnectionSnapshot.prototype = Object.create(Connection.prototype);&#13;
     ConnectionSnapshot.prototype.constructor = ConnectionSnapshot;&#13;
  &#13;
     ConnectionSnapshot.prototype._getData = function() {&#13;
        return this.connectionData;&#13;
     };&#13;
  &#13;
     var Endpoint = function(paramsIn) {&#13;
        var params = paramsIn || {};&#13;
        this.endpointARN = params.endpointId || params.endpointARN || null;&#13;
        this.endpointId = this.endpointARN;&#13;
        this.type = params.type || null;&#13;
        this.name = params.name || null;&#13;
        this.phoneNumber = params.phoneNumber || null;&#13;
        this.agentLogin = params.agentLogin || null;&#13;
        this.queue = params.queue || null;&#13;
     };&#13;
  &#13;
     /**&#13;
      * Strip the SIP endpoint components from the phoneNumber field.&#13;
      */&#13;
     Endpoint.prototype.stripPhoneNumber = function() {&#13;
        return this.phoneNumber ? this.phoneNumber.replace(/sip:([^@]*)@.*/, "$1") : "";&#13;
     };&#13;
  &#13;
     /**&#13;
      * Create an Endpoint object from the given phone number and name.&#13;
      */&#13;
     Endpoint.byPhoneNumber = function(number, name) {&#13;
        return new Endpoint({&#13;
           type:          connect.EndpointType.PHONE_NUMBER,&#13;
           phoneNumber:   number,&#13;
           name:          name || null&#13;
        });&#13;
     };&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * class SoftphoneError&#13;
      */&#13;
     var SoftphoneError =  function(errorType, errorMessage, endPointUrl) {&#13;
          this.errorType = errorType;&#13;
          this.errorMessage = errorMessage;&#13;
          this.endPointUrl = endPointUrl;&#13;
     };&#13;
     SoftphoneError.prototype.getErrorType =  function() {&#13;
          return this.errorType;&#13;
     };&#13;
     SoftphoneError.prototype.getErrorMessage =  function() {&#13;
          return this.errorMessage;&#13;
     };&#13;
     SoftphoneError.prototype.getEndPointUrl =  function() {&#13;
          return this.endPointUrl;&#13;
     };&#13;
  &#13;
     /*----------------------------------------------------------------&#13;
      * Root Subscription APIs.&#13;
      */&#13;
     connect.agent = function(f) {&#13;
        if (connect.agent.initialized) {&#13;
           f(new connect.Agent());&#13;
  &#13;
        } else {&#13;
           var bus = connect.core.getEventBus();&#13;
           bus.subscribe(connect.AgentEvents.INIT, f);&#13;
        }&#13;
     };&#13;
     connect.agent.initialized = false;&#13;
  &#13;
     connect.contact = function(f) {&#13;
        var bus = connect.core.getEventBus();&#13;
        bus.subscribe(connect.ContactEvents.INIT, f);&#13;
     };&#13;
  &#13;
     /**&#13;
      * Execute the given function asynchronously only if the shared worker&#13;
      * says we are the master for the given topic.  If there is no master for&#13;
      * the given topic, we become the master and execute the function.&#13;
      *&#13;
      * @param topic The master topic we are concerned about.&#13;
      * @param f_true The callback to be invoked if we are the master.&#13;
      * @param f_else [optional] A callback to be invoked if we are not the master.&#13;
      */&#13;
     connect.ifMaster = function(topic, f_true, f_else) {&#13;
        connect.assertNotNull(topic, "A topic must be provided.");&#13;
        connect.assertNotNull(f_true, "A true callback must be provided.");&#13;
  &#13;
        if (! connect.core.masterClient) {&#13;
           // We can't be the master because there is no master client!&#13;
           connect.getLog().warn("We can't be the master for topic '%s' because there is no master client!", topic);&#13;
           if (f_else) {&#13;
              f_else();&#13;
           }&#13;
           return;&#13;
        }&#13;
  &#13;
        var masterClient = connect.core.getMasterClient();&#13;
        masterClient.call(connect.MasterMethods.CHECK_MASTER, {&#13;
           topic: topic&#13;
        }, {&#13;
           success: function(data) {&#13;
              if (data.isMaster) {&#13;
                 f_true();&#13;
  &#13;
              } else if (f_else) {&#13;
                 f_else();&#13;
              }&#13;
           }&#13;
        });&#13;
     };&#13;
  &#13;
     /**&#13;
      * Notify the shared worker that we are now the master for the given topic.&#13;
      */&#13;
     connect.becomeMaster = function(topic) {&#13;
        connect.assertNotNull(topic, "A topic must be provided.");&#13;
        var masterClient = connect.core.getMasterClient();&#13;
        masterClient.call(connect.MasterMethods.BECOME_MASTER, {&#13;
           topic: topic&#13;
        });&#13;
     };&#13;
  &#13;
     connect.Agent = Agent;&#13;
     connect.AgentSnapshot = AgentSnapshot;&#13;
     connect.Contact = Contact;&#13;
     connect.ContactSnapshot = ContactSnapshot;&#13;
     connect.Connection = Connection;&#13;
     connect.ConnectionSnapshot = ConnectionSnapshot;&#13;
     connect.Endpoint = Endpoint;&#13;
     connect.Address = Endpoint;&#13;
     connect.SoftphoneError = SoftphoneError;&#13;
  &#13;
  })();&#13;
  /*&#13;
   * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.&#13;
   *&#13;
   * Licensed under the Amazon Software License (the "License"). You may not use&#13;
   * this file except in compliance with the License. A copy of the License is&#13;
   * located at&#13;
   *&#13;
   *    http://aws.amazon.com/asl/&#13;
   *&#13;
   * or in the "license" file accompanying this file. This file is distributed&#13;
   * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express&#13;
   * or implied. See the License for the specific language governing permissions&#13;
   * and limitations under the License.&#13;
   */&#13;
  (function() {&#13;
     var global = this;&#13;
     connect = global.connect || {};&#13;
     global.connect = connect;&#13;
     global.lily = connect;&#13;
  &#13;
     connect.core = {};&#13;
  &#13;
     connect.core.initialized = false;&#13;
  &#13;
     connect.DEFAULT_BATCH_SIZE = 100;&#13;
  &#13;
     var CCP_SYN_TIMEOUT = 1000; // 1 sec&#13;
     var CCP_ACK_TIMEOUT = 3000; // 3 sec&#13;
     var CCP_LOAD_TIMEOUT = 3000; // 3 sec&#13;
     var CCP_IFRAME_REFRESH_INTERVAL = 5000; // 5 sec&#13;
  &#13;
     var LOGIN_URL_PATTERN = "https://{alias}.awsapps.com/auth/?client_id={client_id}&amp;redirect_uri={redirect}";&#13;
     var CLIENT_ID_MAP = {&#13;
        "us-east-1":   "06919f4fd8ed324e"&#13;
     };&#13;
  &#13;
     /**&#13;
      * @deprecated&#13;
      * We will no longer need this function soon.&#13;
      */&#13;
     var createLoginUrl = function(params) {&#13;
        var redirect = "https://lily.us-east-1.amazonaws.com/taw/auth/code";&#13;
        connect.assertNotNull(redirect);&#13;
  &#13;
        if (params.alias) {&#13;
           return LOGIN_URL_PATTERN&#13;
              .replace("{alias}", params.alias)&#13;
              .replace("{client_id}", CLIENT_ID_MAP["us-east-1"])&#13;
              .replace("{redirect}", global.encodeURIComponent(&#13;
                 redirect));&#13;
        } else {&#13;
           return params.ccpUrl;&#13;
        }&#13;
     };&#13;
  &#13;
     /**-------------------------------------------------------------------------&#13;
      * Print a warning message if the Connect core is not initialized.&#13;
      */&#13;
     connect.core.checkNotInitialized = function() {&#13;
        if (connect.core.initialized) {&#13;
           var log = connect.getLog();&#13;
           log.warn("Connect core already initialized, only needs to be initialized once.");&#13;
        }&#13;
     };&#13;
  &#13;
     /**-------------------------------------------------------------------------&#13;
      * Basic Connect client initialization.&#13;
      * Should be used only by the API Shared Worker.&#13;
      */&#13;
     connect.core.init = function(params) {&#13;
        connect.assertNotNull(params, 'params');&#13;
  &#13;
        var authToken = connect.assertNotNull(params.authToken, 'params.authToken');&#13;
        var region = connect.assertNotNull(params.region, 'params.region');&#13;
        var endpoint = params.endpoint || null;&#13;
  &#13;
        connect.core.eventBus = new connect.EventBus();&#13;
        connect.core.agentDataProvider = new AgentDataProvider(connect.core.getEventBus());&#13;
        connect.core.client = new connect.AWSClient(authToken, region, endpoint);&#13;
        connect.core.initialized = true;&#13;
     };&#13;
  &#13;
     /**-------------------------------------------------------------------------&#13;
      * Uninitialize Connect.&#13;
      */&#13;
     connect.core.terminate = function() {&#13;
        connect.core.client = new connect.NullClient();&#13;
        connect.core.masterClient = new connect.NullClient();&#13;
        connect.core.eventBus = new connect.EventBus();&#13;
        connect.core.initialized = false;&#13;
     };&#13;
  &#13;
     /**-------------------------------------------------------------------------&#13;
      * Setup the SoftphoneManager to be initialized when the agent&#13;
      * is determined to have softphone enabled.&#13;
      */&#13;
     connect.core.softphoneUserMediaStream = null;&#13;
  &#13;
     connect.core.getSoftphoneUserMediaStream = function() {&#13;
          return connect.core.softphoneUserMediaStream;&#13;
     };&#13;
  &#13;
     connect.core.setSoftphoneUserMediaStream = function(stream) {&#13;
          connect.core.softphoneUserMediaStream = stream;&#13;
     };&#13;
  &#13;
     connect.core.initRingtoneEngines = function(params) {&#13;
        connect.assertNotNull(params, "params");&#13;
  &#13;
        var setupRingtoneEngines = function(ringtoneSettings) {&#13;
           connect.assertNotNull(ringtoneSettings, "ringtoneSettings");&#13;
           connect.assertNotNull(ringtoneSettings.voice, "ringtoneSettings.voice");&#13;
           connect.assertTrue(ringtoneSettings.voice.ringtoneUrl || ringtoneSettings.voice.disabled, "ringtoneSettings.voice.ringtoneUrl must be provided or ringtoneSettings.voice.disabled must be true");&#13;
           connect.assertNotNull(ringtoneSettings.queue_callback, "ringtoneSettings.queue_callback");&#13;
           connect.assertTrue(ringtoneSettings.queue_callback.ringtoneUrl || ringtoneSettings.queue_callback.disabled, "ringtoneSettings.voice.ringtoneUrl must be provided or ringtoneSettings.queue_callback.disabled must be true");&#13;
  &#13;
           connect.core.ringtoneEngines = {};&#13;
  &#13;
           connect.agent(function(agent) {&#13;
              agent.onRefresh(function() {&#13;
                 connect.ifMaster(connect.MasterTopics.RINGTONE, function() {&#13;
                    if (! ringtoneSettings.voice.disabled &amp;&amp; ! connect.core.ringtoneEngines.voice) {&#13;
                       connect.core.ringtoneEngines.voice =&#13;
                          new connect.VoiceRingtoneEngine(ringtoneSettings.voice);&#13;
                       connect.getLog().info("VoiceRingtoneEngine initialized.");&#13;
                    }&#13;
  &#13;
                    if (! ringtoneSettings.queue_callback.disabled &amp;&amp; ! connect.core.ringtoneEngines.queue_callback) {&#13;
                       connect.core.ringtoneEngines.queue_callback =&#13;
                          new connect.QueueCallbackRingtoneEngine(ringtoneSettings.queue_callback);&#13;
                       connect.getLog().info("QueueCallbackRingtoneEngine initialized.");&#13;
                    }&#13;
                 });&#13;
              });&#13;
           });&#13;
        };&#13;
  &#13;
        var mergeParams = function(params, otherParams) {&#13;
           // For backwards compatibility: support pulling disabled flag and ringtoneUrl&#13;
           // from softphone config if it exists from downstream into the ringtone config.&#13;
           params.ringtone = params.ringtone || {};&#13;
           params.ringtone.voice = params.ringtone.voice || {};&#13;
           params.ringtone.queue_callback = params.ringtone.queue_callback || {};&#13;
  &#13;
           if (otherParams.softphone) {&#13;
              if (otherParams.softphone.disableRingtone) {&#13;
                 params.ringtone.voice.disabled = true;&#13;
                 params.ringtone.queue_callback.disabled = true;&#13;
              }&#13;
  &#13;
              if (otherParams.softphone.ringtoneUrl) {&#13;
                 params.ringtone.voice.ringtoneUrl = otherParams.softphone.ringtoneUrl;&#13;
                 params.ringtone.queue_callback.ringtoneUrl = otherParams.softphone.ringtoneUrl;&#13;
              }&#13;
           }&#13;
  &#13;
           // Merge in ringtone settings from downstream.&#13;
           if (otherParams.ringtone) {&#13;
              params.ringtone.voice = connect.merge(params.ringtone.voice,&#13;
                 otherParams.ringtone.voice || {});&#13;
              params.ringtone.queue_callback = connect.merge(params.ringtone.queue_callback,&#13;
                 otherParams.ringtone.voice || {});&#13;
           }&#13;
        };&#13;
        &#13;
        // Merge params from params.softphone into params.ringtone&#13;
        // for embedded and non-embedded use cases so that defaults&#13;
        // are picked up.&#13;
        mergeParams(params, params);&#13;
  &#13;
        if (connect.isFramed()) {&#13;
           // If the CCP is in a frame, wait for configuration from downstream.&#13;
           var bus = connect.core.getEventBus();&#13;
           bus.subscribe(connect.EventType.CONFIGURE, function(data) {&#13;
              this.unsubscribe();&#13;
              // Merge all params from data into params for any overridden&#13;
              // values in either legacy "softphone" or "ringtone" settings.&#13;
              mergeParams(params, data);&#13;
              setupRingtoneEngines(params.ringtone);&#13;
           });&#13;
  &#13;
        } else {&#13;
           setupRingtoneEngines(params.ringtone);&#13;
        }&#13;
     };&#13;
  &#13;
     connect.core.initSoftphoneManager = function(paramsIn) {&#13;
        var params = paramsIn || {};&#13;
  &#13;
        var competeForMasterOnAgentUpdate = function(softphoneParamsIn) {&#13;
           var softphoneParams = connect.merge(params.softphone || {}, softphoneParamsIn);&#13;
  &#13;
           connect.agent(function(agent) {&#13;
              agent.onRefresh(function() {&#13;
                 var sub = this;&#13;
  &#13;
                 connect.ifMaster(connect.MasterTopics.SOFTPHONE, function() {&#13;
                    if (! connect.core.softphoneManager &amp;&amp; agent.isSoftphoneEnabled()) {&#13;
                       // Become master to send logs, since we need logs from softphone tab.&#13;
                       connect.becomeMaster(connect.MasterTopics.SEND_LOGS);&#13;
                       connect.core.softphoneManager = new connect.SoftphoneManager(softphoneParams);&#13;
                       sub.unsubscribe();&#13;
                    }&#13;
                 });&#13;
              });&#13;
           });&#13;
        };&#13;
  &#13;
        /**&#13;
         * If the window is framed, we need to wait for a CONFIGURE message from&#13;
         * downstream before we try to initialize, unless params.allowFramedSoftphone is true.&#13;
         */&#13;
        if (connect.isFramed() &amp;&amp; ! params.allowFramedSoftphone) {&#13;
           var bus = connect.core.getEventBus();&#13;
           bus.subscribe(connect.EventType.CONFIGURE, function(data) {&#13;
              if (data.softphone &amp;&amp; data.softphone.allowFramedSoftphone) {&#13;
                 this.unsubscribe();&#13;
                 competeForMasterOnAgentUpdate(data.softphone);&#13;
              }&#13;
           });&#13;
        } else {&#13;
           competeForMasterOnAgentUpdate(params);&#13;
        }&#13;
     };&#13;
  &#13;
     /**-------------------------------------------------------------------------&#13;
      * Initializes Connect by creating or connecting to the API Shared Worker.&#13;
      * Used primarily by the CCP.&#13;
      */&#13;
     connect.core.initSharedWorker = function(params) {&#13;
        connect.core.checkNotInitialized();&#13;
        if (connect.core.initialized) {&#13;
           return;&#13;
        }&#13;
        connect.assertNotNull(params, 'params');&#13;
  &#13;
        var sharedWorkerUrl = connect.assertNotNull(params.sharedWorkerUrl, 'params.sharedWorkerUrl');&#13;
        var authToken = connect.assertNotNull(params.authToken, 'params.authToken');&#13;
        var refreshToken = connect.assertNotNull(params.refreshToken, 'params.refreshToken');&#13;
        var authTokenExpiration = connect.assertNotNull(params.authTokenExpiration, 'params.authTokenExpiration');&#13;
        var region = connect.assertNotNull(params.region, 'params.region');&#13;
        var endpoint = params.endpoint || null;&#13;
  &#13;
        try {&#13;
           // Initialize the event bus and agent data providers.&#13;
           connect.core.eventBus = new connect.EventBus({logEvents: true});&#13;
           connect.core.agentDataProvider = new AgentDataProvider(connect.core.getEventBus());&#13;
  &#13;
           // Create the shared worker and upstream conduit.&#13;
           var worker = new SharedWorker(sharedWorkerUrl, "ConnectSharedWorker");&#13;
           var conduit = new connect.Conduit("ConnectSharedWorkerConduit",&#13;
                 new connect.PortStream(worker.port),&#13;
                 new connect.WindowIOStream(window, parent));&#13;
  &#13;
           // Set the global upstream conduit for external use.&#13;
           connect.core.upstream = conduit;&#13;
  &#13;
           // Close our port to the shared worker before the window closes.&#13;
           global.onbeforeunload = function() {&#13;
              conduit.sendUpstream(connect.EventType.CLOSE);&#13;
              worker.port.close();&#13;
           };&#13;
  &#13;
           connect.getLog().scheduleUpstreamLogPush(conduit);&#13;
           // Bridge all upstream messages into the event bus.&#13;
           conduit.onAllUpstream(connect.core.getEventBus().bridge());&#13;
           // Bridge all downstream messages into the event bus.&#13;
           conduit.onAllDownstream(connect.core.getEventBus().bridge());&#13;
           // Pass all upstream messages (from shared worker) downstream (to CCP consumer).&#13;
           conduit.onAllUpstream(conduit.passDownstream());&#13;
           // Pass all downstream messages (from CCP consumer) upstream (to shared worker).&#13;
           conduit.onAllDownstream(conduit.passUpstream());&#13;
           // Send configuration up to the shared worker.&#13;
           conduit.sendUpstream(connect.EventType.CONFIGURE, {&#13;
              authToken:     authToken,&#13;
              authTokenExpiration: authTokenExpiration,&#13;
              refreshToken:  refreshToken,&#13;
              endpoint:      endpoint,&#13;
              region:        region&#13;
           });&#13;
           conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function() {&#13;
              connect.getLog().info("Acknowledged by the ConnectSharedWorker!");&#13;
              connect.core.initialized = true;&#13;
              this.unsubscribe();&#13;
           });&#13;
           // Add all upstream log entries to our own logger.&#13;
           conduit.onUpstream(connect.EventType.LOG, function(logEntry) {&#13;
              connect.getLog().addLogEntry(connect.LogEntry.fromObject(logEntry));&#13;
           });&#13;
           // Reload the page if the shared worker detects an API auth failure.&#13;
           conduit.onUpstream(connect.EventType.AUTH_FAIL, function(logEntry) {&#13;
              location.reload();&#13;
           });&#13;
  &#13;
           connect.core.client = new connect.UpstreamConduitClient(conduit);&#13;
           connect.core.masterClient = new connect.UpstreamConduitMasterClient(conduit);&#13;
  &#13;
           // Pass the TERMINATE request upstream to the shared worker.&#13;
           connect.core.getEventBus().subscribe(connect.EventType.TERMINATE,&#13;
              conduit.passUpstream());&#13;
  &#13;
           // Refresh the page when we receive the TERMINATED response from the&#13;
           // shared worker.&#13;
           connect.core.getEventBus().subscribe(connect.EventType.TERMINATED, function() {&#13;
              window.location.reload(true);&#13;
           });&#13;
  &#13;
           worker.port.start();&#13;
  &#13;
           // Attempt to get permission to show notifications.&#13;
           var nm = connect.core.getNotificationManager();&#13;
           nm.requestPermission();&#13;
  &#13;
        } catch (e) {&#13;
           connect.getLog().error("Failed to initialize the API shared worker, we're dead!")&#13;
              .withException(e);&#13;
        }&#13;
     };&#13;
  &#13;
     /**-------------------------------------------------------------------------&#13;
      * Initializes Connect by creating or connecting to the API Shared Worker.&#13;
      * Initializes Connect by loading the CCP in an iframe and connecting to it.&#13;
      */&#13;
     connect.core.initCCP = function(containerDiv, paramsIn) {&#13;
        connect.core.checkNotInitialized();&#13;
        if (connect.core.initialized) {&#13;
           return;&#13;
        }&#13;
  &#13;
        // For backwards compatibility, when instead of taking a params object&#13;
        // as input we only accepted ccpUrl.&#13;
        var params = {};&#13;
        if (typeof(paramsIn) === 'string') {&#13;
           params.ccpUrl = paramsIn;&#13;
        } else {&#13;
           params = paramsIn;&#13;
        }&#13;
  &#13;
        var softphoneParams = params.softphone || null;&#13;
  &#13;
        connect.assertNotNull(containerDiv, 'containerDiv');&#13;
        connect.assertNotNull(params.ccpUrl, 'params.ccpUrl');&#13;
  &#13;
        // Create the CCP iframe and append it to the container div.&#13;
        var iframe = document.createElement('iframe');&#13;
        iframe.src = params.ccpUrl;&#13;
        iframe.style = "width: 100%; height: 100%";&#13;
        iframe.allow = "microphone";&#13;
        containerDiv.appendChild(iframe);&#13;
  &#13;
        // Initialize the event bus and agent data providers.&#13;
        // NOTE: Setting logEvents here to FALSE in order to avoid duplicating&#13;
        // events which are logged in CCP.&#13;
        connect.core.eventBus = new connect.EventBus({logEvents: false});&#13;
        connect.core.agentDataProvider = new AgentDataProvider(connect.core.getEventBus());&#13;
  &#13;
        // Build the upstream conduit communicating with the CCP iframe.&#13;
        var conduit = new connect.IFrameConduit(params.ccpUrl, window, iframe);&#13;
  &#13;
        // Set the global upstream conduit for external use.&#13;
        connect.core.upstream = conduit;&#13;
  &#13;
        conduit.onAllUpstream(connect.core.getEventBus().bridge());&#13;
  &#13;
        // Initialize the keepalive manager.&#13;
        connect.core.keepaliveManager = new KeepaliveManager(conduit,&#13;
                                                          connect.core.getEventBus(),&#13;
                                                          params.ccpSynTimeout || CCP_SYN_TIMEOUT,&#13;
                                                          params.ccpAckTimeout || CCP_ACK_TIMEOUT);&#13;
        connect.core.iframeRefreshInterval = null;&#13;
  &#13;
        // Allow 10 sec (default) before receiving the first ACK from the CCP.&#13;
        connect.core.ccpLoadTimeoutInstance = global.setTimeout(function() {&#13;
           connect.core.ccpLoadTimeoutInstance = null;&#13;
           connect.core.getEventBus().trigger(connect.EventType.ACK_TIMEOUT);&#13;
        }, params.ccpLoadTimeout || CCP_LOAD_TIMEOUT);&#13;
  &#13;
        // Once we receive the first ACK, setup our upstream API client and establish&#13;
        // the SYN/ACK refresh flow.&#13;
        conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function() {&#13;
           connect.getLog().info("Acknowledged by the CCP!");&#13;
           connect.core.client = new connect.UpstreamConduitClient(conduit);&#13;
           connect.core.masterClient = new connect.UpstreamConduitMasterClient(conduit);&#13;
           connect.core.initialized = true;&#13;
  &#13;
           if (softphoneParams) {&#13;
              // Send configuration up to the CCP.&#13;
              conduit.sendUpstream(connect.EventType.CONFIGURE, {&#13;
                 softphone:  softphoneParams&#13;
              });&#13;
           }&#13;
  &#13;
           if (connect.core.ccpLoadTimeoutInstance) {&#13;
              global.clearTimeout(connect.core.ccpLoadTimeoutInstance);&#13;
              connect.core.ccpLoadTimeoutInstance = null;&#13;
           }&#13;
  &#13;
           connect.core.keepaliveManager.start();&#13;
           this.unsubscribe();&#13;
        });&#13;
  &#13;
        // Add any logs from the upstream to our own logger.&#13;
        conduit.onUpstream(connect.EventType.LOG, function(logEntry) {&#13;
           connect.getLog().addLogEntry(connect.LogEntry.fromObject(logEntry));&#13;
        });&#13;
  &#13;
        // Pop a login page when we encounter an ACK timeout.&#13;
        connect.core.getEventBus().subscribe(connect.EventType.ACK_TIMEOUT, function() {&#13;
           // loginPopup is true by default, only false if explicitly set to false.&#13;
           if (params.loginPopup !== false) {&#13;
              try {&#13;
                 var loginUrl = createLoginUrl(params);&#13;
                 connect.getLog().warn("ACK_TIMEOUT occurred, attempting to pop the login page if not already open.");&#13;
                 connect.core.getPopupManager().open(loginUrl, connect.MasterTopics.LOGIN_POPUP);&#13;
  &#13;
              } catch (e) {&#13;
                 connect.getLog().error("ACK_TIMEOUT occurred but we are unable to open the login popup.").withException(e);&#13;
              }&#13;
           }&#13;
  &#13;
           if (connect.core.iframeRefreshInterval == null) {&#13;
              connect.core.iframeRefreshInterval = window.setInterval(function() {&#13;
                 iframe.src = params.ccpUrl;&#13;
              }, CCP_IFRAME_REFRESH_INTERVAL);&#13;
  &#13;
              conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function() {&#13;
                 this.unsubscribe();&#13;
                 global.clearInterval(connect.core.iframeRefreshInterval);&#13;
                 connect.core.iframeRefreshInterval = null;&#13;
                 connect.core.getPopupManager().clear(connect.MasterTopics.LOGIN_POPUP);&#13;
              });&#13;
           }&#13;
        });&#13;
     };&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     var KeepaliveManager = function(conduit, eventBus, synTimeout, ackTimeout) {&#13;
        this.conduit = conduit;&#13;
        this.eventBus = eventBus;&#13;
        this.synTimeout = synTimeout;&#13;
        this.ackTimeout = ackTimeout;&#13;
        this.ackTimer = null;&#13;
        this.synTimer = null;&#13;
        this.ackSub = null;&#13;
     };&#13;
  &#13;
     KeepaliveManager.prototype.start = function() {&#13;
        var self = this;&#13;
  &#13;
        this.conduit.sendUpstream(connect.EventType.SYNCHRONIZE);&#13;
        this.ackSub = this.conduit.onUpstream(connect.EventType.ACKNOWLEDGE, function() {&#13;
           this.unsubscribe();&#13;
           global.clearTimeout(self.ackTimer);&#13;
           self.deferStart();&#13;
        });&#13;
        this.ackTimer = global.setTimeout(function() {&#13;
           self.ackSub.unsubscribe();&#13;
           self.eventBus.trigger(connect.EventType.ACK_TIMEOUT);&#13;
           self.deferStart();&#13;
        }, this.ackTimeout);&#13;
     };&#13;
  &#13;
     KeepaliveManager.prototype.deferStart = function() {&#13;
        if (this.synTimer == null) {&#13;
           this.synTimer = global.setTimeout(connect.hitch(this, this.start), this.synTimeout);&#13;
        }&#13;
     };&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     var AgentDataProvider = function(bus) {&#13;
        var agentData = null;&#13;
        this.bus = bus;&#13;
        this.bus.subscribe(connect.AgentEvents.UPDATE, connect.hitch(this, this.updateAgentData));&#13;
     };&#13;
  &#13;
     AgentDataProvider.prototype.updateAgentData = function(agentData) {&#13;
        var oldAgentData = this.agentData;&#13;
        this.agentData = agentData;&#13;
  &#13;
        if (oldAgentData == null) {&#13;
           connect.agent.initialized = true;&#13;
           this.bus.trigger(connect.AgentEvents.INIT, new connect.Agent());&#13;
        }&#13;
  &#13;
        this.bus.trigger(connect.AgentEvents.REFRESH, new connect.Agent());&#13;
  &#13;
        this._fireAgentUpdateEvents(oldAgentData);&#13;
     };&#13;
  &#13;
     AgentDataProvider.prototype.getAgentData = function() {&#13;
        if (this.agentData == null) {&#13;
           throw new connect.StateError('No agent data is available yet!');&#13;
        }&#13;
  &#13;
        return this.agentData;&#13;
     };&#13;
  &#13;
     AgentDataProvider.prototype.getContactData = function(contactId) {&#13;
        var agentData = this.getAgentData();&#13;
        var contactData = connect.find(agentData.snapshot.contacts, function(ctdata) {&#13;
           return ctdata.contactId === contactId;&#13;
        });&#13;
  &#13;
        if (contactData == null) {&#13;
           throw new connect.StateError('Contact %s no longer exists.', contactId);&#13;
        }&#13;
  &#13;
        return contactData;&#13;
     };&#13;
  &#13;
     AgentDataProvider.prototype.getConnectionData = function(contactId, connectionId) {&#13;
        var contactData = this.getContactData(contactId);&#13;
        var connectionData = connect.find(contactData.connections, function(cdata) {&#13;
           return cdata.connectionId === connectionId;&#13;
        });&#13;
  &#13;
        if (connectionData == null) {&#13;
           throw new connect.StateError('Connection %s for contact %s no longer exists.', connectionId, contactId);&#13;
        }&#13;
  &#13;
        return connectionData;&#13;
     };&#13;
  &#13;
     AgentDataProvider.prototype._diffContacts = function(oldAgentData) {&#13;
        var diff = {&#13;
           added:      {},&#13;
           removed:    {},&#13;
           common:     {},&#13;
           oldMap:     connect.index(oldAgentData == null ? [] : oldAgentData.snapshot.contacts, function(contact) { return contact.contactId; }),&#13;
           newMap:     connect.index(this.agentData.snapshot.contacts, function(contact) { return contact.contactId; })&#13;
        };&#13;
  &#13;
        connect.keys(diff.oldMap).forEach(function(contactId) {&#13;
           if (connect.contains(diff.newMap, contactId)) {&#13;
              diff.common[contactId] = diff.newMap[contactId];&#13;
           } else {&#13;
              diff.removed[contactId] = diff.oldMap[contactId];&#13;
           }&#13;
        });&#13;
  &#13;
        connect.keys(diff.newMap).forEach(function(contactId) {&#13;
           if (! connect.contains(diff.oldMap, contactId)) {&#13;
              diff.added[contactId] = diff.newMap[contactId];&#13;
           }&#13;
        });&#13;
  &#13;
        return diff;&#13;
     };&#13;
  &#13;
     AgentDataProvider.prototype._fireAgentUpdateEvents = function(oldAgentData) {&#13;
        var self = this;&#13;
        var diff = null;&#13;
        var oldAgentState = oldAgentData == null ? connect.AgentAvailStates.INIT : oldAgentData.snapshot.state.name;&#13;
        var newAgentState = this.agentData.snapshot.state.name;&#13;
        var oldRoutingState = oldAgentData == null ? connect.AgentStateType.INIT : oldAgentData.snapshot.state.type;&#13;
        var newRoutingState = this.agentData.snapshot.state.type;&#13;
  &#13;
        if (oldRoutingState !== newRoutingState) {&#13;
           connect.core.getAgentRoutingEventGraph().getAssociations(this, oldRoutingState, newRoutingState).forEach(function(event) {&#13;
              self.bus.trigger(event, new connect.Agent());&#13;
           });&#13;
        }&#13;
  &#13;
        if (oldAgentState !== newAgentState) {&#13;
           this.bus.trigger(connect.AgentEvents.STATE_CHANGE, {&#13;
              agent:      new connect.Agent(),&#13;
              oldState:  oldAgentState,&#13;
              newState:  newAgentState&#13;
  &#13;
           });&#13;
           connect.core.getAgentStateEventGraph().getAssociations(this, oldAgentState, newAgentState).forEach(function(event) {&#13;
              self.bus.trigger(event, new connect.Agent());&#13;
           });&#13;
        }&#13;
  &#13;
        if (oldAgentData !== null) {&#13;
           diff = this._diffContacts(oldAgentData);&#13;
  &#13;
        } else {&#13;
           diff =  {&#13;
              added:      connect.index(this.agentData.snapshot.contacts, function(contact) { return contact.contactId; }),&#13;
              removed:    {},&#13;
              common:     {},&#13;
              oldMap:     {},&#13;
              newMap:     connect.index(this.agentData.snapshot.contacts, function(contact) { return contact.contactId; })&#13;
           };&#13;
        }&#13;
  &#13;
        connect.values(diff.added).forEach(function(contactData) {&#13;
           self.bus.trigger(connect.ContactEvents.INIT, new connect.Contact(contactData.contactId));&#13;
           self._fireContactUpdateEvents(contactData.contactId, connect.ContactStateType.INIT, contactData.state.type);&#13;
        });&#13;
  &#13;
        connect.values(diff.removed).forEach(function(contactData) {&#13;
           self.bus.trigger(connect.ContactEvents.DESTROYED, new connect.ContactSnapshot(contactData));&#13;
           self.bus.trigger(connect.core.getContactEventName(connect.ContactEvents.DESTROYED, contactData.contactId), new connect.ContactSnapshot(contactData));&#13;
           self._unsubAllContactEventsForContact(contactData.contactId);&#13;
        });&#13;
  &#13;
        connect.keys(diff.common).forEach(function(contactId) {&#13;
           self._fireContactUpdateEvents(contactId, diff.oldMap[contactId].state.type, diff.newMap[contactId].state.type);&#13;
        });&#13;
     };&#13;
  &#13;
     AgentDataProvider.prototype._fireContactUpdateEvents = function(contactId, oldContactState, newContactState) {&#13;
        var self = this;&#13;
        if (oldContactState !== newContactState) {&#13;
           connect.core.getContactEventGraph().getAssociations(this, oldContactState, newContactState).forEach(function(event) {&#13;
              self.bus.trigger(event, new connect.Contact(contactId));&#13;
              self.bus.trigger(connect.core.getContactEventName(event, contactId), new connect.Contact(contactId));&#13;
           });&#13;
        }&#13;
  &#13;
        self.bus.trigger(connect.ContactEvents.REFRESH, new connect.Contact(contactId));&#13;
        self.bus.trigger(connect.core.getContactEventName(connect.ContactEvents.REFRESH, contactId), new connect.Contact(contactId));&#13;
     };&#13;
  &#13;
     AgentDataProvider.prototype._unsubAllContactEventsForContact = function(contactId) {&#13;
        var self = this;&#13;
        connect.values(connect.ContactEvents).forEach(function(eventName) {&#13;
           self.bus.getSubscriptions(connect.core.getContactEventName(eventName, contactId))&#13;
              .map(function(sub) { sub.unsubscribe(); });&#13;
        });&#13;
     };&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getContactEventName = function(eventName, contactId) {&#13;
        connect.assertNotNull(eventName, 'eventName');&#13;
        connect.assertNotNull(contactId, 'contactId');&#13;
        if (! connect.contains(connect.values(connect.ContactEvents), eventName)) {&#13;
           throw new connect.ValueError('%s is not a valid contact event.', eventName);&#13;
        }&#13;
        return connect.sprintf('%s::%s', eventName, contactId);&#13;
     };&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getEventBus = function() {&#13;
        return connect.core.eventBus;&#13;
     };&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getAgentDataProvider = function() {&#13;
        return connect.core.agentDataProvider;&#13;
     };&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getLocalTimestamp = function() {&#13;
        return connect.core.getAgentDataProvider().getAgentData().snapshot.localTimestamp;&#13;
     };&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getSkew = function() {&#13;
        return connect.core.getAgentDataProvider().getAgentData().snapshot.skew;&#13;
     };&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getAgentRoutingEventGraph = function() {&#13;
        return connect.core.agentRoutingEventGraph;&#13;
     };&#13;
     connect.core.agentRoutingEventGraph = new connect.EventGraph()&#13;
        .assoc(connect.EventGraph.ANY, connect.AgentStateType.ROUTABLE,&#13;
               connect.AgentEvents.ROUTABLE)&#13;
        .assoc(connect.EventGraph.ANY, connect.AgentStateType.NOT_ROUTABLE,&#13;
               connect.AgentEvents.NOT_ROUTABLE)&#13;
        .assoc(connect.EventGraph.ANY, connect.AgentStateType.OFFLINE,&#13;
               connect.AgentEvents.OFFLINE);&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getAgentStateEventGraph = function() {&#13;
        return connect.core.agentStateEventGraph;&#13;
     };&#13;
     connect.core.agentStateEventGraph = new connect.EventGraph()&#13;
        .assoc(connect.EventGraph.ANY,&#13;
               connect.values(connect.AgentErrorStates),&#13;
               connect.AgentEvents.ERROR)&#13;
        .assoc(connect.EventGraph.ANY, connect.AgentAvailStates.AFTER_CALL_WORK,&#13;
               connect.AgentEvents.ACW);&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getContactEventGraph = function() {&#13;
        return connect.core.contactEventGraph;&#13;
     };&#13;
  &#13;
     connect.core.contactEventGraph = new connect.EventGraph()&#13;
        .assoc(connect.EventGraph.ANY,&#13;
               connect.ContactStateType.INCOMING,&#13;
               connect.ContactEvents.INCOMING)&#13;
        .assoc(connect.EventGraph.ANY,&#13;
               connect.ContactStateType.PENDING,&#13;
               connect.ContactEvents.PENDING)&#13;
        .assoc(connect.EventGraph.ANY,&#13;
               connect.ContactStateType.CONNECTING,&#13;
               connect.ContactEvents.CONNECTING)&#13;
        .assoc(connect.EventGraph.ANY,&#13;
               connect.ContactStateType.CONNECTED,&#13;
               connect.ContactEvents.CONNECTED)&#13;
        .assoc(connect.ContactStateType.INCOMING,&#13;
               connect.ContactStateType.ERROR,&#13;
               connect.ContactEvents.MISSED)&#13;
        .assoc(connect.EventGraph.ANY,&#13;
               connect.ContactStateType.ENDED,&#13;
               connect.ContactEvents.ACW)&#13;
        .assoc(connect.values(connect.CONTACT_ACTIVE_STATES),&#13;
               connect.values(connect.relativeComplement(connect.CONTACT_ACTIVE_STATES, connect.ContactStateType)),&#13;
               connect.ContactEvents.ENDED);&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getClient = function() {&#13;
        if (! connect.core.client) {&#13;
           throw new connect.StateError('The connect core has not been initialized!');&#13;
        }&#13;
        return connect.core.client;&#13;
     };&#13;
     connect.core.client = null;&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getMasterClient = function() {&#13;
        if (! connect.core.masterClient) {&#13;
           throw new connect.StateError('The connect master client has not been initialized!');&#13;
        }&#13;
        return connect.core.masterClient;&#13;
     };&#13;
     connect.core.masterClient = null;&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getSoftphoneManager = function() {&#13;
        return connect.core.softphoneManager;&#13;
     };&#13;
     connect.core.softphoneManager = null;&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getNotificationManager = function() {&#13;
        if (! connect.core.notificationManager) {&#13;
           connect.core.notificationManager = new connect.NotificationManager();&#13;
        }&#13;
        return connect.core.notificationManager;&#13;
     };&#13;
     connect.core.notificationManager = null;&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getPopupManager = function() {&#13;
        return connect.core.popupManager;&#13;
     };&#13;
     connect.core.popupManager = new connect.PopupManager();&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getPopupManager = function() {&#13;
        return connect.core.popupManager;&#13;
     };&#13;
     connect.core.popupManager = new connect.PopupManager();&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.getUpstream = function() {&#13;
        if (! connect.core.upstream) {&#13;
           throw new connect.StateError('There is no upstream conduit!');&#13;
        }&#13;
        return connect.core.upstream;&#13;
     };&#13;
     connect.core.upstream = null;&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.core.AgentDataProvider = AgentDataProvider;&#13;
  &#13;
  })();&#13;
  /*&#13;
   * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.&#13;
   *&#13;
   * Licensed under the Amazon Software License (the "License"). You may not use&#13;
   * this file except in compliance with the License. A copy of the License is&#13;
   * located at&#13;
   *&#13;
   *    http://aws.amazon.com/asl/&#13;
   *&#13;
   * or in the "license" file accompanying this file. This file is distributed&#13;
   * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express&#13;
   * or implied. See the License for the specific language governing permissions&#13;
   * and limitations under the License.&#13;
   */&#13;
  (function() {&#13;
     var global = this;&#13;
     var connect = global.connect || {};&#13;
     global.connect = connect;&#13;
     global.lily = connect;&#13;
  &#13;
     var RingtoneEngineBase = function(ringtoneConfig) {&#13;
        var self = this;&#13;
        this._prevContactId = null;&#13;
  &#13;
        connect.assertNotNull(ringtoneConfig, "ringtoneConfig");&#13;
        if (! ringtoneConfig.ringtoneUrl) {&#13;
           throw new Error("ringtoneUrl is required!");&#13;
        }&#13;
  &#13;
        if (global.Audio &amp;&amp; typeof global.Promise !== "undefined") {&#13;
           this._playableAudioPromise = new Promise(function(resolve, reject) {&#13;
              self._audio = new Audio(ringtoneConfig.ringtoneUrl);&#13;
              self._audio.loop = true;&#13;
              self._audio.addEventListener("canplay", function(){&#13;
                 self._audioPlayable = true;&#13;
                 resolve(self._audio);&#13;
              });&#13;
           });&#13;
  &#13;
        } else {&#13;
           this._audio = null;&#13;
           connect.getLog().error("Unable to provide a ringtone.");&#13;
        }&#13;
  &#13;
        self._driveRingtone();&#13;
     };&#13;
  &#13;
     RingtoneEngineBase.prototype._driveRingtone = function() {&#13;
        throw new Error("Not implemented.");&#13;
     };&#13;
  &#13;
     RingtoneEngineBase.prototype._startRingtone = function() {&#13;
        if (this._audio) {&#13;
           this._audio.play();&#13;
        }&#13;
     };&#13;
  &#13;
     RingtoneEngineBase.prototype._stopRingtone = function() {&#13;
        if (this._audio) {&#13;
           this._audio.pause();&#13;
           this._audio.currentTime = 0;&#13;
        }&#13;
     };&#13;
  &#13;
     /**&#13;
      * Stop ringtone.&#13;
      */&#13;
     RingtoneEngineBase.prototype.stopRingtone = function() {&#13;
        this._stopRingtone();&#13;
     };&#13;
  &#13;
     RingtoneEngineBase.prototype._ringtoneSetup = function(contact) {&#13;
        var self = this;&#13;
        connect.ifMaster(connect.MasterTopics.RINGTONE, function() {&#13;
           self._startRingtone();&#13;
           self._prevContactId = contact.getContactId();&#13;
  &#13;
           contact.onConnected(lily.hitch(self, self._stopRingtone));&#13;
           contact.onAccepted(lily.hitch(self, self._stopRingtone));&#13;
           contact.onEnded(lily.hitch(self, self._stopRingtone));&#13;
        });&#13;
     };&#13;
  &#13;
     /**&#13;
      * Change the audio device used to play ringtone.&#13;
      * If audio element is not fully initialized, the API will wait _audioPlayablePromise for 3 seconds and fail on timeout.&#13;
      * This API is supported only by browsers that implemented ES6 Promise and http://www.w3.org/TR/audio-output/&#13;
      * Return a Promise that indicates the result of changing output device.&#13;
      */&#13;
     RingtoneEngineBase.prototype.setOutputDevice = function(deviceId) {&#13;
        if (this._playableAudioPromise) {&#13;
           var playableAudioWithTimeout = Promise.race([&#13;
              this._playableAudioPromise,&#13;
              new Promise(function(resolve, reject){&#13;
                 global.setTimeout(function(){reject("Timed out waiting for playable audio");}, 3000/*ms*/);&#13;
              })&#13;
           ]);&#13;
           return playableAudioWithTimeout.then(function(audio){&#13;
              if (audio.setSinkId) {&#13;
                 return Promise.resolve(audio.setSinkId(deviceId));&#13;
              } else {&#13;
                 return Promise.reject("Not supported");&#13;
              }&#13;
           });&#13;
        }&#13;
  &#13;
        if (global.Promise) {&#13;
           return Promise.reject("Not eligible ringtone owner");&#13;
        }&#13;
     };&#13;
  &#13;
     var VoiceRingtoneEngine = function(ringtoneConfig) {&#13;
        RingtoneEngineBase.call(this, ringtoneConfig);&#13;
     };&#13;
     VoiceRingtoneEngine.prototype = Object.create(RingtoneEngineBase.prototype);&#13;
     VoiceRingtoneEngine.prototype.constructor = VoiceRingtoneEngine;&#13;
  &#13;
     VoiceRingtoneEngine.prototype._driveRingtone = function() {&#13;
        var self = this;&#13;
  &#13;
        connect.contact(function(contact) {&#13;
           contact.onConnecting(function() {&#13;
              if (contact.getType() === lily.ContactType.VOICE &amp;&amp;&#13;
                 contact.isSoftphoneCall() &amp;&amp; contact.isInbound()) {&#13;
                 self._ringtoneSetup(contact);&#13;
              }&#13;
           });&#13;
        });&#13;
     };&#13;
  &#13;
     var QueueCallbackRingtoneEngine = function(ringtoneConfig) {&#13;
        RingtoneEngineBase.call(this, ringtoneConfig);&#13;
     };&#13;
     QueueCallbackRingtoneEngine.prototype = Object.create(RingtoneEngineBase.prototype);&#13;
     QueueCallbackRingtoneEngine.prototype.constructor = QueueCallbackRingtoneEngine;&#13;
  &#13;
     QueueCallbackRingtoneEngine.prototype._driveRingtone = function() {&#13;
        var self = this;&#13;
  &#13;
        connect.contact(function(contact) {&#13;
           contact.onIncoming(function() {&#13;
               if (contact.getType() === lily.ContactType.QUEUE_CALLBACK) {&#13;
                  self._ringtoneSetup(contact);&#13;
               }&#13;
            });&#13;
        });&#13;
     };&#13;
  &#13;
     /* export connect.RingtoneEngine */&#13;
     connect.VoiceRingtoneEngine = VoiceRingtoneEngine;&#13;
     connect.QueueCallbackRingtoneEngine = QueueCallbackRingtoneEngine;&#13;
  })();&#13;
  /*&#13;
   * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.&#13;
   *&#13;
   * Licensed under the Amazon Software License (the "License"). You may not use&#13;
   * this file except in compliance with the License. A copy of the License is&#13;
   * located at&#13;
   *&#13;
   *    http://aws.amazon.com/asl/&#13;
   *&#13;
   * or in the "license" file accompanying this file. This file is distributed&#13;
   * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express&#13;
   * or implied. See the License for the specific language governing permissions&#13;
   * and limitations under the License.&#13;
   */&#13;
  (function() {&#13;
     var global = this;&#13;
     connect = global.connect || {};&#13;
     global.connect = connect;&#13;
     global.lily = connect;&#13;
  &#13;
     var RTPJobIntervalMs = 1000;&#13;
     var statsReportingJobIntervalMs = 30000;&#13;
     var streamBufferSize = 500;&#13;
     var CallTypeMap = {};&#13;
     CallTypeMap[connect.SoftphoneCallType.AUDIO_ONLY] = 'Audio';&#13;
     CallTypeMap[connect.SoftphoneCallType.VIDEO_ONLY] = 'Video';&#13;
     CallTypeMap[connect.SoftphoneCallType.AUDIO_VIDEO] = 'AudioVideo';&#13;
     CallTypeMap[connect.SoftphoneCallType.NONE] = 'None';&#13;
     var AUDIO_INPUT = 'audio_input';&#13;
     var AUDIO_OUTPUT = 'audio_output';&#13;
  &#13;
     var MediaTypeMap = {};&#13;
     MediaTypeMap[connect.ContactType.VOICE] = "Voice";&#13;
     var UNKNOWN_MEDIA_TYPE = "Unknown";&#13;
  &#13;
     var timeSeriesStreamStatsBuffer = [];&#13;
     var aggregatedUserAudioStats = null;&#13;
     var aggregatedRemoteAudioStats = null;&#13;
     var rtpStatsJob = null;&#13;
     var reportStatsJob = null;&#13;
     //Logger specific to softphone.&#13;
     var logger = null;&#13;
  &#13;
     var SoftphoneErrorTypes = connect.SoftphoneErrorTypes;&#13;
  &#13;
     var SoftphoneManager = function(softphoneParams) {&#13;
        logger = new SoftphoneLogger(connect.getLog());&#13;
        if (!isBrowserSoftPhoneSupported()) {&#13;
           publishError(SoftphoneErrorTypes.UNSUPPORTED_BROWSER,&#13;
                        "Connect does not support this browser. Some functionality may not work. ",&#13;
                        "");&#13;
        }&#13;
        var gumPromise = fetchUserMedia({&#13;
           success: function(stream) {&#13;
              if (connect.isFirefoxBrowser()) {&#13;
                  connect.core.setSoftphoneUserMediaStream(stream);&#13;
              }&#13;
           },&#13;
           failure: function(err) {&#13;
              publishError(err, "Your microphone is not enabled in your browser. ", "");&#13;
           }&#13;
        });&#13;
  &#13;
        this.ringtoneEngine = null;&#13;
  &#13;
        connect.contact(function(contact) {&#13;
           var callDetected = false;&#13;
  &#13;
           contact.onRefresh(function() {&#13;
              if (contact.isSoftphoneCall() &amp;&amp; !callDetected &amp;&amp; (&#13;
                       contact.getStatus().type === connect.ContactStatusType.CONNECTING ||&#13;
                       contact.getStatus().type === connect.ContactStatusType.INCOMING)) {&#13;
  &#13;
                 callDetected = true;&#13;
                 logger.info("Softphone call detected: ", contact.getContactId());&#13;
                 initializeParams();&#13;
                 var softphoneInfo = contact.getAgentConnection().getSoftphoneMediaInfo();&#13;
                 var callConfig = parseCallConfig(softphoneInfo.callConfigJson);&#13;
  &#13;
                 var session = new connect.RTCSession(&#13;
                       callConfig.signalingEndpoint,&#13;
                       callConfig.iceServers,&#13;
                       softphoneInfo.callContextToken,&#13;
                       logger,&#13;
                       contact.getContactId());&#13;
                 if (connect.core.getSoftphoneUserMediaStream()) {&#13;
                      session.mediaStream = connect.core.getSoftphoneUserMediaStream();&#13;
                 }&#13;
                 session.onSessionFailed = function(rtcSession, reason) {&#13;
                     if (reason === connect.RTCErrors.ICE_COLLECTION_TIMEOUT) {&#13;
                          var endPointUrl = "\n";&#13;
                          for (var i=0; i &lt; rtcSession._iceServers.length; i++) {&#13;
                              for (var j=0; j &lt; rtcSession._iceServers[i].urls.length; j++) {&#13;
                                  endPointUrl = endPointUrl + rtcSession._iceServers[i].urls[j] + "\n";&#13;
                              }&#13;
                          }&#13;
                          publishError(SoftphoneErrorTypes.ICE_COLLECTION_TIMEOUT, "Ice collection timedout. " ,endPointUrl);&#13;
                     } else if (reason === connect.RTCErrors.USER_BUSY) {&#13;
                          publishError(SoftphoneErrorTypes.USER_BUSY_ERROR,&#13;
                          "Softphone call UserBusy error. ",&#13;
                          "");&#13;
                     } else if (reason === connect.RTCErrors.SIGNALLING_HANDSHAKE_FAILURE) {&#13;
                          publishError(SoftphoneErrorTypes.SIGNALLING_HANDSHAKE_FAILURE,&#13;
                          "Handshaking with Signalling Server " + rtcSession._signalingUri + " failed. ",&#13;
                          rtcSession._signalingUri);&#13;
                     } else if (reason === connect.RTCErrors.GUM_TIMEOUT_FAILURE || reason === connect.RTCErrors.GUM_OTHER_FAILURE) {&#13;
                          publishError(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED,&#13;
                          "Your microphone is not enabled in your browser. ",&#13;
                          "");&#13;
                     } else if (reason === connect.RTCErrors.SIGNALLING_CONNECTION_FAILURE) {&#13;
                          publishError(SoftphoneErrorTypes.SIGNALLING_CONNECTION_FAILURE,&#13;
                          "URL " +  rtcSession._signalingUri + " cannot be reached. ",&#13;
                          rtcSession._signalingUri);&#13;
                     } else if (reason === connect.RTCErrors.CALL_NOT_FOUND) {&#13;
                          //No need to publish any softphone error for this case. CCP UX will handle this case.&#13;
                          logger.error("Softphone call failed due to CallNotFoundException.");&#13;
                     } else {&#13;
                          publishError(SoftphoneErrorTypes.WEBRTC_ERROR,&#13;
                          "webrtc system error. ",&#13;
                          "");&#13;
                     }&#13;
                     stopJobsAndReport(contact, rtcSession.sessionReport);&#13;
                 };&#13;
                 session.onSessionConnected = function(rtcSession) {&#13;
                      //Become master to send logs, since we need logs from softphone tab.&#13;
                      connect.becomeMaster(connect.MasterTopics.SEND_LOGS);&#13;
                      //start stats collection and reporting jobs&#13;
                      startStatsCollectionJob(rtcSession);&#13;
                      startStatsReportingJob(contact);&#13;
                 };&#13;
  &#13;
                 session.onSessionCompleted = function(rtcSession) {&#13;
                      //stop all jobs and perform one last job&#13;
                      stopJobsAndReport(contact, rtcSession.sessionReport);&#13;
                 };&#13;
                 session.remoteAudioElement = document.getElementById('remote-audio');&#13;
                 session.connect();&#13;
              }&#13;
           });&#13;
        });&#13;
     };&#13;
  &#13;
     /** Parse the JSON encoded web call config into the data it represents. */&#13;
     var parseCallConfig = function(serializedConfig) {&#13;
         // Our underscore is too old for unescape&#13;
         // https://issues.amazon.com/issues/CSWF-1467&#13;
         var decodedJSON = serializedConfig.replace(/&amp;quot;/g, '"');&#13;
         return JSON.parse(decodedJSON);&#13;
     };&#13;
  &#13;
     var fetchUserMedia = function(callbacksIn) {&#13;
        var callbacks = callbacksIn || {};&#13;
        callbacks.success = callbacks.success || function() {};&#13;
        callbacks.failure = callbacks.failure || function() {};&#13;
  &#13;
        var CONSTRAINT = {&#13;
           audio: true&#13;
        };&#13;
  &#13;
        var promise = null;&#13;
  &#13;
        if (typeof Promise !== "function") {&#13;
           callbacks.failure(SoftphoneErrorTypes.UNSUPPORTED_BROWSER);&#13;
           return;&#13;
        }&#13;
  &#13;
        if (typeof navigator.mediaDevices === "object" &amp;&amp; typeof navigator.mediaDevices.getUserMedia === "function") {&#13;
           promise = navigator.mediaDevices.getUserMedia(CONSTRAINT);&#13;
  &#13;
        } else if (typeof navigator.webkitGetUserMedia === "function") {&#13;
           promise = new Promise(function(resolve, reject) {&#13;
              navigator.webkitGetUserMedia(CONSTRAINT, resolve, reject);&#13;
           });&#13;
  &#13;
        } else {&#13;
           callbacks.failure(SoftphoneErrorTypes.UNSUPPORTED_BROWSER);&#13;
           return;&#13;
        }&#13;
  &#13;
        promise.then(function(stream) {&#13;
           var audioTracks = stream.getAudioTracks();&#13;
           if (audioTracks &amp;&amp; audioTracks.length &gt; 0) {&#13;
              callbacks.success(stream);&#13;
           } else {&#13;
              callbacks.failure(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED);&#13;
           }&#13;
        }, function(err) {&#13;
           callbacks.failure(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED);&#13;
        });&#13;
        return promise;&#13;
     };&#13;
  &#13;
     var publishError = function(errorType, message, endPointUrl) {&#13;
        var bus = connect.core.getEventBus();&#13;
        logger.error("Softphone error occurred : ", errorType,&#13;
              message || "");&#13;
        bus.trigger(connect.AgentEvents.SOFTPHONE_ERROR, new connect.SoftphoneError(errorType, message, endPointUrl));&#13;
     };&#13;
  &#13;
      var isBrowserSoftPhoneSupported = function () {&#13;
          // In Opera, the true version is after "Opera" or after "Version"&#13;
          if (connect.isOperaBrowser() &amp;&amp; connect.getOperaBrowserVersion() &gt; 17) {&#13;
              return true;&#13;
          }&#13;
          // In Chrome, the true version is after "Chrome"&#13;
          else if (connect.isChromeBrowser() &amp;&amp; connect.getChromeBrowserVersion() &gt; 22) {&#13;
              return true;&#13;
          }&#13;
          // In Firefox, the true version is after "Firefox"&#13;
          else if (connect.isFirefoxBrowser() &amp;&amp; connect.getFirefoxBrowserVersion() &gt; 21) {&#13;
              return true;&#13;
          } else {&#13;
              return false;&#13;
          }&#13;
      };&#13;
  &#13;
      var sendSoftphoneMetrics = function(contact) {&#13;
          var streamStats = timeSeriesStreamStatsBuffer.slice();&#13;
          timeSeriesStreamStatsBuffer = [];&#13;
          if (streamStats.length &gt; 0) {&#13;
              contact.sendSoftphoneMetrics(streamStats, {&#13;
                 success: function(){&#13;
                     logger.info("sendSoftphoneMetrics success");&#13;
                 },&#13;
                 failure: function(data){&#13;
                     logger.error("sendSoftphoneMetrics failed.")&#13;
                        .withObject(data);&#13;
                 }&#13;
              });&#13;
          }&#13;
      };&#13;
  &#13;
      var sendSoftphoneReport = function(contact, report, userAudioStats, remoteAudioStats) {&#13;
          report.streamStats = [ addStreamTypeToStats(userAudioStats || {}, AUDIO_INPUT),&#13;
                                  addStreamTypeToStats(remoteAudioStats || {}, AUDIO_OUTPUT) ];&#13;
          var callReport = {&#13;
                          callStartTime: report.sessionStartTime,&#13;
                          callEndTime: report.sessionEndTime,&#13;
                          gumTimeMillis: report.gumTimeMillis,&#13;
                          initializationTimeMillis: report.initializationTimeMillis,&#13;
                          iceCollectionTimeMillis: report.iceCollectionTimeMillis,&#13;
                          signallingConnectTimeMillis: report.signallingConnectTimeMillis,&#13;
                          handshakingTimeMillis: report.handshakingTimeMillis,&#13;
                          preTalkingTimeMillis: report.preTalkingTimeMillis,&#13;
                          talkingTimeMillis: report.talkingTimeMillis,&#13;
                          cleanupTimeMillis: report.cleanupTimeMillis,&#13;
                          iceCollectionFailure: report.iceCollectionFailure,&#13;
                          signallingConnectionFailure: report.signallingConnectionFailure,&#13;
                          handshakingFailure: report.handshakingFailure,&#13;
                          gumOtherFailure: report.gumOtherFailure,&#13;
                          gumTimeoutFailure: report.gumTimeoutFailure,&#13;
                          createOfferFailure: report.createOfferFailure,&#13;
                          setLocalDescriptionFailure: report.setLocalDescriptionFailure,&#13;
                          userBusyFailure: report.userBusyFailure,&#13;
                          invalidRemoteSDPFailure: report.invalidRemoteSDPFailure,&#13;
                          noRemoteIceCandidateFailure: report.noRemoteIceCandidateFailure,&#13;
                          setRemoteDescriptionFailure: report.setRemoteDescriptionFailure,&#13;
                          softphoneStreamStatistics: report.streamStats&#13;
                        };&#13;
          contact.sendSoftphoneReport(callReport, {&#13;
              success: function(){&#13;
                  logger.info("sendSoftphoneReport success");&#13;
              },&#13;
              failure: function(data){&#13;
                  logger.error("sendSoftphoneReport failed.")&#13;
                      .withObject(data);&#13;
              }&#13;
          });&#13;
      };&#13;
  &#13;
      var startStatsCollectionJob = function(rtcSession) {&#13;
          rtpStatsJob = window.setInterval(function() {&#13;
              rtcSession.getUserAudioStats().then(function(stats) {&#13;
                  var previousUserStats = aggregatedUserAudioStats;&#13;
                  aggregatedUserAudioStats = stats;&#13;
                  timeSeriesStreamStatsBuffer.push(getTimeSeriesStats(aggregatedUserAudioStats, previousUserStats, AUDIO_INPUT));&#13;
              }, function(error) {&#13;
                  logger.debug("Failed to get user audio stats.", error);&#13;
              });&#13;
              rtcSession.getRemoteAudioStats().then(function(stats) {&#13;
                  var previousRemoteStats = aggregatedRemoteAudioStats;&#13;
                  aggregatedRemoteAudioStats = stats;&#13;
                  timeSeriesStreamStatsBuffer.push(getTimeSeriesStats(aggregatedRemoteAudioStats, previousRemoteStats, AUDIO_OUTPUT));&#13;
              }, function(error) {&#13;
                  logger.debug("Failed to get remote audio stats.", error);&#13;
              });&#13;
          }, 1000);&#13;
      };&#13;
  &#13;
      var startStatsReportingJob = function(contact) {&#13;
          reportStatsJob = window.setInterval(function() {&#13;
                             sendSoftphoneMetrics(contact);&#13;
          }, statsReportingJobIntervalMs);&#13;
      };&#13;
  &#13;
      var initializeParams = function() {&#13;
          aggregatedUserAudioStats = null;&#13;
          aggregatedRemoteAudioStats = null;&#13;
          timeSeriesStreamStatsBuffer = [];&#13;
          rtpStatsJob = null;&#13;
          reportStatsJob = null;&#13;
      };&#13;
  &#13;
      var getTimeSeriesStats = function(currentStats, previousStats, streamType) {&#13;
          if (previousStats &amp;&amp; currentStats) {&#13;
              var packetsLost = currentStats.packetsLost &gt; previousStats.packetsLost ? currentStats.packetsLost - previousStats.packetsLost : 0;&#13;
              var packetsCount = currentStats.packetsCount &gt; previousStats.packetsCount ? currentStats.packetsCount - previousStats.packetsCount : 0;&#13;
              return new RTPStreamStats(currentStats.timestamp,&#13;
                                        packetsLost,&#13;
                                        packetsCount,&#13;
                                        streamType,&#13;
                                        currentStats.audioLevel,&#13;
                                        currentStats.jbMilliseconds,&#13;
                                        currentStats.rttMilliseconds);&#13;
          } else {&#13;
              return new RTPStreamStats(currentStats.timestamp,&#13;
                                        currentStats.packetsLost,&#13;
                                        currentStats.packetsCount,&#13;
                                        streamType,&#13;
                                        currentStats.audioLevel,&#13;
                                        currentStats.jbMilliseconds,&#13;
                                        currentStats.rttMilliseconds);&#13;
          }&#13;
      };&#13;
  &#13;
      var stopJob = function(task) {&#13;
          if (task !== null){&#13;
              window.clearInterval(task);&#13;
          }&#13;
          return null;&#13;
      };&#13;
  &#13;
      var stopJobsAndReport = function(contact, sessionReport) {&#13;
         rtpStatsJob = stopJob(rtpStatsJob);&#13;
         reportStatsJob = stopJob(reportStatsJob);&#13;
         sendSoftphoneReport(contact, sessionReport, addStreamTypeToStats(aggregatedUserAudioStats, AUDIO_INPUT), addStreamTypeToStats(aggregatedRemoteAudioStats, AUDIO_OUTPUT));&#13;
         sendSoftphoneMetrics(contact);&#13;
      };&#13;
  &#13;
      /**&#13;
      *   Adding streamtype parameter on top of RTCJS RTStats object.&#13;
      */&#13;
      var RTPStreamStats = function(timestamp, packetsLost, packetsCount, streamType, audioLevel, jitterBufferMillis, roundTripTimeMillis) {&#13;
          this.softphoneStreamType = streamType;&#13;
          this.timestamp = timestamp;&#13;
          this.packetsLost = packetsLost;&#13;
          this.packetsCount = packetsCount;&#13;
          this.audioLevel = audioLevel;&#13;
          this.jitterBufferMillis = jitterBufferMillis;&#13;
          this.roundTripTimeMillis = roundTripTimeMillis;&#13;
      };&#13;
  &#13;
      var addStreamTypeToStats = function(stats, streamType) {&#13;
          return new RTPStreamStats(stats.timestamp, stats.packetsLost, stats.packetsCount, streamType, stats.audioLevel);&#13;
      };&#13;
  &#13;
      var SoftphoneLogger = function(logger) {&#13;
          this._originalLogger = logger;&#13;
          var self = this;&#13;
          this._tee = function(level, method) {&#13;
              return function() {&#13;
                  // call the original logger object to output to browser&#13;
                  //Connect logger follows %s format to print objects to console.&#13;
                  var args = Array.prototype.slice.call(arguments[0]);&#13;
                  var format = "";&#13;
                  args.forEach(function(){&#13;
                      format = format + " %s";&#13;
                  });&#13;
                  method.apply(self._originalLogger, [connect.LogComponent.SOFTPHONE, format].concat(args));&#13;
              };&#13;
          };&#13;
      };&#13;
  &#13;
      SoftphoneLogger.prototype.debug =  function() {&#13;
          this._tee(1, this._originalLogger.debug)(arguments);&#13;
      };&#13;
      SoftphoneLogger.prototype.info =  function() {&#13;
          this._tee(2, this._originalLogger.info)(arguments);&#13;
      };&#13;
      SoftphoneLogger.prototype.log =  function() {&#13;
          this._tee(3, this._originalLogger.log)(arguments);&#13;
      };&#13;
      SoftphoneLogger.prototype.warn =  function() {&#13;
          this._tee(4, this._originalLogger.warn)(arguments);&#13;
      };&#13;
      SoftphoneLogger.prototype.error =  function() {&#13;
          this._tee(5, this._originalLogger.error)(arguments);&#13;
      };&#13;
  &#13;
      connect.SoftphoneManager = SoftphoneManager;&#13;
  })();&#13;
  /*&#13;
   * Copyright 2014-2017 Amazon.com, Inc. or its affiliates. All Rights Reserved.&#13;
   *&#13;
   * Licensed under the Amazon Software License (the "License"). You may not use&#13;
   * this file except in compliance with the License. A copy of the License is&#13;
   * located at&#13;
   *&#13;
   *    http://aws.amazon.com/asl/&#13;
   *&#13;
   * or in the "license" file accompanying this file. This file is distributed&#13;
   * on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, express&#13;
   * or implied. See the License for the specific language governing permissions&#13;
   * and limitations under the License.&#13;
   */&#13;
  (function() {&#13;
     var global = this;&#13;
     connect = global.connect || {};&#13;
     global.connect = connect;&#13;
     global.lily = connect;&#13;
  &#13;
     connect.worker = {};&#13;
  &#13;
     var GET_AGENT_TIMEOUT = 30000;&#13;
     var GET_AGENT_RECOVERY_TIMEOUT = 5000;&#13;
     var GET_AGENT_SUCCESS_TIMEOUT = 100;&#13;
     var LOG_BUFFER_CAP_SIZE = 400;&#13;
  &#13;
     var GET_AGENT_CONFIGURATION_INTERVAL = 30000;      // 30sec&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     var MasterTopicCoordinator = function() {&#13;
        this.topicMasterMap = {};&#13;
     };&#13;
  &#13;
     MasterTopicCoordinator.prototype.getMaster = function(topic) {&#13;
        connect.assertNotNull(topic, 'topic');&#13;
        return this.topicMasterMap[topic] || null;&#13;
     };&#13;
  &#13;
     MasterTopicCoordinator.prototype.setMaster = function(topic, id) {&#13;
        connect.assertNotNull(topic, 'topic');&#13;
        connect.assertNotNull(id, 'id');&#13;
        this.topicMasterMap[topic] = id;&#13;
     };&#13;
  &#13;
     MasterTopicCoordinator.prototype.removeMaster = function(id) {&#13;
        connect.assertNotNull(id, 'id');&#13;
        var self = this;&#13;
  &#13;
        connect.entries(this.topicMasterMap).filter(function(entry) {&#13;
           return entry.value === id;&#13;
        }).forEach(function(entry) {&#13;
           delete self.topicMasterMap[entry.key];&#13;
        });&#13;
     };&#13;
  &#13;
     /**-------------------------------------------------------------------------&#13;
      * The object responsible for polling and passing data downstream to all&#13;
      * consumer ports.&#13;
      */&#13;
     var ClientEngine = function() {&#13;
        var self = this;&#13;
  &#13;
        this.client = null;&#13;
        this.multiplexer = new connect.StreamMultiplexer();&#13;
        this.conduit = new connect.Conduit("AmazonConnectSharedWorker", null, this.multiplexer);&#13;
        this.timeout = null;&#13;
        this.agent = null;&#13;
        this.nextToken = null;&#13;
        this.initData = {};&#13;
        this.portConduitMap = {};&#13;
        this.masterCoord = new MasterTopicCoordinator();&#13;
        this.logsBuffer = [];&#13;
  &#13;
        connect.rootLogger = new connect.DownstreamConduitLogger(this.conduit);&#13;
  &#13;
        this.conduit.onDownstream(connect.EventType.SEND_LOGS, function(logsToUpload) {&#13;
           self.logsBuffer = self.logsBuffer.concat(logsToUpload);&#13;
           //only call API to send logs if buffer reached cap&#13;
           if (self.logsBuffer.length &gt; LOG_BUFFER_CAP_SIZE) {&#13;
              self.handleSendLogsRequest(self.logsBuffer);&#13;
           }&#13;
        });&#13;
        this.conduit.onDownstream(connect.EventType.CONFIGURE, function(data) {&#13;
           if (data.authToken &amp;&amp; data.authToken !== self.initData.authToken) {&#13;
              self.initData = data;&#13;
              connect.core.init(data);&#13;
  &#13;
              // Start polling for agent data.&#13;
              self.pollForAgent();&#13;
              self.pollForAgentConfiguration({repeatForever: true});&#13;
           }&#13;
        });&#13;
        this.conduit.onDownstream(connect.EventType.TERMINATE, function() {&#13;
           //upload pending logs before terminating.&#13;
           self.handleSendLogsRequest(self.logsBuffer);&#13;
           connect.core.terminate();&#13;
           self.conduit.sendDownstream(connect.EventType.TERMINATED);&#13;
        });&#13;
        this.conduit.onDownstream(connect.EventType.SYNCHRONIZE, function() {&#13;
           self.conduit.sendDownstream(connect.EventType.ACKNOWLEDGE);&#13;
        });&#13;
        this.conduit.onDownstream(connect.EventType.BROADCAST, function(data) {&#13;
           self.conduit.sendDownstream(data.event, data.data);&#13;
        });&#13;
  &#13;
        /**&#13;
         * Called when a consumer port connects to this SharedWorker.&#13;
         * Let's add them to our multiplexer.&#13;
         */&#13;
        global.onconnect = function(event) {&#13;
           var port = event.ports[0];&#13;
           var stream = new connect.PortStream(port);&#13;
           self.multiplexer.addStream(stream);&#13;
           port.start();&#13;
  &#13;
           var portConduit = new connect.Conduit(stream.getId(), null, stream);&#13;
           portConduit.sendDownstream(connect.EventType.ACKNOWLEDGE, {id: stream.getId()});&#13;
  &#13;
           self.portConduitMap[stream.getId()] = portConduit;&#13;
  &#13;
           if (self.agent !== null) {&#13;
              portConduit.sendDownstream(connect.AgentEvents.UPDATE, self.agent);&#13;
           }&#13;
  &#13;
           portConduit.onDownstream(connect.EventType.API_REQUEST,&#13;
                 connect.hitch(self, self.handleAPIRequest, portConduit));&#13;
           portConduit.onDownstream(connect.EventType.MASTER_REQUEST,&#13;
                 connect.hitch(self, self.handleMasterRequest, portConduit, stream.getId()));&#13;
           portConduit.onDownstream(connect.EventType.RELOAD_AGENT_CONFIGURATION,&#13;
                 connect.hitch(self, self.pollForAgentConfiguration));&#13;
           portConduit.onDownstream(connect.EventType.CLOSE, function() {&#13;
              self.multiplexer.removeStream(stream);&#13;
              delete self.portConduitMap[stream.getId()];&#13;
              self.masterCoord.removeMaster(stream.getId());&#13;
           });&#13;
        };&#13;
     };&#13;
  &#13;
     ClientEngine.prototype.pollForAgent = function() {&#13;
        var self = this;&#13;
        var client = connect.core.getClient();&#13;
  &#13;
        this.checkAuthToken();&#13;
  &#13;
        client.call(connect.ClientMethods.GET_AGENT_SNAPSHOT, {&#13;
           nextToken:     self.nextToken,&#13;
           timeout:       GET_AGENT_TIMEOUT&#13;
        }, {&#13;
           success: function(data) {&#13;
              self.agent = self.agent || {};&#13;
              self.agent.snapshot = data.snapshot;&#13;
              self.agent.snapshot.localTimestamp = connect.now();&#13;
              self.agent.snapshot.skew = self.agent.snapshot.snapshotTimestamp - self.agent.snapshot.localTimestamp;&#13;
              self.nextToken = data.nextToken;&#13;
              self.updateAgent();&#13;
              global.setTimeout(connect.hitch(self, self.pollForAgent), GET_AGENT_SUCCESS_TIMEOUT);&#13;
           },&#13;
           failure: function(err, data) {&#13;
              try {&#13;
                 connect.getLog().error("Failed to get agent data.")&#13;
                    .withObject({&#13;
                       err: err,&#13;
                       data: data&#13;
                    });&#13;
  &#13;
              } finally {&#13;
                 global.setTimeout(connect.hitch(self, self.pollForAgent), GET_AGENT_RECOVERY_TIMEOUT);&#13;
              }&#13;
           },&#13;
           authFailure: connect.hitch(self, self.handleAuthFail)&#13;
        });&#13;
  &#13;
     };&#13;
  &#13;
     ClientEngine.prototype.pollForAgentConfiguration = function(paramsIn) {&#13;
        var self = this;&#13;
        var client = connect.core.getClient();&#13;
        var params = paramsIn || {};&#13;
  &#13;
        client.call(connect.ClientMethods.GET_AGENT_CONFIGURATION, {}, {&#13;
           success: function(data) {&#13;
              var configuration = data.configuration;&#13;
              self.pollForAgentPermissions(configuration);&#13;
              self.pollForAgentStates(configuration);&#13;
              self.pollForDialableCountryCodes(configuration);&#13;
              self.pollForRoutingProfileQueues(configuration);&#13;
              if (params.repeatForever) {&#13;
                 global.setTimeout(connect.hitch(self, self.pollForAgentConfiguration, params),&#13;
                    GET_AGENT_CONFIGURATION_INTERVAL);&#13;
              }&#13;
           },&#13;
           failure: function(err, data) {&#13;
              try {&#13;
                 connect.getLog().error("Failed to fetch agent configuration data.")&#13;
                    .withObject({&#13;
                       err: err,&#13;
                       data: data&#13;
                    });&#13;
              } finally {&#13;
                 if (params.repeatForever) {&#13;
                    global.setTimeout(connect.hitch(self, self.pollForAgentConfiguration),&#13;
                       GET_AGENT_CONFIGURATION_INTERVAL, params);&#13;
                 }&#13;
              }&#13;
           },&#13;
           authFailure: connect.hitch(self, self.handleAuthFail)&#13;
        });&#13;
     };&#13;
  &#13;
     ClientEngine.prototype.pollForAgentStates = function(configuration, paramsIn) {&#13;
        var self = this;&#13;
        var client = connect.core.getClient();&#13;
        var params = paramsIn || {};&#13;
        params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;&#13;
  &#13;
        client.call(connect.ClientMethods.GET_AGENT_STATES, {&#13;
           nextToken: params.nextToken || null,&#13;
           maxResults: params.maxResults&#13;
  &#13;
        }, {&#13;
           success: function(data) {&#13;
              if (data.nextToken) {&#13;
                 self.pollForAgentStates(configuration, {&#13;
                    states:   (params.states || []).concat(data.states),&#13;
                    nextToken:     data.nextToken,&#13;
                    maxResults:    params.maxResults&#13;
                 });&#13;
  &#13;
              } else {&#13;
                 configuration.agentStates = (params.states || []).concat(data.states);&#13;
                 self.updateAgentConfiguration(configuration);&#13;
              }&#13;
           },&#13;
           failure: function(err, data) {&#13;
              connect.getLog().error("Failed to fetch agent states list.")&#13;
                 .withObject({&#13;
                    err: err,&#13;
                    data: data&#13;
                 });&#13;
           },&#13;
           authFailure: connect.hitch(self, self.handleAuthFail)&#13;
        });&#13;
     };&#13;
  &#13;
     ClientEngine.prototype.pollForAgentPermissions = function(configuration, paramsIn) {&#13;
        var self = this;&#13;
        var client = connect.core.getClient();&#13;
        var params = paramsIn || {};&#13;
        params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;&#13;
  &#13;
        client.call(connect.ClientMethods.GET_AGENT_PERMISSIONS, {&#13;
           nextToken: params.nextToken || null,&#13;
           maxResults: params.maxResults&#13;
  &#13;
        }, {&#13;
           success: function(data) {&#13;
              if (data.nextToken) {&#13;
                 self.pollForAgentPermissions(configuration, {&#13;
                    permissions:   (params.permissions || []).concat(data.permissions),&#13;
                    nextToken:     data.nextToken,&#13;
                    maxResults:    params.maxResults&#13;
                 });&#13;
  &#13;
              } else {&#13;
                 configuration.permissions = (params.permissions || []).concat(data.permissions);&#13;
                 self.updateAgentConfiguration(configuration);&#13;
              }&#13;
           },&#13;
           failure: function(err, data) {&#13;
              connect.getLog().error("Failed to fetch agent permissions list.")&#13;
                 .withObject({&#13;
                    err: err,&#13;
                    data: data&#13;
                 });&#13;
           },&#13;
           authFailure: connect.hitch(self, self.handleAuthFail)&#13;
        });&#13;
     };&#13;
  &#13;
     ClientEngine.prototype.pollForDialableCountryCodes = function(configuration, paramsIn) {&#13;
        var self = this;&#13;
        var client = connect.core.getClient();&#13;
        var params = paramsIn || {};&#13;
        params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;&#13;
  &#13;
        client.call(connect.ClientMethods.GET_DIALABLE_COUNTRY_CODES, {&#13;
           nextToken: params.nextToken || null,&#13;
           maxResults: params.maxResults&#13;
        }, {&#13;
           success: function(data) {&#13;
              if (data.nextToken) {&#13;
                 self.pollForDialableCountryCodes(configuration, {&#13;
                    countryCodes:  (params.countryCodes || []).concat(data.countryCodes),&#13;
                    nextToken:     data.nextToken,&#13;
                    maxResults:    params.maxResults&#13;
                 });&#13;
  &#13;
              } else {&#13;
                 configuration.dialableCountries = (params.countryCodes || []).concat(data.countryCodes);&#13;
                 self.updateAgentConfiguration(configuration);&#13;
              }&#13;
           },&#13;
           failure: function(err, data) {&#13;
              connect.getLog().error("Failed to fetch dialable country codes list.")&#13;
                 .withObject({&#13;
                    err: err,&#13;
                    data: data&#13;
                 });&#13;
           },&#13;
           authFailure: connect.hitch(self, self.handleAuthFail)&#13;
        });&#13;
     };&#13;
  &#13;
     ClientEngine.prototype.pollForRoutingProfileQueues = function(configuration, paramsIn) {&#13;
        var self = this;&#13;
        var client = connect.core.getClient();&#13;
        var params = paramsIn || {};&#13;
        params.maxResults = params.maxResults || connect.DEFAULT_BATCH_SIZE;&#13;
  &#13;
        client.call(connect.ClientMethods.GET_ROUTING_PROFILE_QUEUES, {&#13;
           routingProfileARN: configuration.routingProfile.routingProfileARN,&#13;
           nextToken: params.nextToken || null,&#13;
           maxResults: params.maxResults&#13;
        }, {&#13;
           success: function(data) {&#13;
              if (data.nextToken) {&#13;
                 self.pollForRoutingProfileQueues(configuration, {&#13;
                    countryCodes:  (params.queues || []).concat(data.queues),&#13;
                    nextToken:     data.nextToken,&#13;
                    maxResults:    params.maxResults&#13;
                 });&#13;
  &#13;
              } else {&#13;
                 configuration.routingProfile.queues = (params.queues || []).concat(data.queues);&#13;
                 self.updateAgentConfiguration(configuration);&#13;
              }&#13;
           },&#13;
           failure: function(err, data) {&#13;
              connect.getLog().error("Failed to fetch routing profile queues list.")&#13;
                 .withObject({&#13;
                    err: err,&#13;
                    data: data&#13;
                 });&#13;
           },&#13;
           authFailure: connect.hitch(self, self.handleAuthFail)&#13;
        });&#13;
     };&#13;
  &#13;
     ClientEngine.prototype.handleAPIRequest = function(portConduit, request) {&#13;
        var self = this;&#13;
        var client = connect.core.getClient();&#13;
        client.call(request.method, request.params, {&#13;
           success: function(data) {&#13;
              var response = connect.EventFactory.createResponse(connect.EventType.API_RESPONSE, request, data);&#13;
              portConduit.sendDownstream(response.event, response);&#13;
           },&#13;
           failure: function(err, data) {&#13;
              var response = connect.EventFactory.createResponse(connect.EventType.API_RESPONSE, request, data, JSON.stringify(err));&#13;
              portConduit.sendDownstream(response.event, response);&#13;
              connect.getLog().error("'%s' API request failed: %s", request.method, err)&#13;
                 .withObject({request: request, response: response});&#13;
           },&#13;
           authFailure: connect.hitch(self, self.handleAuthFail)&#13;
        });&#13;
     };&#13;
  &#13;
     /**&#13;
      * Handle incoming master query or modification requests from connected tab ports.&#13;
      */&#13;
     ClientEngine.prototype.handleMasterRequest = function(portConduit, portId, request) {&#13;
        var response = null;&#13;
  &#13;
        switch(request.method) {&#13;
        case connect.MasterMethods.BECOME_MASTER:&#13;
           this.masterCoord.setMaster(request.params.topic, portId);&#13;
           response = connect.EventFactory.createResponse(connect.EventType.MASTER_RESPONSE, request, {&#13;
              masterId:   portId,&#13;
              isMaster:   true,&#13;
              topic:      request.params.topic&#13;
           });&#13;
  &#13;
           break;&#13;
  &#13;
        case connect.MasterMethods.CHECK_MASTER:&#13;
           var masterId = this.masterCoord.getMaster(request.params.topic);&#13;
           if (!masterId) {&#13;
              this.masterCoord.setMaster(request.params.topic, portId);&#13;
              masterId = portId;&#13;
           }&#13;
  &#13;
           response = connect.EventFactory.createResponse(connect.EventType.MASTER_RESPONSE, request, {&#13;
              masterId:   masterId,&#13;
              isMaster:   portId === masterId,&#13;
              topic:      request.params.topic&#13;
           });&#13;
  &#13;
           break;&#13;
  &#13;
        default:&#13;
           throw new Error("Unknown master method: " + request.method);&#13;
        }&#13;
  &#13;
        portConduit.sendDownstream(response.event, response);&#13;
     };&#13;
  &#13;
     ClientEngine.prototype.updateAgentConfiguration = function(configuration) {&#13;
        if (configuration.permissions &amp;&amp;&#13;
            configuration.dialableCountries &amp;&amp;&#13;
            configuration.agentStates &amp;&amp;&#13;
            configuration.routingProfile.queues) {&#13;
  &#13;
           this.agent = this.agent || {};&#13;
           this.agent.configuration = configuration;&#13;
           this.updateAgent();&#13;
  &#13;
        } else {&#13;
           connect.getLog().trace("Waiting to update agent configuration until all config data has been fetched.");&#13;
        }&#13;
     };&#13;
  &#13;
     ClientEngine.prototype.updateAgent = function() {&#13;
        if (! this.agent) {&#13;
           connect.getLog().trace("Waiting to update agent until the agent has been fully constructed.");&#13;
  &#13;
        } else if (! this.agent.snapshot) {&#13;
           connect.getLog().trace("Waiting to update agent until the agent snapshot is available.");&#13;
  &#13;
        } else if (! this.agent.configuration) {&#13;
           connect.getLog().trace("Waiting to update agent until the agent configuration is available.");&#13;
  &#13;
        } else {&#13;
           // Alias some of the properties for backwards compatibility.&#13;
           this.agent.snapshot.status = this.agent.state;&#13;
           this.agent.snapshot.contacts.forEach(function(contact) {&#13;
              contact.status = contact.state;&#13;
  &#13;
              contact.connections.forEach(function(connection) {&#13;
                 connection.address = connection.endpoint;&#13;
              });&#13;
           });&#13;
  &#13;
           this.agent.configuration.routingProfile.defaultOutboundQueue.queueId =&#13;
              this.agent.configuration.routingProfile.defaultOutboundQueue.queueARN;&#13;
           this.agent.configuration.routingProfile.queues.forEach(function(queue) {&#13;
              queue.queueId = queue.queueARN;&#13;
           });&#13;
           this.agent.snapshot.contacts.forEach(function(contact) {&#13;
              //contact.queue is null when monitoring&#13;
              if (contact.queue !== undefined) {&#13;
                  contact.queue.queueId = contact.queue.queueARN;&#13;
              }&#13;
           });&#13;
           this.agent.configuration.routingProfile.routingProfileId =&#13;
              this.agent.configuration.routingProfile.routingProfileARN;&#13;
  &#13;
           this.conduit.sendDownstream(connect.AgentEvents.UPDATE, this.agent);&#13;
        }&#13;
     };&#13;
  &#13;
     /**&#13;
      * Send a message downstream to all consumers when we detect that authentication&#13;
      * against one of our APIs has failed.&#13;
      */&#13;
     ClientEngine.prototype.handleSendLogsRequest = function() {&#13;
        var self = this;&#13;
        var client = connect.core.getClient();&#13;
        var logEvents = [];&#13;
        var logsToSend = self.logsBuffer.slice();&#13;
        self.logsBuffer = [];&#13;
        logsToSend.forEach(function(log) {&#13;
           logEvents.push({&#13;
              timestamp:  log.time,&#13;
              component:  log.component,&#13;
              message: log.text&#13;
           });&#13;
        });&#13;
        client.call(connect.ClientMethods.SEND_CLIENT_LOGS, {logEvents: logEvents}, {&#13;
           success: function(data) {&#13;
              connect.getLog().info("SendLogs request succeeded.");&#13;
           },&#13;
           failure: function(err, data) {&#13;
              connect.getLog().error("SendLogs request failed. %s", err);&#13;
           },&#13;
           authFailure: connect.hitch(self, self.handleAuthFail)&#13;
        });&#13;
     };&#13;
  &#13;
     ClientEngine.prototype.handleAuthFail = function() {&#13;
        var self = this;&#13;
        self.conduit.sendDownstream(connect.EventType.AUTH_FAIL);&#13;
     };&#13;
  &#13;
     ClientEngine.prototype.checkAuthToken = function() {&#13;
        var self = this;&#13;
        var expirationDate = new Date(self.initData.authTokenExpiration);&#13;
        var currentTimeStamp = new Date().getTime();&#13;
        var fiveMins = 5 * 60 * 1000;&#13;
  &#13;
        // refresh token 5 minutes before expiration&#13;
        if (expirationDate.getTime() &lt; (currentTimeStamp + fiveMins)) {&#13;
          this.refreshAuthToken();&#13;
        }&#13;
     };&#13;
  &#13;
     ClientEngine.prototype.refreshAuthToken = function() {&#13;
        var self = this;&#13;
        connect.assertNotNull(self.initData.refreshToken, 'initData.refreshToken');&#13;
  &#13;
        var client = connect.core.getClient();&#13;
        client.call(connect.ClientMethods.GET_NEW_AUTH_TOKEN, {refreshToken: self.initData.refreshToken}, {&#13;
           success: function(data) {&#13;
              connect.getLog().info("Get new auth token succeeded. New auth token expired at %s", data.expirationDateTime);&#13;
              self.initData.authToken = data.newAuthToken;&#13;
              self.initData.authTokenExpiration = new Date(data.expirationDateTime);&#13;
              connect.core.init(self.initData);&#13;
           },&#13;
           failure: function(err, data) {&#13;
              connect.getLog().error("Get new auth token failed. %s ", err);&#13;
              self.conduit.sendDownstream(connect.EventType.AUTH_FAIL);&#13;
           },&#13;
           authFailure: connect.hitch(self, self.handleAuthFail)&#13;
        });&#13;
     };&#13;
  &#13;
     /**-----------------------------------------------------------------------*/&#13;
     connect.worker.main = function() {&#13;
        connect.worker.clientEngine = new ClientEngine();&#13;
     };&#13;
  &#13;
  })();&#13;
  </script>
        <script_name>amazon-connect-1.0</script_name>
        <sys_class_name>sys_ui_script</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2019-03-05 06:15:50</sys_created_on>
        <sys_id>74972db4db003300ebcba455ca96194e</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_name>x_317887_amazon.amazon-connect-1.0</sys_name>
        <sys_package display_value="Amazon" source="x_317887_amazon">686765b4db003300ebcba455ca9619c4</sys_package>
        <sys_policy/>
        <sys_scope display_value="Amazon">686765b4db003300ebcba455ca9619c4</sys_scope>
        <sys_update_name>sys_ui_script_74972db4db003300ebcba455ca96194e</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2019-03-05 06:15:50</sys_updated_on>
        <ui_type>0</ui_type>
        <use_scoped_format>false</use_scoped_format>
    </sys_ui_script>
</record_update>
